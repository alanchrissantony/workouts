

# --- Next Function Block ---

import re
import math
from abc import ABC, abstractmethod
from collections import Counter
import functools
import string
import random

class A:
    def print():
        pass
# -----------------------------------------------------
# Function 1: Insertion sort (in-place) using insertion‐like algorithm.
def insertion_sort(arr: list) -> list:
    """
    Sorts the list 'arr' using a variant of insertion sort.
    
    Example:
      Input: [4, 2, 1, 3]
      Output: [1, 2, 3, 4]
    """
    head = arr.copy()
    i = 1
    while i < len(head):
        if head[i] < head[i - 1]:
            j = i - 1
            # Move left until we find a position where head[i] is not less.
            while j >= 0 and head[i] < head[j]:
                j -= 1
            # Insert head[i] at the correct position.
            head.insert(j + 1, head[i])
            # Remove the duplicate element (since head[i] was shifted).
            del head[i + 1]
        else:
            i += 1
    return head


# --- Next Function Block ---


# -----------------------------------------------------
# Function 2: Pairwise swap (inserting elements from end into the middle)
def pairwise_swap(head: list) -> list:
    """
    Given a list 'head', inserts elements from the end into the middle positions.
    The snippet shows inserting element at the end at index i and then removing the duplicate.
    
    Example:
      Input: [1]
      Output: [1]  (For a single element, nothing changes.)
    """
    head = head.copy()
    i = 1
    j = len(head) - 1
    while j > i:
        head.insert(i, head[j])
        del head[j + 1]
        i += 2
    return head


# --- Next Function Block ---


# -----------------------------------------------------
# Function 3: Demonstrate closure with a global variable.
def demonstrate_closure() -> None:
    """
    Demonstrates variable lookup in a closure by printing a global variable.
    """
    def f():
        print(x)
    x = 1
    f()


# --- Next Function Block ---


class A:
    def print():
        pass

# -----------------------------------------------------
# Function 4: Rotate a list by k positions (to the right).
def rotate_list(head: list, k: int) -> list:
    """
    Rotates the list 'head' to the right by k positions.
    
    Example:
      head = [0,1,2], k = 3
      Since k % len(head) == 0, the rotated list is the same.
    """
    n = len(head)
    if n == 0:
        return head
    k = k % n
    # Using slicing for rotation:
    return head[-k:] + head[:-k]


# --- Next Function Block ---


# -----------------------------------------------------
# Function 5: Count distinct substrings in a reversed string.
def count_distinct_substrings(s: str) -> int:
    """
    Reverses the string s, then counts distinct substrings generated by
    expanding from each character.
    
    Note: The original snippet is ambiguous; this function uses a simple
    method to count all distinct substrings.
    """
    s = s[::-1]
    substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substrings.add(s[i:j])
    return len(substrings)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 6: Append text to a file and then read its contents.
def append_and_read_file(filename: str, text: str) -> None:
    """
    Appends 'text' to the file 'filename' and then prints its contents.
    """
    with open(filename, "a") as f:
        f.write(text)
    with open(filename, "r") as f:
        for line in f:
            print(line, end="")


# --- Next Function Block ---


# -----------------------------------------------------
# Function 7: Print numbers missing in a list.
def get_missing_numbers(arr: list) -> list:
    """
    Given a list 'arr', prints and returns numbers in range [0, max(arr))
    that are not present in arr.
    """
    missing = []
    for i in range(max(arr)):
        if i not in arr:
            missing.append(i)
    return missing


# --- Next Function Block ---


# -----------------------------------------------------
# Function 8: Reverse a subarray between two 1-indexed positions.
def reverse_subarray(head: list, left: int, right: int) -> list:
    """
    Reverses a portion of the list 'head' from index left-1 to right-1 (inclusive).
    
    Example:
      head = [1,2,3,4,5,6,8], left = 2, right = 4
      Output: [1, 4, 3, 2, 5, 6, 8]
    """
    # Convert left and right to 0-indexed.
    left_idx = left - 1
    right_idx = right
    new_list = head[:left_idx] + head[left_idx:right_idx][::-1] + head[right_idx:]
    return new_list


# --- Next Function Block ---


# -----------------------------------------------------
# Function 9: Print increasing slices of a list.
def print_increasing_slices(head: list) -> None:
    """
    For each index i in head, prints the slice head[i:j] where j increases based on a rule.
    (The original snippet increases j by j-i each iteration.)
    """
    i = 0
    j = 1
    while i < len(head):
        print(head[i:j])
        i += 1
        j += (j - i)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 10: Remove up to k occurrences across groups and return distinct group count.
def remove_k_occurrences(arr: list, k: int) -> int:
    """
    Counts the occurrences of each element in arr and then “removes” up to k occurrences across groups.
    Returns the number of groups (distinct elements) remaining after removals.
    
    This function uses the Counter to get counts, then iterates through the sorted counts.
    (Based on snippet logic, returns len(count) - j, where j is incremented when count goes below 1.)
    """
    counts = dict(sorted(Counter(arr).items(), key=lambda item: item[1]))
    j = 0
    flag = False
    for key in counts:
        while counts[key] > 0:
            if k > 0:
                counts[key] -= 1
                k -= 1
                if counts[key] < 1:
                    j += 1
            else:
                flag = True
                break
        if flag:
            break
    return len(counts) - j


# --- Next Function Block ---


# -----------------------------------------------------
# Function 11: Reverse chunks of a list (based on index modulus k).
def reverse_chunks(arr: list, k: int) -> list:
    """
    Divides the list 'arr' into chunks of size k and reverses each chunk.
    If the last chunk is smaller than k, leaves it as is.
    
    Example:
      arr = [1,2,3,4], k = 2 → returns [2,1,4,3]
    """
    result = []
    for i in range(0, len(arr), k):
        chunk = arr[i:i+k]
        if len(chunk) == k:
            result.extend(chunk[::-1])
        else:
            result.extend(chunk)
    return result


# --- Next Function Block ---


# -----------------------------------------------------
# Function 12: Transform list by conditional chunk reversal.
def transform_list_by_chunks(arr: list) -> list:
    """
    Transforms the list 'arr' by taking chunks (whose size depends on a changing parameter k)
    and reverses the chunk if its length is even, otherwise leaves it as is.
    
    The update of the start index uses the rule i = k*k - i and increments k by 1 each iteration.
    (This is one interpretation of the snippet.)
    """
    nums = []
    i = 0
    k = 1
    n = len(arr)
    while i < n:
        # Determine chunk size as k; slice from i to i+k.
        chunk = arr[i:i+k]
        if len(chunk) % 2 == 0:
            nums.extend(chunk[::-1])
        else:
            nums.extend(chunk)
        # Update i as shown in snippet: i = k*k - i.
        i = k * k - i
        k += 1
    return nums


# --- Next Function Block ---


# -----------------------------------------------------
# Function 13: Remove elements until list is sorted.
def remove_until_sorted(nums: list) -> (list, int):
    """
    Repeatedly removes an element that is out of order until the list is sorted.
    Returns a tuple of (final sorted list, number of iterations).
    
    Example:
      nums = [4,5,7,7,13]
    """
    count = 0
    while nums != sorted(nums):
        i = 0
        while i < len(nums) - 1:
            if nums[i+1] < nums[i]:
                del nums[i+1]
            else:
                i += 1
        count += 1
    return nums, count


# --- Next Function Block ---


# -----------------------------------------------------
# Function 14: Count common elements in two lists.
def count_common_elements(head: list, nums: list) -> int:
    """
    Counts how many elements in 'head' are also present in 'nums'.
    
    Example:
      head = [0,1,2,3], nums = [0,1,3] → returns 3.
    """
    count = 0
    for item in head:
        if item in nums:
            count += 1
    return count


# --- Next Function Block ---


# -----------------------------------------------------
# Function 15: Length of sublist after the maximum element.
def length_after_max(head: list) -> int:
    """
    Returns the length of the sublist after the maximum element in head.
    
    Example:
      head = [5,2,13] → maximum is 13 at index 2, so returns len(head) - 3 = 0.
    """
    if not head:
        return 0
    max_val = max(head)
    max_index = head.index(max_val)
    return len(head) - (max_index + 1)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 16: Maximum reachable index with given bricks and ladders.
def max_reachable_index(heights: list, bricks: int, ladders: int) -> int:
    """
    Simulates moving from the first building to subsequent buildings using bricks and ladders.
    For each step, if the next building is higher, uses bricks (or ladders if insufficient bricks).
    Returns the maximum index reached (0-indexed).
    
    Example:
      heights = [14,3,19,3], bricks = 17, ladders = 0.
    """
    i = 0
    while i < len(heights) - 1:
        diff = heights[i+1] - heights[i]
        if diff > 0:
            if diff > bricks and ladders > 0:
                ladders -= 1
            elif diff <= bricks:
                bricks -= diff
            else:
                break
        i += 1
    return i


# --- Next Function Block ---


# -----------------------------------------------------
# Function 17: Insert GCD between adjacent elements.
def insert_gcd_between_adjacent(arr: list) -> list:
    """
    For each pair of adjacent elements in arr, computes their GCD and inserts it between them.
    
    Example:
      arr = [18,6,10,3] 
      Returns a new list with the GCD inserted between adjacent pairs.
    """
    def gcd(a, b):
        return math.gcd(a, b)
    res = []
    for i in range(len(arr)-1):
        res.append(arr[i])
        res.append(gcd(arr[i], arr[i+1]))
    res.append(arr[-1])
    return res


# --- Next Function Block ---


# -----------------------------------------------------
# Function 18: Merge parts of two lists.
def merge_lists(list1: list, list2: list, a: int, b: int) -> list:
    """
    Merges segments of list1 and list2:
      - Takes the first a elements from list1.
      - Then all elements from list2.
      - Then all elements of list1 after index b.
    
    Example:
      list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]
      Returns: list1[:3] + list2 + list1[5:]
    """
    return list1[:a] + list2 + list1[b+1:]


# --- Next Function Block ---




# -----------------------------------------------------
# Function 1: Find the nth number in a custom sequence.
def find_nth_number(n: int) -> int:
    """
    Finds and returns the nth number in a sequence defined by:
      - For numbers less than 7, every number is counted.
      - For numbers >= 7, if the number is divisible by 7, it is skipped.
      - Otherwise, if the number is composite (i.e. it has a divisor other than 1 and itself), it is counted.
    
    This is one interpretation of the snippet.
    """
    count = 0
    i = 1
    while count < n:
        if i < 7:
            count += 1
        else:
            # Skip numbers divisible by 7.
            if i % 7 == 0:
                i += 1
                continue
            prime_flag = False  # Actually, true means composite.
            j = 2
            while j < i:
                if i % j == 0:
                    prime_flag = True
                    break
                j += 1
            if prime_flag:
                count += 1
                print("Counting:", i)
        if count == n:
            break
        i += 1
    return i


# --- Next Function Block ---


# -----------------------------------------------------
# Function 2: Process folder paths and select one per key.
def process_folders(folders: list) -> dict:
    """
    Processes a list of folder paths and builds a dictionary keyed by the first two characters.
    If a key already exists, the folder with the shorter path is kept; if equal, a new entry with the full
    folder string is added.
    
    Example:
      folders = ["/a","/a/b","/c/d","/c/d/e","/c/f"]
    """
    d = {}
    i = 0
    while i < len(folders):
        key = folders[i][:2]
        if key in d:
            # Keep the one with the shorter length
            if len(folders[i]) < len(d[key]):
                d[key] = folders[i]
            elif len(folders[i]) == len(d[key]):
                # In the snippet, a new key is added with folder itself.
                d[folders[i]] = folders[i]
        else:
            d[key] = folders[i]
        i += 1
    return d


# --- Next Function Block ---


# -----------------------------------------------------
# Function 3: Print binary representations of numbers.
def print_binary(nums: list) -> None:
    """
    Given a list of numbers, prints each number along with its binary representation.
    """
    i = 0
    while i < len(nums):
        print(bin(nums[i]), nums[i])
        i += 1


# --- Next Function Block ---


# -----------------------------------------------------
# Function 4: Calculate an expression using logarithms.
def calculate_expression(a: int, b: int) -> int:
    """
    If a is 0 and b is not, returns b.
    If b is 0 and a is not, returns a.
    Otherwise, computes int(math.log(math.exp(a) * math.exp(b))) which is equivalent to a+b.
    
    Example:
      a = 707, b = 2 → returns 709.
    """
    if a == 0 and b != 0:
        return b
    elif b == 0 and a != 0:
        return a
    else:
        return int(math.log(math.exp(a) * math.exp(b)))


# --- Next Function Block ---


# -----------------------------------------------------
# Function 5: Filter even numbers from a list.
def filter_evens(arr: list) -> list:
    """
    Returns a list of even numbers from the given list 'arr'.
    
    Example:
      arr = [1,2,3,4,5,6] → returns [2,4,6].
    """
    return list(filter(lambda x: x % 2 == 0, arr))


# --- Next Function Block ---


# -----------------------------------------------------
# Function 6: Find the maximum average subarray of length k.
def max_average_subarray(nums: list, k: int) -> float:
    """
    Finds the contiguous subarray of length k that has the maximum average.
    Prints the subarray each time a new maximum average is found.
    Returns the maximum average.
    
    Example:
      nums = [-1], k = 1.
    """
    max_avg = float('-inf')
    best_sub = None
    i = 0
    while i < len(nums) - k + 1:
        current_avg = sum(nums[i:i+k]) / k
        if current_avg > max_avg:
            max_avg = current_avg
            best_sub = nums[i:i+k]
            print("New best subarray:", best_sub)
        i += 1
    return max_avg


# --- Next Function Block ---


# -----------------------------------------------------
# Function 7: Binary search on a sorted list.
def binary_search(nums: list, target: int) -> int:
    """
    Performs a binary search on a sorted list 'nums' to find 'target'.
    Returns the index if found; otherwise, returns -1.
    
    Example:
      nums = [1,2,3,1], target = 2 → returns index 1.
    """
    start = 0
    end = len(nums) - 1
    while start <= end:
        mid = (start + end) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            start = mid + 1
        else:
            end = mid - 1
    return -1


# --- Next Function Block ---


# -----------------------------------------------------
# Function 8: Rank array elements.
def rank_array(arr: list) -> (list, dict):
    """
    Ranks the elements of 'arr' by sorting the unique values and mapping them to ranks starting at 1.
    Replaces each element in arr with its rank.
    
    Example:
      arr = [40,10,20,30] → returns ([4,1,2,3], {10: 1, 20: 2, 30: 3, 40: 4})
    """
    unique_sorted = sorted(set(arr))
    ranking = {val: idx + 1 for idx, val in enumerate(unique_sorted)}
    ranked_arr = [ranking[val] for val in arr]
    return ranked_arr, ranking


# --- Next Function Block ---


# -----------------------------------------------------
# Function 9: Evaluate a string expression.
def evaluate_expression(expr: str):
    """
    Evaluates a string expression using Python's eval.
    
    Example:
      expr = "-9.1234" → returns -9.1234.
    """
    return eval(expr)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 10: Reverse a subarray given left and right indices (1-indexed).
def reverse_subarray(head: list, left: int, right: int) -> list:
    """
    Reverses the subarray of 'head' from index left-1 to right-1 (inclusive).
    
    Example:
      head = [1,2,3,4,5,6,8], left = 2, right = 4 → returns [1,4,3,2,5,6,8].
    """
    left_idx = left - 1
    right_idx = right
    return head[:left_idx] + head[left_idx:right_idx][::-1] + head[right_idx:]


# --- Next Function Block ---


# -----------------------------------------------------
# Function 11: Merge two lists by inserting a segment.
def merge_lists(list1: list, list2: list, a: int, b: int) -> list:
    """
    Merges two lists by taking:
      - The first a elements from list1,
      - Then all elements from list2,
      - Then all elements from list1 after index b.
    
    Example:
      list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]
      Returns: list1[:3] + list2 + list1[b+1:].
    """
    return list1[:a] + list2 + list1[b+1:]


# --- Next Function Block ---





def a(n):
    for i in range(0,n+1):
        a = i
        for k in range(n-i):
            print(end=" ")
        b=False
        for j in range(1, 2*i-2):
            print(a, end="")
            if a<3:
                b=True
            if b:
                a+=1
            else:
                a-=1
        print("\r")


# --- Next Function Block ---


def b(n):
    for i in range(n+1):
        for j in range(n-i):
            print(end=" ")
        for k in range(2*i-1):
            if k==0 or k==2*i-2:
                print("*", end="")
            else:
                if i==n:
                    print("*", end="")
                else:
                    print(end=" ")
        print("\n")


# --- Next Function Block ---


def c(num):
    flag=False
    if num == 1:
        print("Not prime")
    elif num > 0:
        for i in range(2, num):
            if(num%i==0):
                flag=True
                break
        
    if flag:
        print("Not prime")
    else:
        print("Prime")


# --- Next Function Block ---


def d(n):

    for i in range(1,n+1):
        for k in range(n-i):
            print(end=" ")
        for j in range(1, i):
            print(j,end=" ")
        print(1)


# --- Next Function Block ---


def e(n):
    a=0
    for i in range(n):
        for j in range(i):
            a=a+1
            print(a,end=" ")
        print("\n")


# --- Next Function Block ---


def f(n):
    for i in range(1,n+1):
        for j in range(1,i+1):
            print(j,end=" ")
        print("\n")


# --- Next Function Block ---


def g(n):

    for i in range(n+1):
        for j in range(i*2):
            print("*",end=" ")
        for k in range(1):
            print("*",end=" ")
        print("\n")


# --- Next Function Block ---


def h(n):
    run=True
    for i in range(1, n+1):
        for j in range(1, n+1):
            if j>n-i:
                print("",j,end="")
            else:
                print(end=" ")
        print("\n")


# --- Next Function Block ---


def i(n):
    for i in range(1, n+1):
        for j in range(0, n+1):
            if j<i:
                print(end="  ")
            else:
                print(" *", end="")
        print("\n")


# --- Next Function Block ---


def j(n):
    for i in range(1, n+1):
        for j in range(n+1):
            if j>=i:
                print("*",end="")
            else:
                print(end=" ")
        print("\r")


# --- Next Function Block ---


def i(n):
    for i in range(1, n+1):
        for j in range(1,n+1):
            if j<=(n+1)-i:
                print("*",end="")
            else:
                print(end=" ")
        print("\n")


# --- Next Function Block ---



def display(limit):
    print("Crossroads")
    if limit > 1:
        display(limit - 1)


# --- Next Function Block ---

    

def j(n):
    for i in range(1, n+1):
        for j in range(1, i+1):
            if i==5 or j==1 or j==5:
                print("*", end=" ")
            else:
                print(end=" ")
        print(end="\n")


# --- Next Function Block ---


def k(n):
    for i in range(1, n+1):
        for j in range(1, n*2+1):
            if(j<=i or j>n*2-i):
                print("*",end=" ")
            else:
                print(end="  ")
        print("\n")


# --- Next Function Block ---


def l(n):
    for i in range(1, n*2+1):
        for j in range(1, i+1):
            if(j<=i and i<=n):
                print("*",end=" ")
            elif(j<=n*2-i):
                print("*", end=" ")
        
        print("\n")


# --- Next Function Block ---


def m(n):
    for i in range(1, n+1):
        for j in range(1, n+1):
            if j<=n-i:
                print(end=" ")
            elif i%2!=0:          
                print(i,end=" ")
        print("")


# --- Next Function Block ---


def n(n):
    for i in range(1, n+1):
        for k in range(1, n+2-i):
            print(end="  ")
        for j in range(1, 2*i):
            print(j,end=" ")
        
        print("\n")


# --- Next Function Block ---


def o(n):
    for i in range(1, n*2+1):
        for j in range(1, n+1):
            if j<=n+1-i and i<=n:
                print("*",end=" ")
            elif j<=i-n and i>n:
                print("*",end=" ")
        print("\r")


# --- Next Function Block ---


def p(n):
    for i in range(1, n+1):
        for j in range(1, n+1):
            if j<=i or j>n-i:
                print("*", end=" ")
            else:
                print(end="  ")
        print("\n")


# --- Next Function Block ---


def q(n):
    count = 1
    for i in range(0, n+1):
        for j in range(1, i+1):
            print(j, end=" ")
        print("1\n")


# --- Next Function Block ---


def r(n):
    for i in range(1, n+1):
        for j in range(1, i*2):
            print("*",end=" ")
        print("\n*\n*\n")


# --- Next Function Block ---


def s(n):
    for i in range(1, n+5):
        for j in range(1, 2*i):
            print("*",end=" ")
        print("\n")


# --- Next Function Block ---


def t(n):
    for i in range(1,n):
        for j in range(2,n):
            if j<=i or j>n-i:
                print("*", end=" ")
            else:
                print(end="  ")
        if i>=5:
            break
        print("\n")


# --- Next Function Block ---


def u(size):
    i=0
    j=0
    while i<=size:
        i=i+1
        while j<=size:
            j=j+1
            if j<=i or j>size-i:
                print("*", end=" ")
            else:
                print(end=" ")
            
        print("\n")


# --- Next Function Block ---


def v():
    print("Enter numbers")
    array = []

    for i in range(0,5):
        array.append(int(input()))
    count =0
    for i in range(4):
        for j in range(i,5):
            if(array[i]==array[j]):
                count = count+1
                print(i,j)
    print(count,"*")


# --- Next Function Block ---



class Solution:
    def isValid(self, s: str) -> bool:
        array=[]
        count=0
        if(len(s)%2==0):
            flag=True
            for i in s:
                array.append(i)
            i=0
            while i<len(array):
                if(i%2==0 and array[i]=="(" and array[i+1]==")" or array[i]=="[" and array[i+1]=="]" or array[i]=="{" and array[i+1]=="}" or i<=len(array)/2 and array[i]=="(" and array[(len(array)-1)-i]==")" or array[i]=="[" and array[(len(array)-1)-i]=="]" or array[i]=="{" and array[(len(array)-1)-i]=="}"):
                    if(ord(array[i+1])-ord(array[i])<5 and ord(array[i+1])-ord(array[i])>0):
                        i=i+1
                else:
                    print(i)
                    flag=False
                i=i+1
        else:
            flag=False
        if(flag):
            print(True)
        else:
            print(False)
    s="([])"
    isValid(0, s)

def w(nums1, nums2):
    m=0
    n=1
    k=0
    for i in range(m,m+n):
        nums1[i] = nums2[k]
        k=k+1
    for s in range((m+n)-1):
        for j in range(s+1, m+n):
            if(nums1[s]>nums1[j]):
                temp=nums1[s]
                nums1[s]=nums1[j]
                nums1[j]=temp


# --- Next Function Block ---


def y(x):
    a=str(x)
    array=[]
    isPalindrome=True
    for i in a:
        array.append(i)

    for i in range(len(array)):
        if(int(array[i])!=int(array[len(array)-1-i])):
            isPalindrome=False
    if(isPalindrome):
        print(True)
    else:
        print(False)

    def isPalindrome(x):
        return x == x[::-1]

    res=isPalindrome("122")
    print(res)


# --- Next Function Block ---


def y(nums):
    array=[]
    pos=[]
    for i in range(len(nums)-2):
        for j in range(i+1,len(nums)-1):
            for k in range(j+1,len(nums)):
                if((nums[i]+nums[j]+nums[k])==0 and i!=j and i!=k and j!=k):
                    if([nums[i],nums[j],nums[k]] or [nums[i],nums[k],nums[j]] or [nums[j],nums[i],nums[k]] or [nums[j],nums[k],nums[i]] or [nums[k],nums[i],nums[j]] or [nums[k],nums[j],nums[i]] in array):
                        pos.append([i,j,k])
                    else:
                        array.append([nums[i],nums[j],nums[k]])
    print(array,"\n")
    print(pos)


# --- Next Function Block ---


def z(x):

    val = set(x)
    st = list(val)
    print(st)

    s="fly me   to   the moon  "
    a=s[::-1]
    count=0
    alph=False
    for i in a:
        if i!=" ":
            alph=True
        if alph and i==" ":
            break
        if alph and i!=" ":
            count=count+1
    print(count)


# --- Next Function Block ---


def aa(n):
    i=n-1
    k=2
    pro=n
    val=n-k
    j=val-1
    den=val
    while i>0:
        pro=pro*i
        i=i-1
    while j>0:
        den=den*j
    if den==0:
        den=1
    print(pro/den)


# --- Next Function Block ---


def ab(s):
    resp=""
    spc=[",",".",";",":","-","_"]
    for i in s:
        if i!=" " and i not in spc:
            resp=resp+i
    resp=resp.lower()
    if resp==resp[::-1]:
        print( True)
    else:
        print( False,resp)


# --- Next Function Block ---


def ac(nums):
    array=[]
    for i in range(len(nums)):
        count=1
        for j in range(len(nums)):
            if(nums[i]==nums[j] and i!=j):
                count=count+1
        array.append(count)
    lar=array[0]
    pos=0
    for i in range(0,len(array)):
        if lar<array[i]:
            lar=array[i]
            pos=i
    print( lar)


# --- Next Function Block ---


def ad(array):
    val=2
    i=0
    while i<len(array)-k:
        if array[i]==val:
            array.pop(i)
            i=i-1
        i=i+1
    print(len(array), array)


# --- Next Function Block ---


def ae(array):
    count=0
    for i in range(len(array)):
        for j in range(len(array)):

            if(array[i]>array[j]):
                if(array[i]%2==0):
                    array[i]=int(array[i]/2)
                    array.insert(i+1, int(array[i]))
                else:
                    array[i]=int((array[i]+1)/2)-1
                    array.insert(i+1, int(array[i]+1))
    print(array)


# --- Next Function Block ---



def af(s):       
    array=[]
    stg=[]
    lar=0
    def ins(length, pos, val):
        for i in range(0,length):
            stg.insert(pos, val)
            pos=pos+1

    for i in range(len(s)):
        count=1
        for j in range(len(s)):
            if(s[i]==s[j] and i!=j):
                count=count+1
        array.append(count)

    for k in range(len(array)):
        if(array[k]%2==0):
            if(len(stg)==0):
                for i in range(array[k]):
                    stg.append(s[k])
            else:
                if(s[k] not in stg):
                    pos=int(len(stg)/2)
                    ins(array[k], pos, s[k])
        else:
            if(array[k]>lar):
                lar=array[k]
                val=k
    print(s[val])
    if(lar>0):
        if(lar==1):
            hlf=int(len(stg)/2)
            stg.insert(hlf, s[val])
        elif(len(stg)==0):
            for i in range(lar):
                stg.append(s[val])
        else:
            hlf=int(len(stg)/2)
            ins(lar, hlf, s[val])
    print(array)


# --- Next Function Block ---


def ag(s):
    dict={}
    array=[]
    lar=0
    def ins(length, pos, val):
        for i in range(0,length):
            array.insert(pos, val)
            pos=pos+1
    for i in range(len(s)):
        count=1
        for j in range(len(s)):
            if(s[i]==s[j] and i!=j):
                count=count+1
        dict={**dict, s[i]:count}
    for i in dict.keys():
        if(dict[i]%2==0):
            if(len(array)==0):
                for j in range(dict[i]):
                    array.append(i)
            else:
                pos=int(len(array)/2)
                ins(dict[i], pos, i)
        else:
            if(dict[i]>lar):
                lar=dict[i]
                val=i

    if(lar>0):
        if(lar==1):
            hlf=int(len(array)/2)
            array.insert(hlf, val)
        elif(len(array)==0):
            for i in range(lar):
                array.append(val)
        else:
            hlf=int(len(array)/2)
            ins(lar, hlf, val)

    print(dict)

    s_len = len(s)
    if s == s[::-1]:
        print(s_len)

    chars = {}
    palindrome_length = 0

    for n in s:
        if chars.get(n):
            chars[n] += 1
            if chars[n] % 2 == 0:
                palindrome_length += 2
        else:
            chars[n] = 1

    print(palindrome_length + 1 if s_len - palindrome_length != 0 else palindrome_length)


# --- Next Function Block ---


def ah(nums):
    size=0
    while size<len(nums):
        pos=size
        if(nums[size]==0):
            break
        size=(size+nums[size])
    if(size-pos+1==len(nums)):
        print (True)
    else:
        print (False)


# --- Next Function Block ---


def ai(s,t):
    same=True
    array=""
    lar=-1
    for i in range(0,len(s)):
        for j in range(0,len(t)):
            if(s[i] == t[j] and j>lar):
                array=array+s[i]
                if(j>lar):
                    lar=j
    if array == s:
        print(True)
    else:
        print(array)


# --- Next Function Block ---


def aj(x):
    res=0
    dict={'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}

    for i in s:
        res=res+dict[i]
    if(s[len(s)-2]=='I' and dict[s[len(s)-1]]>1):
        res=res-2

    print(res)


# --- Next Function Block ---


def ak(array):
    count=0
    size=len(array)-1
    for i in range(size):
        if(count>0 and array[i-1] == array[i]):
            array[i]=array[i+1]
            size=size-1
        print(array[i])
        count=count+1


# --- Next Function Block ---


# anagrams.py
def are_anagrams(s: str, t: str) -> bool:
    """
    Returns True if strings s and t have the same character frequencies.
    """
    if len(s) != len(t):
        return False

    sdict = {}
    tdict = {}

    for i in range(len(s)):
        scount = 1
        tcount = 1
        for j in range(len(s)):
            if i != j:
                if s[i] == s[j]:
                    scount += 1
                if t[i] == t[j]:
                    tcount += 1
        sdict[s[i]] = scount
        tdict[t[i]] = tcount

    return sdict == tdict


# --- Next Function Block ---


# dominoes.py
def count_domino_pairs(dominoes: list) -> int:
    """
    Counts the number of equivalent domino pairs.
    Dominoes are considered equivalent if their sorted values are equal.
    """
    domino_count = {}
    count = 0
    for domino in dominoes:
        # Sort to get a consistent representation
        sorted_domino = tuple(sorted(domino))
        if sorted_domino in domino_count:
            count += domino_count[sorted_domino]
            domino_count[sorted_domino] += 1
        else:
            domino_count[sorted_domino] = 1
    return count


# --- Next Function Block ---


# compare_sorted_numbers.py
def compare_sorted_lists(nums: list):
    """
    Returns a tuple (sorted_set, sorted_nums) if the set and list differ,
    otherwise returns False.
    """
    sorted_set = sorted(set(nums))
    nums_sorted = sorted(nums)
    if sorted_set == nums_sorted:
        return False
    else:
        return sorted_set, nums_sorted


# --- Next Function Block ---


# pascals_triangle.py
def generate_pascals_triangle(n: int) -> list:
    """
    Generates Pascal's triangle with n rows.
    """
    triangle = []
    for i in range(n):
        row = [1]
        if i > 0:
            last_row = triangle[-1]
            for j in range(1, i):
                row.append(last_row[j-1] + last_row[j])
            row.append(1)
        triangle.append(row)
    return triangle


# --- Next Function Block ---


# day_of_year.py
def day_of_year(date_str: str) -> int:
    """
    Given a date string in 'YYYY-MM-DD' format, returns its day-of-year.
    """
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    year, month, day = map(int, date_str.split("-"))
    day_count = sum(days_in_month[:month-1]) + day
    # Check for leap year: divisible by 4 and (not divisible by 100 or divisible by 400)
    if (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)) and month > 2:
        day_count += 1
    return day_count


# --- Next Function Block ---


# majority_element.py
def majority_element(nums: list):
    """
    Returns the element that occurs most frequently in nums.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    max_count = 0
    majority = None
    for num, count in freq.items():
        if count > max_count:
            max_count = count
            majority = num
    return majority


# --- Next Function Block ---


# tribonacci.py
def tribonacci(n: int) -> int:
    """
    Returns the (n+1)th Tribonacci number.
    Starting with trib[0]=0, trib[1]=0, trib[2]=1.
    """
    trib = [0, 0, 1]
    for i in range(2, n + 1):
        trib.append(trib[i-2] + trib[i-1] + trib[i])
    return trib[n+1]


# --- Next Function Block ---


# factorial_division.py
def compute_factorial_divided(n: int) -> int:
    """
    Computes (2*n)! divided by 2^n.
    """
    num = n * 2
    factorial = 1
    for i in range(num, 0, -1):
        factorial *= i
    return factorial // (2 ** n)


# --- Next Function Block ---


# min_frequency_element.py
def min_frequency_element(nums: list):
    """
    Returns the element with the minimum frequency in nums.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    min_count = float('inf')
    element = None
    for num, count in freq.items():
        if count < min_count:
            min_count = count
            element = num
    return element


# --- Next Function Block ---


# search_insert.py
def search_insert(nums: list, target: int):
    """
    Returns a tuple (position, new_list) where position is the index of target in the sorted list.
    If target is not in nums, it is inserted into the correct sorted position.
    """
    if target in nums:
        return nums.index(target), nums
    for i, num in enumerate(nums):
        if target < num:
            nums.insert(i, target)
            return i, nums
    nums.append(target)
    return len(nums) - 1, nums


# --- Next Function Block ---


# str_str.py
def find_substring(haystack: str, needle: str) -> int:
    """
    Returns the index of the first occurrence of needle in haystack, or -1 if not found.
    """
    return haystack.find(needle)


# --- Next Function Block ---




# patterns.py

def reverse_vowels(s: str) -> str:
    """
    Reverses only the vowels in the string.
    Example: "hello" -> "holle"
    """
    vowels = ['a','e','i','o','u','A','E','I','O','U']
    s_list = list(s)
    # Collect vowels in order.
    collected = [ch for ch in s_list if ch in vowels]
    # Reverse the collected vowels.
    collected = collected[::-1]
    idx = 0
    # Replace vowels in s_list with reversed ones.
    for i in range(len(s_list)):
        if s_list[i] in vowels:
            s_list[i] = collected[idx]
            idx += 1
    return "".join(s_list)


# --- Next Function Block ---



def sort_vowels_in_string(s: str) -> str:
    """
    Extracts vowels from s, sorts them (by ascii), then replaces vowels in order.
    Example: "lEetcOde" -> vowels sorted: ['E','O','e','o'] and then reinserted.
    """
    vowels = ['a','e','i','o','u','A','E','I','O','U']
    s_list = list(s)
    # Collect ascii codes of vowels.
    vowel_codes = [ord(ch) for ch in s_list if ch in vowels]
    vowel_codes.sort()
    sorted_vowels = "".join(chr(code) for code in vowel_codes)
    idx = 0
    res = ""
    for ch in s_list:
        if ch in vowels:
            res += sorted_vowels[idx]
            idx += 1
        else:
            res += ch
    return res


# --- Next Function Block ---



def unique_chars(s: str) -> str:
    """
    Returns a string made of unique characters in s (order arbitrary).
    Example: "pwwkew" -> a string with unique letters.
    """
    return "".join(set(s))


# --- Next Function Block ---



def reduce_value(n: float) -> float:
    """
    Divides n by 2 repeatedly until n <= 2.
    """
    while n > 2:
        n /= 2
    return n


# --- Next Function Block ---



def move_zeros_nested(nums: list) -> list:
    """
    Moves zeros in a list to the end using nested loops.
    Example: [0,0,1,0,3,12] becomes a list with non-zeros first.
    """
    nums = nums[:]  # copy to avoid mutation
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            if nums[i] == 0 and nums[j] != 0:
                nums[i], nums[j] = nums[j], 0
    return nums


# --- Next Function Block ---



def move_zeros_remove(nums: list) -> list:
    """
    Moves zeros to the end by removing and appending.
    Example: [0,1,0,3,12] becomes [1,3,12,0,0].
    """
    nums = nums[:]  # copy
    for i in nums[:]:
        if i == 0:
            nums.remove(i)
            nums.append(0)
    return nums


# --- Next Function Block ---



def combine_adjacent_equal(nums: list) -> list:
    """
    Combines two equal adjacent numbers by doubling the first and zeroing the second.
    Then moves zeros to the end.
    Example: [1,2,2,1,1,0] --> after combination and shifting zeros.
    """
    nums = nums[:]  # copy
    for i in range(len(nums)-1):
        if nums[i] == nums[i+1]:
            nums[i] *= 2
            nums[i+1] = 0
    # Remove zeros and append them at the end.
    result = [num for num in nums if num != 0]
    result.extend([0] * (len(nums) - len(result)))
    return result


# --- Next Function Block ---



def int_to_roman(num: int) -> str:
    """
    Converts an integer to a Roman numeral string.
    """
    mapping = {1000:'M', 500:'D', 100:'C', 50:'L', 10:'X', 5:'V', 1:'I'}
    out = ""
    n = num
    while n > 0:
        if n >= 1000:
            n -= 1000
            out += mapping[1000]
        elif n >= 900:
            n -= 900
            out += mapping[100] + mapping[1000]
        elif n >= 500:
            n -= 500
            out += mapping[500]
        elif n >= 400:
            n -= 400
            out += mapping[100] + mapping[500]
        elif n >= 100:
            n -= 100
            out += mapping[100]
        elif n >= 90:
            n -= 90
            out += mapping[10] + mapping[100]
        elif n >= 50:
            n -= 50
            out += mapping[50]
        elif n >= 40:
            n -= 40
            out += mapping[10] + mapping[50]
        elif n >= 10:
            n -= 10
            out += mapping[10]
        elif n >= 9:
            n -= 9
            out += mapping[1] + mapping[10]
        elif n >= 5:
            n -= 5
            out += mapping[5]
        elif n >= 4:
            n -= 4
            out += mapping[1] + mapping[5]
        else:
            n -= 1
            out += mapping[1]
    return out


# --- Next Function Block ---



def multiply_str_numbers(num1: str, num2: str) -> int:
    """
    Converts two string numbers to integers and returns their product.
    """
    return int(num1) * int(num2)


# --- Next Function Block ---



def min_diff_pair(arr: list) -> list:
    """
    Given a sorted array, finds and returns the pair of numbers with the minimum difference.
    """
    arr = sorted(arr)
    diffs = []
    pairs = []
    for i in range(len(arr)-1):
        diff = arr[i+1] - arr[i]
        diffs.append(diff)
        pairs.append([arr[i], arr[i+1]])
    min_diff = min(diffs) if diffs else None
    for pair in pairs:
        if pair[1] - pair[0] == min_diff:
            return pair
    return []


# --- Next Function Block ---



def insert_zeros_after_even(nums: list) -> list:
    """
    Inserts two zeros immediately after every even number in the list.
    """
    i = 0
    nums = nums[:]  # copy
    while i < len(nums):
        if nums[i] % 2 == 0:
            nums.insert(i+1, 0)
            nums.insert(i+2, 0)
            i += 3
        else:
            i += 1
    return nums


# --- Next Function Block ---



def remove_two_after_condition(arr: list) -> list:
    """
    If an element in arr is divisible by 5 and there's a next element, remove the next two elements.
    (Note: This logic is based on the given code and may remove fewer than two if not available.)
    """
    arr = arr[:]  # copy
    i = 0
    while i < len(arr) - 1:
        if arr[i] % 5 == 0:
            # Remove next two elements if possible.
            if i+1 < len(arr):
                arr.pop(i+1)
            if i+1 < len(arr):
                arr.pop(i+1)
        i += 1
    return arr


# --- Next Function Block ---



def check_coordinate_difference(coordinates: list) -> bool:
    """
    Given a list of [x,y] coordinates, attempts to check if the differences between consecutive coordinates are consistent.
    (The original logic is ambiguous; this function mimics the provided approach.)
    """
    if not coordinates:
        return True
    diff = coordinates[0][0] - coordinates[0][1]
    diffx = []
    diffy = []
    h = 0
    out = True
    for i in range(len(coordinates)):
        k = coordinates[i]
        if i < len(coordinates) - 1:
            l = coordinates[i+1]
        for j in range(len(k) - 1):
            if diff:
                if k[0] - k[1] == diff:
                    if i < len(coordinates) - 1:
                        diffx.append(l[0] - k[0])
                        diffy.append(l[1] - k[1])
                        if h > 0 and diffx[h-1] == diffx[h] and diffy[h-1] == diffy[h]:
                            h += 1
                        elif diff != 0 and diffx[h] % diff == 0 and diffy[h] % diff == 0:
                            h += 1
                        else:
                            out = False
                            break
                else:
                    out = False
                    break
            else:
                diff = k[0] - k[1]
    return out


# --- Next Function Block ---



def max_profit_difference(arr: list) -> int:
    """
    Given a list of prices (or similar), finds the pair with the minimum difference and returns the difference between sell and buy.
    If the difference is negative, returns 0.
    (Logic based on the provided snippet.)
    """
    diff_map = {}
    for i in range(len(arr)-1):
        minval = arr[0]  # initial min value difference (this logic is ambiguous)
        for j in range(i+1, len(arr)):
            if arr[i] - arr[j] < minval:
                minval = arr[i] - arr[j]
                buyval = arr[i]
                sellval = arr[j]
        diff_map[minval] = [buyval, sellval]
    key = min(diff_map) if diff_map else 0
    val = diff_map.get(key, [0, 0])
    res = val[1] - val[0]
    if res <= 0:
        res = 0
    return res


# --- Next Function Block ---



def find_min_in_list(arr: list) -> int:
    """
    Returns the minimum value in the list.
    """
    if not arr:
        return None
    min_val = arr[0]
    for i in arr:
        if i < min_val:
            min_val = i
    return min_val


# --- Next Function Block ---



def print_star_pattern():
    """
    Prints a pattern:
    For each i from 1 to 3:
      - Print a line with '*' (with newline)
      - Then print i blocks of a square pattern where each block is a row of i stars repeated 'size' times.
      'size' doubles for each i.
    """
    size = 2
    for i in range(1, 4):
        # Print i lines with "*"
        for j in range(i):
            print("*")
        # Print square blocks
        for k in range(i):
            for l in range(size):
                print("*", end=" ")
            print()  # new line after each block row
        size *= 2


# --- Next Function Block ---




# patterns.py

def symmetric_differences(arr: list) -> list:
    """
    Given an array, computes absolute differences between elements
    from the start and end moving inward.
    Example:
      Input: [7,3,5,2,10,6,8,1,4,9]
      Output: list of differences for first half of array with corresponding symmetric elements.
    """
    size = len(arr)
    diff = []
    i, n = 0, size - 1
    for _ in range(size // 2):
        # If indices cross, break (though loop is already half-length)
        if i == n:
            break
        diff.append(abs(arr[i] - arr[n]))
        i += 1
        n -= 1
    return diff


# --- Next Function Block ---



def product_minus_sum(n: int) -> int:
    """
    Converts an integer to string, computes the product of its digits,
    the sum of its digits, and returns (product - sum).
    Example: n=234 -> (2*3*4) - (2+3+4) = 24 - 9 = 15
    """
    s = str(n)
    prod = 1
    total = 0
    for ch in s:
        digit = int(ch)
        total += digit
        prod *= digit
    return prod - total


# --- Next Function Block ---



def sum_of_multiples(n: int) -> int:
    """
    Sums all numbers in the range [1, n) that are divisible by 3, 5, or 7.
    Example: n=7 sums numbers in 1...6 meeting the condition.
    """
    total = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0 or i % 7 == 0:
            total += i
    return total


# --- Next Function Block ---



def nine_minus_one(n: int) -> int:
    """
    For a given integer n, creates a number with the same number of digits all '9's
    and a number with the same number of digits all '1's, then returns their difference.
    Example: n=555 -> "999" - "111" = 888.
    """
    s = str(n)
    large = int("9" * len(s))
    small = int("1" * len(s))
    return large - small


# --- Next Function Block ---



def product_of_list(nums: list, verbose: bool = False) -> int:
    """
    Multiplies the numbers in the list (iterating in reverse order).
    Optionally prints each number.
    """
    product = 1
    for num in nums[::-1]:
        if verbose:
            print(num)
        product *= num
    return product


# --- Next Function Block ---



def longest_common_prefix(strs: list) -> str:
    """
    Returns the longest common prefix among the list of strings.
    If there is none, returns an empty string.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        # Shorten the prefix until s starts with it
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def max_right(arr: list) -> list:
    """
    Given an array, returns a new list where each element at index i is
    replaced by the maximum element to its right; the last element is -1.
    Example: [7,3,5,2,10] -> [10,10,10,10,-1]
    """
    size = len(arr)
    if size == 0:
        return []
    result = [None] * size
    result[-1] = -1
    max_so_far = arr[-1]
    for i in range(size - 2, -1, -1):
        if arr[i] > max_so_far:
            max_so_far = arr[i]
        result[i] = max_so_far
    return result


# --- Next Function Block ---



def generate_random_array(n: int) -> tuple:
    """
    Generates an array of n-1 distinct random integers between -n and n (excluding 0),
    then appends -sum(array) if not already present, or adjusts if it is.
    Returns a tuple: (array, count, -count), where count is the sum of the initial array.
    """
    import random
    array = []
    count = 0
    while len(array) < n - 1:
        val = random.randint(-n, n)
        if val not in array and val != 0:
            array.append(val)
            count += val
    if -count not in array:
        array.append(-count)
    else:
        idx = array.index(-count)
        array[idx] = 0
        array.append(-count + (-count))
    return array, count, -count


# --- Next Function Block ---



def modify_number(num: int) -> int:
    """
    Given a number, replaces the first digit that is less than 9 with 9.
    Then, in a while loop, if a digit (starting from the right) equals 6,
    adds 3 times its positional value to the original number and stops.
    Returns the modified number.
    """
    s = str(num)
    ret = ""
    ins = True
    for ch in s:
        digit = int(ch)
        if digit < 9 and ins:
            ret += "9"
            ins = False
        else:
            ret += ch
    modified = int(ret)
    
    # Process digits from right side
    temp = num
    count = 0
    while temp > 1:
        if temp % 10 == 6:
            modified += 3 * (10 ** count)
            break
        count += 1
        temp //= 10
    return modified


# --- Next Function Block ---



def pascal_row(row_index: int) -> list:
    """
    Returns the row_index-th row of Pascal's Triangle.
    Example: row_index=0 returns [1], row_index=1 returns [1,1], etc.
    """
    triangle = []
    for i in range(row_index + 1):
        row = [1]
        if i > 0:
            prev = triangle[-1]
            for j in range(1, i):
                row.append(prev[j-1] + prev[j])
            row.append(1)
        triangle.append(row)
    return triangle[row_index]


# --- Next Function Block ---



def min_max_game(nums: list) -> int:
    """
    Given a list of numbers, repeatedly perform the following:
      - Partition the list into pairs.
      - For each pair, if it's the turn for 'min', choose the minimum; otherwise, choose the maximum.
      - Continue until one number remains.
    Returns the final number.
    """
    turn = True  # True means take min, False means take max.
    while len(nums) > 1:
        new_nums = []
        for i in range(0, len(nums) - 1, 2):
            if turn:
                new_nums.append(min(nums[i], nums[i+1]))
            else:
                new_nums.append(max(nums[i], nums[i+1]))
            turn = not turn
        if len(nums) % 2 == 1:
            new_nums.append(nums[-1])
        nums = new_nums
    return nums[0]


# --- Next Function Block ---



def chunk_string(s: str, k: int) -> list:
    """
    Splits the string s into chunks of length k.
    The final chunk may be shorter if s is not divisible by k.
    """
    return [s[i:i+k] for i in range(0, len(s), k)]


# --- Next Function Block ---



def min_max_game_progression(nums: list) -> list:
    """
    Implements the Min Max Game (LeetCode #2293) and returns all intermediate lists.
    """
    result = [nums]
    flag = True
    while len(result[-1]) > 1:
        current = result[-1]
        new_list = []
        i = 0
        while i < len(current) - 1:
            if flag:
                new_list.append(min(current[i], current[i+1]))
            else:
                new_list.append(max(current[i], current[i+1]))
            flag = not flag
            i += 2
        result.append(new_list)
    return result


# --- Next Function Block ---



def most_frequent(nums: list):
    """
    Returns the most frequent element in the list.
    """
    freq = {}
    max_count = 0
    max_elem = None
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
        if freq[num] > max_count:
            max_count = freq[num]
            max_elem = num
    return max_elem


# --- Next Function Block ---



def compute_ranks(arr: list) -> list:
    """
    Computes the rank for each element in the original array.
    Rank is defined as:
       - Unique elements are sorted.
       - The rank is 1 for the smallest element, 2 for the next, etc.
    Returns a list of ranks corresponding to the original array.
    """
    sorted_unique = sorted(set(arr))
    rank_dict = {num: rank+1 for rank, num in enumerate(sorted_unique)}
    return [rank_dict[num] for num in arr]


# --- Next Function Block ---



def print_symmetric_pairs(s: str) -> None:
    """
    Prints pairs of characters from the string: first with last, second with second-last, etc.
    """
    size = len(s)
    for i in range(size // 2):
        print(s[i], s[size - 1 - i])


# --- Next Function Block ---



def max_area(height: list) -> int:
    """
    Given a list of heights, returns the maximum area formed by two indices,
    defined as min(height[i], height[j]) * (j - i). (O(n^2) brute force approach.)
    """
    max_area_val = 0
    size = len(height)
    for i in range(size - 1):
        for j in range(i + 1, size):
            area = min(height[i], height[j]) * (j - i)
            if area > max_area_val:
                max_area_val = area
    return max_area_val


# --- Next Function Block ---




# patterns.py

# 1. Happy Number Check (using sum of squares of digits)
def is_happy(n: int, max_iter: int = 100) -> bool:
    """
    Determines if a number is "happy". A number is happy if repeatedly replacing
    it with the sum of the squares of its digits eventually leads to 1.
    """
    for _ in range(max_iter):
        s = str(n)
        total = sum(int(ch) ** 2 for ch in s)
        n = total
        if n == 1:
            return True
    return False


# --- Next Function Block ---


# 2. k Least Ones Rows in a Binary Matrix
def k_least_ones_rows(mat: list, k: int) -> list:
    """
    Given a binary matrix, counts the number of 1's in each row and returns
    the indices of the k rows with the fewest 1's.
    """
    row_counts = {i: sum(row) for i, row in enumerate(mat)}
    sorted_rows = sorted(row_counts.items(), key=lambda x: x[1])
    return [i for i, _ in sorted_rows[:k]]


# --- Next Function Block ---


# 3. Check if s is a Subsequence of t
def is_subsequence(s: str, t: str) -> bool:
    """
    Returns True if s is a subsequence of t.
    """
    pos = 0
    for char in s:
        pos = t.find(char, pos)
        if pos == -1:
            return False
        pos += 1
    return True


# --- Next Function Block ---


# 4. Digit Root (Repeated sum of digits until single digit)
def digit_root(n: int) -> int:
    """
    Repeatedly sums the digits of n until a single digit is obtained.
    """
    while n >= 10:
        n = sum(int(d) for d in str(n))
    return n


# --- Next Function Block ---


# 5. Count Numbers Smaller Than Current
def count_smaller_numbers(nums: list) -> list:
    """
    For each number in nums, counts how many numbers in nums are smaller.
    """
    result = []
    for i in range(len(nums)):
        count = sum(1 for j in range(len(nums)) if nums[i] > nums[j])
        result.append(count)
    return result


# --- Next Function Block ---


# 6. Intersection of Two Lists (unique common elements)
def intersection(nums1: list, nums2: list) -> list:
    """
    Returns a list of unique elements common to both nums1 and nums2.
    """
    return list(set(nums1).intersection(set(nums2)))


# --- Next Function Block ---


# 7. Palindrome Check
def is_palindrome(s: str) -> bool:
    """
    Returns True if s is a palindrome.
    """
    return s == s[::-1]


# --- Next Function Block ---


# 8. Interleave Two Strings
def interleave_strings(word1: str, word2: str) -> str:
    """
    Interleaves characters of word1 and word2. If one word is longer,
    appends the remainder at the end.
    """
    result = []
    max_len = max(len(word1), len(word2))
    for i in range(max_len):
        if i < len(word1):
            result.append(word1[i])
        if i < len(word2):
            result.append(word2[i])
    return "".join(result)


# --- Next Function Block ---


# 9. Maximum Sum with Reversed Numbers
def max_sum_with_reversed(nums: list) -> int:
    """
    For each number in nums that has more than one digit, reverse its digits.
    If the reversed number is also in nums, track the maximum sum of the original
    and reversed numbers.
    """
    max_sum = -1
    for num in nums:
        s = str(num)
        if len(s) > 1:
            rev = int(s[::-1])
            if rev in nums:
                max_sum = max(max_sum, num + rev)
    return max_sum


# --- Next Function Block ---


# 10. Alternate Rearrangement of Characters
def alternate_rearrange(s: str) -> str:
    """
    Rearranges characters from s by alternating from a sorted list of unique characters,
    decrementing their frequency until the result's length equals the original.
    (This mimics a complex custom ordering from the provided snippet.)
    """
    freq = {}
    for ch in s:
        freq[ch] = freq.get(ch, 0) + 1
    unique_chars = sorted(set(s))
    result = ""
    i = 0
    reverse = False
    const = False
    while len(result) < len(s) and unique_chars:
        # If the current character is exhausted, remove it.
        if freq[unique_chars[i]] <= 0:
            unique_chars.pop(i)
            if not unique_chars:
                break
            i = len(unique_chars)-1 if reverse else 0
            continue
        result += unique_chars[i]
        freq[unique_chars[i]] -= 1
        # Toggle direction at boundaries.
        if i == 0:
            reverse = False
        elif i == len(unique_chars) - 1:
            reverse = True
        const = True
        if len(unique_chars) <= 1:
            i = 0
        elif reverse:
            i -= 1
        else:
            i += 1
    return result


# --- Next Function Block ---


# 11. Count Pairs with Sum Less Than Target
def count_pairs_with_sum_less_than(nums: list, target: int) -> int:
    """
    Counts the number of unique pairs (i, j) with i < j such that the sum is less than target.
    """
    count = 0
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            if nums[i] + nums[j] < target:
                count += 1
    return count


# --- Next Function Block ---


# 12. Count Pairs with Sum in [lower, upper]
def count_pairs_in_range(nums: list, lower: int, upper: int) -> int:
    """
    Counts the number of unique pairs (i, j) with i < j such that the sum is between lower and upper (inclusive).
    """
    count = 0
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            s = nums[i] + nums[j]
            if lower <= s <= upper:
                count += 1
    return count


# --- Next Function Block ---


# 13. Check First Letters of Words Against a String
def check_first_letters(words: list, s: str) -> bool:
    """
    Checks if the first letter of each word in words matches the corresponding character in s.
    Returns False if lengths differ.
    """
    if len(words) != len(s):
        return False
    for i in range(len(words)):
        if words[i][0] != s[i]:
            return False
    return True


# --- Next Function Block ---


# 14. Count Unique Numbers in Intervals
def count_unique_numbers_in_intervals(intervals: list) -> int:
    """
    Given a list of intervals [start, end], counts the number of unique integers in all intervals.
    """
    unique_nums = set()
    for start, end in intervals:
        unique_nums.update(range(start, end + 1))
    return len(unique_nums)


# --- Next Function Block ---


# 15. Return Length of List
def list_length(lst: list) -> int:
    """
    Returns the length of lst.
    """
    return len(lst)


# --- Next Function Block ---


# 16. Create Target Array in Given Order
def create_target_array(nums: list, index: list) -> list:
    """
    Given two lists, nums and index, inserts each element from nums into a target list at the corresponding index.
    """
    target = []
    for num, idx in zip(nums, index):
        target.insert(idx, num)
    return target


# --- Next Function Block ---


# 17. Common Divisors of Two Numbers
def common_divisors(a: int, b: int) -> list:
    """
    Returns a list of common divisors of a and b.
    """
    c = a if a < b else b
    divisors = []
    for i in range(1, c + 1):
        if a % i == 0 and b % i == 0:
            divisors.append(i)
    return divisors


# --- Next Function Block ---


# 18. ID with Maximum Gap in Logs
def id_of_max_gap(logs: list) -> int:
    """
    Given logs as [id, time] pairs, returns the id corresponding to the maximum gap between times.
    Assumes logs are ordered by time.
    """
    kdiff = 0
    selected_id = 0
    pos = 0
    for log in logs:
        current_id, time = log
        gap = time - pos
        if gap > kdiff:
            kdiff = gap
            selected_id = current_id
        pos = time
    return selected_id


# --- Next Function Block ---


# 19. Print Negative Pairs
def print_negative_pairs(nums: list) -> None:
    """
    For each number in nums, if its negative exists in nums, prints the negative value with a tag.
    """
    nums_sorted = sorted(nums, reverse=True)
    for num in nums_sorted:
        if -num in nums:
            print(-num, "9")


# --- Next Function Block ---


# 20. Power Calculation
def power(x: float, n: int) -> float:
    """
    Returns x raised to the power n.
    """
    return x ** n


# --- Next Function Block ---


# 21. Range Count
def range_count(low: int, high: int) -> int:
    """
    Returns the difference between high and low.
    """
    return high - low


# --- Next Function Block ---


# 22. Average of Salaries
def average_salary(salaries: list) -> float:
    """
    Returns the average of the salaries in the list.
    """
    return sum(salaries) / len(salaries) if salaries else 0


# --- Next Function Block ---


# 23. Rotate Array Right by k
def rotate_right(nums: list, k: int) -> list:
    """
    Rotates the list nums to the right by k positions.
    """
    n = len(nums)
    k = k % n  # Handle cases where k >= n
    return nums[-k:] + nums[:-k]


# --- Next Function Block ---


# 24. Element Equal to Its Frequency
def element_equal_to_frequency(arr: list) -> int:
    """
    Returns the first element whose value equals its frequency in the array.
    If none exists, returns -1.
    """
    freq = {}
    for num in arr:
        freq[num] = freq.get(num, 0) + 1
    for num in arr:
        if num == freq[num]:
            return num
    return -1


# --- Next Function Block ---


# 25. Longest Repeating Character Substring Length
def longest_repeating_substring_length(s: str) -> int:
    """
    Returns the length of the longest substring of s consisting of the same character.
    """
    if not s:
        return 0
    max_len = 1
    current_len = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_len += 1
        else:
            max_len = max(max_len, current_len)
            current_len = 1
    return max(max_len, current_len)


# --- Next Function Block ---


# 26. Get Dictionary Keys
def get_dict_keys(d: dict) -> list:
    """
    Returns a list of keys in dictionary d.
    """
    return list(d.keys())


# --- Next Function Block ---


# 27. Demonstrate Abstract Base Classes
from abc import ABC, abstractmethod
class A(ABC):
    @abstractmethod
    def printf(self):
        pass

class B(A):
    def printf(self):
        print("Hi from B")
    def Scan(self):
        print("Hey")

def test_inheritance():
    """
    Demonstrates inheritance using abstract base classes.
    """
    obj = B()
    obj.printf()
    obj.Scan()


# --- Next Function Block ---


# 28. Custom Fibonacci Variant (starting with [1,2])
def custom_fib(n: int) -> int:
    """
    Returns the nth element in a Fibonacci-like sequence starting with 1 and 2.
    """
    if n == 1:
        return 1
    if n == 2:
        return 2
    seq = [1, 2]
    for i in range(2, n):
        seq.append(seq[-1] + seq[-2])
    return seq[-1]


# --- Next Function Block ---


# 29. Vehicle Class with Destructor
class Vehicle:
    def __init__(self):
        print("Vehicle created.")
    def __del__(self):
        print("Destructor called, vehicle deleted.")
    def display(self):
        print("Hello")

def test_vehicle_class():
    """
    Creates a Vehicle instance, calls display, then deletes it.
    """
    car = Vehicle()
    car.display()
    del car


# --- Next Function Block ---


# 30. Most Frequent Element in a List
def most_frequent_element(nums: list) -> int:
    """
    Returns the element with the highest frequency in nums.
    """
    freq = {}
    max_count = 0
    max_elem = None
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
        if freq[num] > max_count:
            max_count = freq[num]
            max_elem = num
    return max_elem


# --- Next Function Block ---


# 31. Print Duplicates in a List
def print_duplicates(nums: list) -> None:
    """
    Prints elements that appear more than once in the list.
    """
    seen = set()
    duplicates = set()
    for num in nums:
        if num in seen:
            duplicates.add(num)
        else:
            seen.add(num)
    for dup in duplicates:
        print(dup)


# --- Next Function Block ---


# 32. First Duplicate Element (from set comprehension)
def first_duplicate(nums: list):
    """
    Returns the first element that appears more than once in nums.
    If none, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---


# 33. Capitalize First Letter of a String
def capitalize_first_letter(s: str) -> str:
    """
    Capitalizes the first letter of the string s.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---


# 34. Interleave Halves of an Array
def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list nums and an integer n, interleaves the first n elements with the next n elements.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---


# 35. Extract Number from String
def extract_number(s: str) -> int:
    """
    Splits the string s by spaces and returns the last integer found.
    If none found, returns 0.
    """
    num = 0
    for token in s.split():
        try:
            num = int(token)
        except ValueError:
            continue
    return num


# --- Next Function Block ---


# 36. Longest Common Prefix (Brute Force)
def longest_common_prefix_brute(strs: list) -> str:
    """
    Finds the longest common prefix among a list of strings using brute force.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# --- Next Function Block ---


# 37. Remove Duplicates In-place (Sorted Array Variant)
def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---


# 38. Normalize Email Addresses
def normalize_email(email: str) -> str:
    """
    Normalizes an email address by removing dots from the local name and ignoring everything after a '+'.
    """
    local, domain = email.split('@')
    local = local.split('+')[0].replace('.', '')
    return local + '@' + domain


# --- Next Function Block ---


def normalize_emails(emails: list) -> list:
    """
    Normalizes a list of emails.
    """
    return [normalize_email(email) for email in emails]


# --- Next Function Block ---


# 39. Adjust Prices (Subtract first smaller element)
def adjust_prices(prices: list) -> list:
    """
    For each price in the list, if a subsequent price is smaller,
    subtract that price from the current and break.
    """
    adjusted = prices[:]  # make a copy
    for i in range(len(adjusted)-1):
        for j in range(i+1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] = adjusted[i] - adjusted[j]
                break
    return adjusted


# --- Next Function Block ---


# 40. Sum Diagonals of a Matrix
def sum_diagonals(mat: list) -> int:
    """
    Sums the elements on both the main diagonal and the secondary diagonal of a square matrix.
    If the matrix has an odd center, it is counted only once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i]  # primary diagonal
        total += mat[i][n - 1 - i]  # secondary diagonal
    # If n is odd, subtract the center value (counted twice)
    if n % 2 == 1:
        total -= mat[n//2][n//2]
    return total


# --- Next Function Block ---





# patterns.py

def is_diagonal_matrix(grid: list) -> bool:
    """
    Returns True if grid is a square matrix with nonzero entries only on the main diagonal,
    and zeros off the diagonal.
    """
    n = len(grid)
    for i in range(n):
        for j in range(len(grid[i])):
            if i == j:
                if grid[i][j] == 0:
                    return False
            else:
                if grid[i][j] != 0:
                    return False
    return True


# --- Next Function Block ---



def xor_of_sequence(n: int, start: int = 3, step: int = 2) -> int:
    """
    Generates a sequence of n numbers, starting from 'start' and increasing by 'step',
    and returns their bitwise XOR.
    """
    seq = []
    xor_val = 0
    i = start
    while len(seq) < n:
        seq.append(i)
        xor_val ^= i
        i += step
    return xor_val


# --- Next Function Block ---



def count_elements_geq(arr: list, target) -> int:
    """
    Counts the number of elements in arr that are greater than or equal to target.
    """
    count = 0
    for elem in arr:
        if elem >= target:
            count += 1
    return count


# --- Next Function Block ---



def max_account_value(accounts: list) -> int:
    """
    Given a list of accounts (each account is a list of numbers), returns the maximum total (row sum).
    """
    max_val = 0
    for acc in accounts:
        total = sum(acc)
        if total > max_val:
            max_val = total
    return max_val


# --- Next Function Block ---



def count_equal_pairs(nums: list) -> int:
    """
    Counts the number of pairs (i, j) with i < j such that nums[i] == nums[j].
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if nums[i] == nums[j]:
                count += 1
    return count


# --- Next Function Block ---



def duplicate_list(nums: list) -> list:
    """
    Returns a new list by appending a copy of nums to itself.
    """
    return nums + nums


# --- Next Function Block ---



def final_value_after_operations(operations: list) -> int:
    """
    Given a list of operations (strings "++X" or "X++"), returns the final value of x.
    """
    x = 0
    for op in operations:
        if op in ["++X", "X++"]:
            x += 1
        else:
            x -= 1
    return x


# --- Next Function Block ---



def kids_with_greatest_candies(candies: list, extraCandies: int) -> list:
    """
    Returns a list of booleans indicating whether each kid can have the greatest number of candies
    after receiving extraCandies.
    """
    max_candies = max(candies)
    result = []
    for c in candies:
        result.append(c + extraCandies >= max_candies)
    return result


# --- Next Function Block ---



def running_sum(nums: list) -> list:
    """
    Returns a list where each element at index i is the sum of nums[0:i+1].
    """
    total = 0
    result = []
    for num in nums:
        total += num
        result.append(total)
    return result


# --- Next Function Block ---



def sentence_with_most_words(sentences: list) -> list:
    """
    Returns the list of words of the sentence that has the maximum word count.
    """
    max_words = []
    for sentence in sentences:
        words = sentence.split()
        if len(words) > len(max_words):
            max_words = words
    return max_words


# --- Next Function Block ---



def prefix_difference(nums: list) -> list:
    """
    Computes two prefix sum arrays:
      - left prefix sum from the start,
      - right prefix sum from the end,
    then returns a list of absolute differences between the left prefix at index i
    and the corresponding right prefix from the opposite end.
    """
    n = len(nums)
    left = [0] * n
    right = [0] * n
    s_left = 0
    s_right = 0
    for i in range(n):
        left[i] = s_left
        s_left += nums[i]
        right[i] = s_right
        s_right += nums[n - 1 - i]
    diff = []
    for i in range(n):
        diff.append(abs(left[i] - right[n - 1 - i]))
    return diff


# --- Next Function Block ---



def print_custom_pattern(n: int) -> None:
    """
    Prints a custom pattern based on a grid of size (n*n).
    (Note: The pattern logic is derived from the given code and may be adjusted as needed.)
    """
    total = n * n
    for i in range(total):
        for j in range(total):
            # This condition is based on the provided snippet; adjust as needed.
            if (i == 0 and j == total // 2) or \
               (i > 0 and (total / 2) - 2 < j < (total / 2) + 1) or \
               (i > (total / 2) - 2 and 1 < j < 5) or \
               (i > (total / 2) - 2 and 5 < j < 9) or \
               (i > (total / 2) - 2 and total - 6 < j < total - 2) or \
               (i > (total / 2) - 2 and total - 10 < j < total - 6) or \
               (i >= total // 2) or \
               (i == 12 and 0 < j < total - 1):
                print("*", end=" ")
            else:
                print("  ", end=" ")
        print()


# --- Next Function Block ---



def convert_date(date: str) -> str:
    """
    Converts a date from format "20th Oct 2052" to "2052-10-20".
    Assumes day part may contain ordinal suffixes.
    """
    month_map = {
        "Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04",
        "May": "05", "Jun": "06", "Jul": "07", "Aug": "08",
        "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"
    }
    parts = date.split()
    day_part = parts[0]
    # Remove non-digit characters
    day = "".join(filter(str.isdigit, day_part))
    if len(day) == 1:
        day = "0" + day
    month = month_map[parts[1]]
    year = parts[2]
    return f"{year}-{month}-{day}"


# --- Next Function Block ---



def count_odds(low: int, high: int) -> int:
    """
    Counts the number of odd numbers in the inclusive range [low, high].
    """
    count = 0
    for i in range(low, high + 1):
        if i % 2 != 0:
            count += 1
    return count


# --- Next Function Block ---



def rearrange_string(s: str, indices: list) -> str:
    """
    Rearranges characters in s according to indices.
    """
    mapping = {index: char for index, char in zip(indices, s)}
    sorted_mapping = dict(sorted(mapping.items()))
    result = "".join(sorted_mapping[i] for i in sorted_mapping)
    return result


# --- Next Function Block ---



def repeat_alternate(nums: list) -> list:
    """
    For even-indexed elements in nums, repeats the element at index i+1 a number of times equal to nums[i].
    Example: For nums = [1,2,3,4], returns [2] repeated 1 time and [4] repeated 3 times => [2,4,4,4].
    """
    result = []
    for i in range(0, len(nums), 2):
        if i + 1 < len(nums):
            result.extend([nums[i+1]] * nums[i])
    return result


# --- Next Function Block ---



def first_k_words(s: str, k: int) -> str:
    """
    Returns the first k words from the string s.
    """
    words = s.split()
    return " ".join(words[:k])


# --- Next Function Block ---



def compare_word_lists(word1: list, word2: list) -> bool:
    """
    Concatenates the elements of both lists (word by word) and compares the resulting strings.
    Returns True if they are equal.
    """
    stg1 = "".join(word1)
    stg2 = "".join(word2)
    return stg1 == stg2


# --- Next Function Block ---



def sum_minus_digit_sum(nums: list) -> int:
    """
    For a list of numbers, returns the difference between the sum of the numbers and
    the sum of all their digits.
    """
    total = sum(nums)
    digit_sum = 0
    for num in nums:
        for ch in str(num):
            digit_sum += int(ch)
    return total - digit_sum


# --- Next Function Block ---



def count_pairs_with_difference(nums: list, k: int) -> int:
    """
    Counts the number of pairs (i, j) with i < j such that the absolute difference is k.
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if abs(nums[i] - nums[j]) == k:
                count += 1
    return count


# --- Next Function Block ---



def count_special_pairs(nums: list, k: int) -> int:
    """
    Counts the number of pairs (i, j) with i < j such that nums[i] == nums[j]
    and (i * j) % k == 0.
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if nums[i] == nums[j] and (i * j) % k == 0:
                count += 1
    return count


# --- Next Function Block ---



def format_number_with_dots(n: int) -> str:
    """
    Formats a number with dots as thousand separators.
    Example: 1234567 -> "1.234.567"
    """
    s = str(n)
    result = ""
    count = 0
    # Process digits from right to left.
    for ch in s[::-1]:
        if count == 3:
            result = "." + result
            count = 0
        result = ch + result
        count += 1
    return result


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the count of words that consist solely of characters in allowed.
    """
    count = 0
    for word in words:
        valid = True
        for ch in word:
            if ch not in allowed:
                valid = False
                break
        if valid:
            count += 1
    return count


# --- Next Function Block ---



def sum_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Inserts "[.]" between each segment of an IP address.
    Example: "1.1.1.1" -> "1[.]1[.]1[.]1"
    """
    parts = address.split(".")
    return "[.]".join(parts)


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Counts how many characters in stones are also in jewels.
    """
    count = 0
    for ch in stones:
        if ch in jewels:
            count += 1
    return count


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string based on the following rules:
    "G" -> "G"
    "()" -> "o"
    "(al)" -> "al"
    Example: "G()(al)" -> "Goal"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims extra spaces and redistributes spaces evenly between words.
    (A simple approach; may not cover all edge cases.)
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    # Minimum spaces between words:
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            # Distribute extra spaces to the left
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Brute-force approach to the container with most water problem.
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters that appear exactly once in s.
    If all characters are unique, returns -1.
    """
    freq = {}
    for ch in s:
        freq[ch] = freq.get(ch, 0) + 1
    unique_chars = [ch for ch, count in freq.items() if count == 1]
    if len(unique_chars) == len(s):
        return -1
    return len(unique_chars)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For characters that repeat in s, returns the maximum gap (distance - 1)
    between two occurrences. If none repeat, returns -1.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element found in nums.
    If no duplicate exists, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Capitalizes the first letter of the string.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list nums and an integer n, interleaves the first n elements with the next n elements.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Splits the string by spaces and returns the last integer found (if any).
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among the list of strings.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes email addresses by removing dots in the local part (before '+')
    and ignoring any characters after '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price, subtracts the first subsequent smaller price (if found) and stops.
    """
    adjusted = prices[:]  # copy list
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the primary and secondary diagonal of a square matrix.
    For an odd-length matrix, the center element is counted only once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---





def count_elements_based_on_min_freq(nums: list) -> int:
    """
    Sorts the list and builds a frequency dictionary.
    Finds the number (key) with the lowest frequency and then counts how many elements in the sorted list are 
    greater than or equal to that number.
    """
    nums_sorted = sorted(nums)
    freq = {}
    for num in nums_sorted:
        freq[num] = freq.get(num, 0) + 1
    sorted_freq = sorted(freq.items(), key=lambda x: x[1])
    min_elem, _ = sorted_freq[0]
    total = sum(1 for num in nums_sorted if num >= min_elem)
    return total


# --- Next Function Block ---



def print_pattern_1(n: int) -> None:
    """
    Prints a pattern based on a condition:
    For each row i (1-indexed) and each column j (0-indexed) in a grid of width n, prints a star (*) or space.
    The condition is:
      - if (j < i and i <= 3) or (i > 3 and j <= n - i): print a space
      - else: print a star.
    """
    for i in range(1, n + 1):
        for j in range(n):
            if (j < i and i <= 3) or (i > 3 and j <= n - i):
                print(" ", end="  ")
            else:
                print("*", end="  ")
        print()


# --- Next Function Block ---



def print_pattern_2(n: int) -> None:
    """
    Prints a pattern on an n*n grid.
    For each cell (i, j) where 0 <= i, j < n*n, prints a star if j < 13 - i*i or j > 11 + i*i; otherwise prints spaces.
    (The condition is taken from the snippet; adjust as needed.)
    """
    total = n * n
    for i in range(total):
        for j in range(total):
            if j < 13 - i * i or j > 11 + i * i:
                print("*", end=" ")
            else:
                print("  ", end="")
        print()


# --- Next Function Block ---



def reconstruct_from_pieces(arr: list, pieces: list) -> (bool, list):
    """
    Tries to reconstruct the array by selecting unique pieces from 'pieces' that appear in 'arr'.
    Flattens the collected pieces and compares the result with arr.
    Returns a tuple (is_equal, reconstructed_array).
    """
    collected = []
    used = []
    for piece in pieces:
        if piece not in used and any(num in arr for num in piece):
            used.append(piece)
            collected.extend(piece)
    return (collected == arr, collected)


# --- Next Function Block ---



def is_arithmetic_progression(arr: list) -> bool:
    """
    Checks if the sorted array forms an arithmetic progression.
    """
    arr = sorted(arr)
    if len(arr) < 2:
        return True
    diff = arr[1] - arr[0]
    for i in range(1, len(arr) - 1):
        if arr[i + 1] - arr[i] != diff:
            return False
    return True


# --- Next Function Block ---



def check_progressions(*arrays) -> list:
    """
    For each array provided, returns True if it forms an arithmetic progression (when sorted), otherwise False.
    """
    results = []
    for arr in arrays:
        results.append(is_arithmetic_progression(arr))
    return results


# --- Next Function Block ---



def count_word_occurrences(sequence: str, word: str) -> int:
    """
    Returns the number of non-overlapping occurrences of word in sequence.
    """
    return sequence.count(word)


# --- Next Function Block ---



def count_word_occurrences_replace(sequence: str, word: str) -> int:
    """
    Uses string replacement to calculate the number of times word appears in sequence.
    """
    reduced = sequence.replace(word, "")
    return (len(sequence) - len(reduced)) // len(word)


# --- Next Function Block ---



def compute_subtractions(n: int) -> int:
    """
    Repeatedly subtracts floor(i/2) from i until i <= 1, summing all subtractions.
    """
    count = 0
    i = n
    while i > 1:
        sub = i // 2
        i = i - sub
        count += sub
    return count


# --- Next Function Block ---



def convert_zigzag(s: str, numRows: int) -> str:
    """
    Attempts to create a zigzag conversion of s for numRows.
    (Note: This implementation follows the provided snippet's structure and may differ from the standard solution.)
    """
    if numRows == 1 or numRows >= len(s):
        return s
    result = ""
    i = 0
    diff = numRows
    while len(result) < len(s):
        if i >= len(s):
            i -= len(s)
            if i % 2 == 0:
                diff = 2
                i = 1
            else:
                diff = numRows
        result += s[i]
        i += diff
    return result


# --- Next Function Block ---



def equal_vowel_halves(s: str) -> bool:
    """
    Splits string s into two halves and returns True if both halves have the same count of vowels.
    """
    vowels = set('aeiouAEIOU')
    half = len(s) // 2
    first_half = s[:half]
    second_half = s[half:]
    return sum(1 for ch in first_half if ch in vowels) == sum(1 for ch in second_half if ch in vowels)


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Given a list of vote strings, returns the vote with the highest frequency.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each i from 0 to len(s)-1, creates a pattern of 'R' repeated i times followed by 'L' repeated i times.
    Counts the total occurrences of these patterns in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    Given a list of items (each item is a list) and a ruleKey ("type", "color", or other),
    selects the element at the corresponding position (0 for "type", 1 for "color", 2 otherwise)
    and counts how many items have ruleValue at that position.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints the grid row by row.
    """
    for row in grid:
        for elem in row:
            print(elem, end=" ")
        print()


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of numbers that appear only once in the list.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times, adding (count+pos) to the sum.
    Resets count to 0 and increments pos when count reaches 7.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Returns a new list where each element is replaced by the element at the index equal to its value.
    """
    result = []
    for i in range(len(nums)):
        result.append(nums[nums[i]])
    return result


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Computes the difference between the sum of numbers in [1, n] not divisible by m and the sum of numbers divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (for i from 1 to 31) that exists in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers: 2, 4, 6, ... up to limit*2.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor of the minimum and maximum of the list.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts to reorder a list based on a nested loop strategy and checks if the
    resulting list equals the sorted version of the original list.
    (Logic follows the provided snippet; behavior may be non-standard.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 in str1 and returns the result.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx + len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Returns the sum of the minimum value of each row in a triangle (list of lists).
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of 'digit' from 'number' and returns a tuple with the resulting string and 
    a list of indices where the digit was found.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if all elements in nums have unique frequencies.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum count between occurrences of '1' and '0' in s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Determines if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Compares the string s against two alternating patterns ("0101..." and "1010...")
    and returns the minimum number of mismatches.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Iterates over the string s and when consecutive duplicate characters are found,
    flips the second one ("0" becomes "1" and vice versa) and counts the flips.
    Returns the modified string and the count of flips.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i + 1]:
            count += 1
            s_list[i + 1] = "1" if s_list[i + 1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the vote (string) with the highest frequency from the list.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each possible i, builds a pattern with i 'R's followed by i 'L's,
    and counts how many times each such pattern appears in s.
    Returns the total count.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    For each item in items (a list of lists), checks the element at a position determined by ruleKey 
    ("type" → index 0, "color" → index 1, otherwise index 2) and counts items that equal ruleValue.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints each element of a 2D grid.
    """
    for row in grid:
        for val in row:
            print(val, end=" ")
        print()


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of numbers that appear exactly once in the list.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times while updating two counters (count and pos) and returns the sum of (count+pos) over the iterations.
    Resets count to 0 and increments pos when count reaches 7.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Creates a new list where each element is replaced by the element at the index equal to its value.
    """
    return [nums[nums[i]] for i in range(len(nums))]


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Sums numbers from 1 to n that are not divisible by m and subtracts the sum of numbers that are divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (for i in range(1, 32)) that exists in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers from 2 to 2*limit.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor of the minimum and maximum values in the list.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts a reordering of the list based on the provided snippet.
    Returns True if the concatenation of the modified sublists equals the sorted original list.
    (Note: The original logic is unclear.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 in str1 and returns the modified string.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx+len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Sums the minimum element of each row in a triangle.
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of a digit from a number (given as a string).
    Returns the resulting string and a list of indices where removals occurred.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if all numbers in nums have unique frequencies.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum between the count of '1's and '0's in the string s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Returns True if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Computes the number of mismatches between s and two alternating patterns ("0101..." and "1010...").
    Returns the smaller mismatch count.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Flips the second of any two consecutive identical characters ("0" becomes "1", "1" becomes "0").
    Returns the resulting string and the count of flips.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i + 1]:
            count += 1
            s_list[i + 1] = "1" if s_list[i + 1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the vote (string) with the highest frequency.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each possible repetition count i, builds a pattern of i 'R's followed by i 'L's,
    and sums up how many times these patterns appear in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    For a list of items (each item is a list) and a ruleKey ("type", "color", or other),
    selects the element at index 0 for "type", index 1 for "color", and index 2 otherwise,
    then counts how many items have that element equal to ruleValue.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints the elements of a 2D grid.
    """
    for row in grid:
        print(" ".join(str(x) for x in row))


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of the numbers that appear exactly once in the list.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times, updating a counter and position.
    Adds (count + pos) on each iteration; resets count after 7 iterations and increments pos.
    Returns the total sum.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Constructs a new list where each element at index i is replaced by nums[nums[i]].
    """
    return [nums[nums[i]] for i in range(len(nums))]


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Returns the difference between the sum of numbers 1 to n that are not divisible by m and the sum of those divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (for i in 1..31) found in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers from 2 to 2*limit.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor (GCD) of the minimum and maximum of nums.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts a reordering (as in the provided snippet) and returns True if the concatenation
    of modified segments equals the sorted version of the original list.
    (The logic is based on the snippet and may be non-standard.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 in str1 and returns the resulting string.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx + len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Returns the sum of the minimum elements of each row in a triangle (list of lists).
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of the specified digit from the number (as a string).
    Returns a tuple of the new string and a list of indices where the digit was found.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if the frequency of each number in nums is unique.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum count between occurrences of '1' and '0' in the string s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Returns True if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Computes the number of mismatches between s and two alternating patterns ("0101..." and "1010...").
    Returns the smaller mismatch count.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Iterates over the string s and, when two consecutive identical characters are found,
    flips the second character ("0" becomes "1" and vice versa). Returns the modified string and the count of flips.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i + 1]:
            count += 1
            s_list[i + 1] = "1" if s_list[i + 1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the candidate (vote) with the highest number of votes.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each possible repetition count i, builds a pattern of 'R'*i + 'L'*i,
    and returns the total number of occurrences of such patterns in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    Counts how many items in a list of lists have the value ruleValue at a specific index:
      - 0 for ruleKey "type"
      - 1 for ruleKey "color"
      - 2 otherwise.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of numbers in the list that appear exactly once.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times, updating counters 'count' and 'pos'. Adds (count+pos) to the sum,
    resets count to 0 and increments pos after 7 iterations. Returns the final sum.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Creates a new list by mapping each index i to the element at index nums[i].
    """
    return [nums[nums[i]] for i in range(len(nums))]


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Computes the difference between the sum of numbers 1 to n that are not divisible by m
    and the sum of numbers that are divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (i * n for some i in 1..31) that is present in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers from 2 to 2*limit.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor (GCD) of the minimum and maximum values in nums.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts a reordering based on the provided logic and returns True if the concatenation of 
    modified segments equals the sorted original list.
    (The logic is directly derived from the snippet and might be non-standard.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 in str1 and returns the result.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx + len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Returns the sum of the minimum elements from each row of a triangle (list of lists).
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of the given digit from the string 'number'.
    Returns a tuple with the new string and the list of indices where the digit was found.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if each number in nums has a unique frequency.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum count between the number of '1's and '0's in s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Returns True if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Compares s against two alternating patterns ("0101..." and "1010...") and returns the minimum mismatch count.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Flips the second character in any pair of consecutive identical characters ("0" <-> "1")
    and returns the modified string along with the count of flips.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i + 1]:
            count += 1
            s_list[i + 1] = "1" if s_list[i + 1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the candidate with the highest vote count.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each possible i (0 <= i < len(s)), builds a pattern of i 'R's followed by i 'L's and sums
    the occurrences of these patterns in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    Counts how many items (each a list) have ruleValue at a position determined by ruleKey:
      - 0 for "type"
      - 1 for "color"
      - 2 otherwise.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints a 2D grid.
    """
    for row in grid:
        print(" ".join(str(x) for x in row))


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of numbers in nums that appear exactly once.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times, updating two counters (count and pos), adding (count+pos) each time.
    Resets count after 7 iterations and increments pos. Returns the total sum.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Returns a new list where each element is replaced by the element at index equal to its value.
    """
    return [nums[nums[i]] for i in range(len(nums))]


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Computes the difference between the sum of numbers from 1 to n that are not divisible by m 
    and the sum of numbers that are divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (for i in 1..31) that is present in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers from 2 to 2*limit.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor of the minimum and maximum values in nums.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts a reordering based on a nested deletion loop and returns True if the concatenation 
    of the removed elements and the remaining list equals the sorted original list.
    (Logic is directly based on the snippet and may be non-standard.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 from str1 and returns the resulting string.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx+len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Returns the sum of the minimum element from each row of a triangle.
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of a given digit from the number (as a string).
    Returns a tuple containing the new string and a list of indices where the digit was removed.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if all numbers in nums have unique frequencies.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum count between occurrences of '1' and '0' in s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Returns True if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Computes the mismatch count between s and two alternating patterns ("0101..." and "1010...")
    and returns the minimum of the two counts.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Iterates over s and flips the second character of any adjacent duplicate pair
    (switching '0' to '1' and vice versa). Returns the modified string and the flip count.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i+1]:
            count += 1
            s_list[i+1] = "1" if s_list[i+1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the candidate with the highest vote count from the list.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each i (from 0 to len(s)-1), creates a pattern of 'R'*i followed by 'L'*i,
    and sums the number of times such patterns occur in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    For a list of items (each a list), returns the count of items where the element at position 
    (0 for "type", 1 for "color", 2 otherwise) equals ruleValue.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def sum_of_prefix_differences(nums: list) -> list:
    """
    Computes two prefix sum arrays (left from the start and right from the end) and returns 
    a list of absolute differences between corresponding elements.
    """
    n = len(nums)
    left = [0] * n
    right = [0] * n
    s_left, s_right = 0, 0
    for i in range(n):
        left[i] = s_left
        s_left += nums[i]
        right[i] = s_right
        s_right += nums[n - 1 - i]
    return [abs(left[i] - right[n - 1 - i]) for i in range(n)]


# --- Next Function Block ---



def print_custom_pattern(n: int) -> None:
    """
    Prints a pattern on an n*n grid.
    The pattern logic follows the snippet condition: if j < 13 - i*i or j > 11 + i*i, print "*"; else print spaces.
    """
    total = n * n
    for i in range(total):
        for j in range(total):
            if j < 13 - i * i or j > 11 + i * i:
                print("*", end=" ")
            else:
                print("  ", end="")
        print()


# --- Next Function Block ---



def convert_date(date: str) -> str:
    """
    Converts a date from a format like "20th Oct 2052" to "2052-10-20".
    Assumes the day part may have ordinal suffixes.
    """
    month_map = {"Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04",
                 "May": "05", "Jun": "06", "Jul": "07", "Aug": "08",
                 "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"}
    parts = date.split()
    day = "".join(filter(str.isdigit, parts[0]))
    if len(day) == 1:
        day = "0" + day
    month = month_map[parts[1]]
    year = parts[2]
    return f"{year}-{month}-{day}"


# --- Next Function Block ---



def count_odds_in_range(low: int, high: int) -> int:
    """
    Returns the count of odd numbers in the inclusive range [low, high].
    """
    return sum(1 for i in range(low, high + 1) if i % 2 != 0)


# --- Next Function Block ---



def rearrange_string(s: str, indices: list) -> str:
    """
    Rearranges the characters in s according to the provided indices.
    """
    mapping = {idx: ch for idx, ch in zip(indices, s)}
    sorted_mapping = dict(sorted(mapping.items()))
    return "".join(sorted_mapping[i] for i in sorted_mapping)


# --- Next Function Block ---



def repeat_alternate(nums: list) -> list:
    """
    For every even-indexed element in nums, repeats the element at index i+1 a number of times equal to nums[i].
    Returns the resulting list.
    Example: for nums = [1,2,3,4], returns [2,4,4,4].
    """
    result = []
    for i in range(0, len(nums), 2):
        if i + 1 < len(nums):
            result.extend([nums[i+1]] * nums[i])
    return result


# --- Next Function Block ---



def first_k_words(s: str, k: int) -> str:
    """
    Returns the first k words from the string s.
    """
    words = s.split()
    return " ".join(words[:k])


# --- Next Function Block ---



def compare_word_lists(word1: list, word2: list) -> bool:
    """
    Concatenates the lists of strings and returns True if the resulting strings are equal.
    """
    return "".join(word1) == "".join(word2)


# --- Next Function Block ---



def sum_minus_digit_sum(nums: list) -> int:
    """
    Returns the difference between the sum of numbers in nums and the sum of all their digits.
    """
    total = sum(nums)
    digit_sum = sum(int(ch) for num in nums for ch in str(num))
    return total - digit_sum


# --- Next Function Block ---



def count_pairs_with_difference(nums: list, k: int) -> int:
    """
    Counts unique pairs (i, j) with i < j in nums such that abs(nums[i] - nums[j]) == k.
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if abs(nums[i] - nums[j]) == k:
                count += 1
    return count


# --- Next Function Block ---



def count_special_pairs(nums: list, k: int) -> int:
    """
    Counts pairs (i, j) with i < j where nums[i] equals nums[j] and (i*j) % k == 0.
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if nums[i] == nums[j] and (i * j) % k == 0:
                count += 1
    return count


# --- Next Function Block ---



def format_number_with_dots(n: int) -> str:
    """
    Formats the integer n by inserting dots as thousand separators.
    Example: 1234567 -> "1.234.567"
    """
    s = str(n)
    result = ""
    count = 0
    for ch in s[::-1]:
        if count == 3:
            result = "." + result
            count = 0
        result = ch + result
        count += 1
    return result


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the count of words in the list that contain only characters from allowed.
    """
    count = 0
    for word in words:
        if all(ch in allowed for ch in word):
            count += 1
    return count


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Formats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are also in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string: "G" remains, "()" becomes "o", and "(al)" becomes "al".
    Example: "G()(al)" -> "Goal"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims the text and redistributes spaces evenly between words.
    (A simple implementation that may not cover all edge cases.)
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area for the container with most water problem (brute force approach).
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For characters that repeat in s, returns the maximum gap (distance minus one)
    between two occurrences. If none repeat, returns -1.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps)


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums; if none exist, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Capitalizes the first letter of the string.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list 'nums' of length 2*n, interleaves the first n elements with the next n elements.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Splits s by spaces and returns the last integer found, or 0 if none.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Finds the longest common prefix among the list of strings using a brute-force approach.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes a list of emails by removing dots and ignoring characters after '+' in the local part.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price in the list, finds the first subsequent smaller price and subtracts it from the current price.
    Returns the modified list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the primary and secondary diagonal of a square matrix.
    If the matrix has an odd center, that value is subtracted once (since it was counted twice).
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the count of words in the list that contain only characters from allowed.
    """
    count = 0
    for word in words:
        if all(ch in allowed for ch in word):
            count += 1
    return count


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the number of characters in stones that are present in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string:
      "G" remains "G",
      "()" becomes "o",
      "(al)" becomes "al".
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels (starting from 'A').
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims the text and redistributes spaces evenly between words.
    (A simple approach; edge cases may vary.)
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area that can be formed by two lines in the list 'height'.
    (Brute-force O(n^2) approach.)
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For each character that repeats in s, computes the gap (difference in indices minus one)
    between its first and last occurrence. Returns the maximum such gap; if no repeats, returns -1.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums.
    If there are no duplicates, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Returns s with its first letter capitalized.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first half with the second half.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Returns the last integer found in s when splitting by spaces.
    If no integer is found, returns 0.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among the list of strings using a brute-force approach.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates in-place from a sorted list and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes emails by removing dots from the local part and ignoring everything after a '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price in prices, finds the first subsequent smaller price and subtracts it from the current price.
    Returns the adjusted list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the main and secondary diagonals of a square matrix.
    For odd-sized matrices, the center element is subtracted once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the number of words that consist solely of characters in allowed.
    """
    count = 0
    for word in words:
        if all(ch in allowed for ch in word):
            count += 1
    return count


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing each '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the number of characters in stones that are also in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string:
      - "G" -> "G"
      - "()" -> "o"
      - "(al)" -> "al"
    Example: "G()(al)" -> "Goal"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels (starting from 'A').
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims extra spaces from the text and redistributes spaces evenly between words.
    (Simple implementation.)
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area that can be formed by two indices in height (brute-force approach).
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For characters that repeat in s, returns the maximum gap (index difference minus one)
    between two occurrences. Returns -1 if no character repeats.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums, or None if there is none.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Returns the string s with its first letter capitalized.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first n elements with the last n elements.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Splits s by spaces and returns the last integer found, or 0 if none.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Finds the longest common prefix among the given list of strings.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes emails by removing dots in the local part and ignoring characters after '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price, finds the first subsequent smaller price and subtracts it from the current price.
    Returns the adjusted list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the main and secondary diagonals of a square matrix.
    If the matrix has an odd center, subtracts the center value once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the count of words that consist solely of characters in allowed.
    """
    return sum(1 for word in words if all(ch in allowed for ch in word))


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all odd-length subarrays of arr.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are also in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Interprets the command string:
      - "G" becomes "G"
      - "()" becomes "o"
      - "(al)" becomes "al"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims and redistributes spaces evenly between words in the text.
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum container area using a brute-force approach.
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters that appear exactly once in s.
    If all characters are unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For characters that repeat in s, returns the maximum gap (difference in indices minus one).
    Returns -1 if no character repeats.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums; returns None if there are no duplicates.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Returns the string s with its first letter capitalized.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first half with the second half.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Returns the last integer found in s when splitting by spaces, or 0 if none.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among the given strings using a brute-force method.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates in-place from a sorted list and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes email addresses by removing dots in the local part (before '+')
    and ignoring any characters after '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price in prices, subtracts the first subsequent smaller price (if found) and returns the modified list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of both the primary and secondary diagonals of a square matrix.
    If the matrix has an odd dimension, subtracts the center element once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the number of words that contain only characters found in allowed.
    """
    return sum(1 for word in words if all(ch in allowed for ch in word))


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing each '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the number of characters in stones that are also in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Interprets a command string:
      - "G" remains "G"
      - "()" becomes "o"
      - "(al)" becomes "al"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims the text and evenly redistributes spaces between words.
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area that can be formed between two lines in the list 'height'.
    (Brute-force approach.)
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    Returns the maximum gap (difference in indices minus one) between any two occurrences 
    of the same character in s. Returns -1 if no repeats exist.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element found in nums. Returns None if there is no duplicate.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Returns s with its first character capitalized.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first half with the second half.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Splits s by spaces and returns the last integer found; returns 0 if none is found.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among a list of strings using a brute-force approach.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates in-place from a sorted list and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes a list of emails by removing dots ('.') from the local part and ignoring everything after a '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price, finds the first subsequent smaller price and subtracts it from the current price.
    Returns the adjusted list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the primary and secondary diagonals of a square matrix.
    For odd dimensions, the center element is subtracted once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n//2][n//2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the number of words that consist only of characters in allowed.
    """
    return sum(1 for word in words if all(ch in allowed for ch in word))


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are also present in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string by mapping:
      "G" -> "G"
      "()" -> "o"
      "(al)" -> "al"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims extra spaces from text and evenly redistributes them between words.
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area that can be contained between two lines in the list height.
    (Brute-force approach.)
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For each character that repeats in s, returns the maximum gap (index difference minus one)
    between any two occurrences. If no character repeats, returns -1.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums, or None if no duplicate exists.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Capitalizes the first letter of s.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first half with the second half.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Returns the last integer found in s after splitting by spaces; returns 0 if none.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among a list of strings.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes emails by removing '.' from the local part and ignoring characters after '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price in prices, subtracts the first subsequent smaller price (if any) from it.
    Returns the adjusted list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the primary and secondary diagonals of a square matrix.
    If the matrix size is odd, the center element is counted only once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the number of words composed solely of characters in allowed.
    """
    return sum(1 for word in words if all(ch in allowed for ch in word))


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all odd-length subarrays of arr.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string by mapping:
      "G" -> "G",
      "()" -> "o",
      "(al)" -> "al".
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims the text and redistributes spaces evenly between words.
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return re


# --- Next Function Block ---


# patterns.py

def count_elements_geq_lowest_freq(nums: list) -> int:
    """
    Sorts the list, builds a frequency dictionary, then finds the smallest frequency entry.
    Returns the count of numbers in nums that are greater than or equal to the key
    of the lowest-frequency element.
    Example:
      nums = [3,9,7,8,3,8,6,6]
      Sorted nums: [3,3,6,6,7,8,8,9]
      Frequency: {3:2, 6:2, 7:1, 8:2, 9:1}
      Lowest frequency entry: (7,1)
      Count numbers >= 7 → 7,8,8,9 → 4
    """
    nums.sort()
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    # Get the (number, count) pair with the minimum count
    low = sorted(freq.items(), key=lambda x: x[1])[0]
    total = sum(1 for num in nums if num >= low[0])
    return total


# --- Next Function Block ---



def print_pattern_1(n: int) -> None:
    """
    Prints a pattern for n rows.
    (Based on the snippet with two nested loops and conditional spacing.)
    """
    for i in range(1, n + 1):
        for j in range(n):
            # Example condition: for i <= 3, print spaces for j < i; for i > 3, print spaces for j <= n-i.
            if (j < i and i <= 3) or (i > 3 and j <= n - i):
                print(" ", end="  ")
            else:
                print("*", end="  ")
        print("\n", end="")


# --- Next Function Block ---



def print_pattern_2(n: int) -> None:
    """
    Prints a second pattern based on an n*n grid.
    (The conditions are taken from the provided snippet.)
    """
    total = n * n
    for i in range(total):
        for j in range(total):
            # The condition is taken as provided; adjust if needed.
            if j < 13 - i * i or j > 11 + i * i:
                print("*", end=" ")
            else:
                print("  ", end="")
        print("\n", end="")


# --- Next Function Block ---



def convert_date(date: str) -> str:
    """
    Converts a date string like "20th Oct 2052" to the format "2052-10-20".
    """
    month_map = {
        "Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04",
        "May": "05", "Jun": "06", "Jul": "07", "Aug": "08",
        "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"
    }
    parts = date.split(" ")
    # Remove non-digit characters from the day part.
    day = "".join(ch for ch in parts[0] if ch.isdigit())
    if len(day) == 1:
        day = "0" + day
    month = month_map[parts[1]]
    year = parts[2]
    return f"{year}-{month}-{day}"


# --- Next Function Block ---



def count_odds_in_range(low: int, high: int) -> int:
    """
    Counts the number of odd numbers in the inclusive range [low, high].
    """
    count = 0
    for i in range(low, high + 1):
        if i % 2 != 0:
            count += 1
    return count


# --- Next Function Block ---



def reorder_string(s: str, indices: list) -> str:
    """
    Reorders string s based on the list of indices.
    Example:
       s = "codeleet", indices = [4,5,6,7,0,2,1,3] → returns "leetcode"
    """
    mapping = {idx: ch for idx, ch in zip(indices, s)}
    # Sort by index and join the characters.
    result = "".join(mapping[i] for i in sorted(mapping))
    return result


# --- Next Function Block ---



def running_sum(nums: list) -> list:
    """
    Returns a list of the running (cumulative) sum of nums.
    """
    total = 0
    result = []
    for num in nums:
        total += num
        result.append(total)
    return result


# --- Next Function Block ---



def sentence_with_most_words(sentences: list) -> list:
    """
    Splits each sentence into words and returns the word list for the sentence with the most words.
    """
    max_words = []
    for sentence in sentences:
        words = sentence.split()
        if len(words) > len(max_words):
            max_words = words
    return max_words


# --- Next Function Block ---



def prefix_diff(nums: list) -> list:
    """
    Computes two arrays:
      - left prefix sums (excluding current index)
      - right prefix sums (from the end)
    Returns a list of absolute differences between left prefix at index i and the reversed right prefix.
    """
    n = len(nums)
    left = []
    right = []
    s_left = 0
    s_right = 0
    for i in range(n):
        left.append(s_left)
        s_left += nums[i]
        right.append(s_right)
        s_right += nums[n - 1 - i]
    diff = []
    for i in range(n):
        diff.append(abs(left[i] - right[n - 1 - i]))
    return diff


# --- Next Function Block ---



def count_frequency_and_elements(nums: list) -> int:
    """
    Builds a frequency dictionary for nums, then finds the entry with the lowest frequency.
    Counts and prints indices and values for numbers in nums that are greater than or equal to the key
    of that lowest-frequency entry. Returns the total count.
    """
    nums.sort()
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    # Get the (number, count) pair with the minimum frequency.
    low = sorted(freq.items(), key=lambda x: x[1])[0]
    total = 0
    for i, num in enumerate(nums):
        if num >= low[0]:
            total += 1
            print(i, num)
    return total


# --- Next Function Block ---



def validate_pieces(arr: list, pieces: list) -> bool:
    """
    Given an array 'arr' and a list of lists 'pieces', attempts to reassemble arr
    by selecting pieces (each piece is a list of integers) if their elements appear in arr.
    Returns True if the concatenated pieces equal arr; otherwise, False.
    (Logic is based on the snippet and may need adjustment.)
    """
    assembled = []
    used = []
    # For each piece in pieces, if not already used and if its elements appear in arr, add it.
    for piece in pieces:
        if piece not in used and all(x in arr for x in piece):
            assembled.extend(piece)
            used.append(piece)
    return assembled == arr


# --- Next Function Block ---



def is_arithmetic_sequence(arr: list) -> bool:
    """
    Checks if the sorted list arr forms an arithmetic sequence.
    """
    if len(arr) < 2:
        return True
    arr = sorted(arr)
    diff = arr[1] - arr[0]
    for i in range(1, len(arr)):
        if arr[i] - arr[i - 1] != diff:
            return False
    return True


# --- Next Function Block ---



def are_all_arithmetic(lists: list) -> list:
    """
    Given a list of lists (each list of numbers), returns a list of booleans indicating whether
    each individual list is an arithmetic sequence.
    """
    result = []
    for lst in lists:
        result.append(is_arithmetic_sequence(lst))
    return result


# --- Next Function Block ---



def max_occurrences_of_word(sequence: str, word: str) -> int:
    """
    Returns the maximum number of non-overlapping occurrences of 'word' in 'sequence'.
    (Uses both a replace method and the built-in count for verification.)
    """
    count_builtin = sequence.count(word)
    # Alternatively, you might iterate over sequence to count non-overlapping occurrences.
    i, count = 0, 0
    while i <= len(sequence) - len(word):
        if sequence[i:i+len(word)] == word:
            count += 1
            i += len(word)
        else:
            i += 1
    # Return whichever count is higher (they should be equal if word does not overlap)
    return max(count, count_builtin)


# --- Next Function Block ---



def sum_halves(n: int) -> int:
    """
    Given n, repeatedly subtract half (floor division) until i <= 1.
    Returns the sum of all subtracted values.
    """
    count = 0
    while n > 1:
        sub = n // 2
        n = n - sub
        count += sub
    return count


# --- Next Function Block ---



def zigzag_convert(s: str, numRows: int) -> str:
    """
    Converts the string s into a zigzag pattern on numRows and reads line by line.
    (A simplified version of the zigzag conversion problem.)
    """
    if numRows == 1 or numRows >= len(s):
        return s
    rows = [''] * numRows
    cur_row, step = 0, 1
    for char in s:
        rows[cur_row] += char
        if cur_row == 0:
            step = 1
        elif cur_row == numRows - 1:
            step = -1
        cur_row += step
    return "".join(rows)


# --- Next Function Block ---



def equal_half_vowels(s: str) -> bool:
    """
    Checks if the first half and second half of string s have the same number of vowels.
    Assumes s length is even.
    """
    vowels = set("aeiouAEIOU")
    half = len(s) // 2
    first_half = s[:half]
    second_half = s[half:]
    count_first = sum(1 for ch in first_half if ch in vowels)
    count_second = sum(1 for ch in second_half if ch in vowels)
    return count_first == count_second


# --- Next Function Block ---



def election_winner(votes: list) -> str:
    """
    Given a list of votes (strings), returns the candidate with the most votes.
    """
    vote_counts = {}
    for vote in votes:
        vote_counts[vote] = vote_counts.get(vote, 0) + 1
    # Find candidate with maximum votes
    winner = max(vote_counts.items(), key=lambda x: x[1])[0]
    return winner


# --- Next Function Block ---



def count_special_substrings(s: str, r: str = "R", l: str = "L") -> int:
    """
    Constructs substrings of the form r repeated i times concatenated with l repeated i times,
    counts occurrences in s.
    """
    count_total = 0
    for i in range(1, len(s) + 1):
        substr = r * i + l * i
        if substr in s:
            occurrence = s.count(substr)
            print(substr, occurrence)
            count_total += occurrence
    return count_total


# --- Next Function Block ---



def count_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    Given a list of item lists and a rule specified by ruleKey ("type", "color", or "name"),
    counts how many items have the ruleValue at the corresponding index.
    Assumes: type → index 0, color → index 1, name → index 2.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints all elements of a 2D grid.
    """
    for row in grid:
        for elem in row:
            print(elem, end=" ")
        print()


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Sums numbers that appear only once in the list.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def sum_with_pattern(n: int) -> int:
    """
    For n iterations, accumulates a sum based on an increasing count and a position that resets every 7 counts.
    """
    total = 0
    count = 0
    pos = 1
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_mapping(nums: list) -> list:
    """
    Returns a new list where each element is nums[nums[i]].
    Assumes that all nums[i] are valid indices.
    """
    return [nums[x] for x in nums]


# --- Next Function Block ---



def sum_diff_by_divisibility(n: int, m: int) -> int:
    """
    Sums numbers from 1 to n that are not divisible by m and subtracts the sum of numbers that are divisible by m.
    """
    total_non_div = 0
    total_div = 0
    for i in range(1, n + 1):
        if i % m == 0:
            total_div += i
        else:
            total_non_div += i
    return total_non_div - total_div


# --- Next Function Block ---



def first_multiple_in_list(n: int, arr: list) -> int:
    """
    Returns the first multiple of n that is present in arr.
    """
    i = 1
    while True:
        multiple = i * n
        if multiple in arr:
            return multiple
        i += 1


# --- Next Function Block ---


def first_n_evens(n: int) -> list:
    """
    Returns a list of the first n even numbers.
    """
    return [i * 2 for i in range(1, n + 1)]


# --- Next Function Block ---


def gcd_from_list(nums: list) -> int:
    """
    Returns the greatest common divisor (GCD) of the minimum and maximum elements in nums.
    (Assumes positive numbers.)
    """
    from math import gcd
    low = min(nums)
    high = max(nums)
    return gcd(low, high)


# --- Next Function Block ---


def has_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    (This happens if n is a perfect square of a prime.)
    """
    import math
    if n < 4:
        return False
    sqrt_n = math.isqrt(n)
    if sqrt_n * sqrt_n != n:
        return False
    # Check if sqrt_n is prime.
    for i in range(2, int(math.sqrt(sqrt_n)) + 1):
        if sqrt_n % i == 0:
            return False
    return True


# --- Next Function Block ---


def custom_sort_validation(nums: list) -> bool:
    """
    Attempts a custom sort by removing and appending elements.
    Returns True if the custom-sorted list equals the actual sorted list.
    (Logic based on the provided snippet.)
    """
    original = nums[:]
    target = sorted(nums)
    arr = []
    i = 0
    # Use a copy for processing.
    temp = nums[:]
    while i < len(temp) - 1:
        if temp[i+1] < temp[i]:
            # Append the element at i+1 and remove it.
            arr.append(temp[i+1])
            del temp[i+1]
        else:
            i += 1
    result = arr + temp
    return result == target


# --- Next Function Block ---


def custom_remove_substring(str1: str, str2: str) -> str:
    """
    (Based on the provided snippet)
    If str2 is in str1, finds the first occurrence indices and removes that part.
    Otherwise returns str1.
    Note: If str2 is empty, returns str1.
    """
    if not str2:
        return str1
    idx = str1.find(str2)
    if idx != -1:
        return str1[:idx] + str1[idx+len(str2):]
    return str1


# --- Next Function Block ---


def sum_of_triangle_row_mins(triangle: list) -> int:
    """
    Given a triangle (list of lists), returns the sum of the minimum value in each row.
    """
    total = 0
    for row in triangle:
        total += min(row)
    return total


# --- Next Function Block ---


def remove_digit_and_record_indices(number: str, digit: str) -> (str, list):
    """
    Removes occurrences of digit from number and records the indices (of digit in original).
    Returns a tuple of (modified string, list of indices where digit was found).
    """
    indices = []
    result = ""
    for idx, ch in enumerate(number):
        if ch == digit:
            indices.append(idx)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---


def check_frequency_uniqueness(arr: list) -> bool:
    """
    Returns True if the sorted list of frequencies of elements equals the sorted unique frequencies.
    (Based on the provided snippet.)
    """
    freq = {}
    for num in arr:
        freq[num] = freq.get(num, 0) + 1
    freq_vals = sorted(freq.values())
    unique_vals = sorted(set(freq_vals))
    return freq_vals == unique_vals


# --- Next Function Block ---


def sum_of_divisible_elements(n: int) -> int:
    """
    For n = 7 (example), sums numbers from 1 to n and returns the difference between sum of numbers
    not divisible by a given condition and those that are divisible.
    (Based on the snippet where numbers divisible by m are summed separately.)
    This version uses m = 3 as in the snippet.
    """
    sum_non = 0
    sum_div = 0
    for i in range(1, n + 1):
        if i % 3 == 0:
            sum_div += i
        else:
            sum_non += i
    return sum_non - sum_div


# --- Next Function Block ---


def first_duplicate_in_list(nums: list):
    """
    Returns the first duplicate element in nums. If none found, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---


def rotate_array_right(nums: list, k: int) -> list:
    """
    Rotates the list nums to the right by k positions.
    """
    n = len(nums)
    k %= n
    return nums[-k:] + nums[:-k]


# --- Next Function Block ---


def sum_of_subarrays_with_odd_length(arr: list) -> int:
    """
    Sums all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---


def reformat_ip(address: str) -> str:
    """
    Reformats an IP address by inserting "[.]" between segments.
    Example: "1.1.1.1" -> "1[.]1[.]1[.]1"
    """
    parts = address.split(".")
    return "[.]".join(parts)


# --- Next Function Block ---


def count_jewels_in_stones(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are in jewels.
    """
    count = 0
    for ch in stones:
        if ch in jewels:
            count += 1
    return count


# --- Next Function Block ---


def interpret_command(command: str) -> str:
    """
    Interprets the command string:
      - "G" remains "G"
      - "()" is replaced by "o"
      - "(al)" is replaced by "al"
    Example: "G()(al)" -> "Goal"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---


def excel_columns(n: int) -> list:
    """
    Returns a list of the first n Excel column labels starting from 'A'.
    """
    return [chr(ord('A') + i) for i in range(n)]


# --- Next Function Block ---


def reformat_text(text: str) -> str:
    """
    Trims extra spaces and redistributes spaces evenly between words.
    (Simple approach: assumes extra spaces are those beyond single spaces.)
    """
    words = text.strip().split()
    return " ".join(words)


# --- Next Function Block ---




# patterns.py

# 1. Given a number, sort its digits and compute the sum of the integer
#    formed by concatenating the smallest and largest digit with the remaining two in order.
def sorted_digits_sum(num: int) -> int:
    """
    Converts num to its digit list, sorts the digits, then returns:
      int(sorted[0] + sorted[3]) + int(sorted[1] + sorted[2])
    Example: 2932 -> digits sorted = ['2','2','3','9'] → int('2'+'9') + int('2'+'3') = 29 + 23 = 52.
    """
    s = str(num)
    arr = list(s)
    arr.sort()
    # Concatenate first and last digit; then second and third.
    return int(arr[0] + arr[3]) + int(arr[1] + arr[2])


# --- Next Function Block ---



# 2. Alternating digit sum: add digits at even indices, subtract at odd.
def alternating_digit_sum(n: int) -> int:
    """
    Converts n to a string and alternately adds and subtracts digits.
    Example: 111 -> (1 - 1 + 1) = 1.
    """
    s = str(n)
    total = 0
    for i in range(len(s)):
        if i % 2 == 0:
            total += int(s[i])
        else:
            total -= int(s[i])
    return total


# --- Next Function Block ---



# 3. Extract all digits from a list of numbers.
def extract_digits(nums: list) -> list:
    """
    For each number in nums, extracts its digits and returns a flat list of all digits.
    Example: [13,25] -> [1, 3, 2, 5]
    """
    result = []
    for num in nums:
        for ch in str(num):
            result.append(int(ch))
    return result


# --- Next Function Block ---



# 4. Count numbers (1 to num) whose digit sum is even.
def count_even_digit_sum(num: int) -> int:
    """
    For every number from 1 to num, computes the sum of digits (printing each sum),
    and counts how many have an even digit sum.
    """
    count = 0
    for i in range(1, num + 1):
        s = str(i)
        digit_sum = sum(int(ch) for ch in s)
        # Uncomment the next line to print each sum:
        # print(digit_sum)
        if digit_sum % 2 == 0:
            count += 1
    return count


# --- Next Function Block ---



# 5. Letter-sum transformation.
def letter_sum_transformation(s: str, k: int) -> int:
    """
    Maps each letter in s to a number (a->1, b->2, ..., z->26) by concatenation.
    Then, for k iterations, sums all digits of the resulting string and reassigns.
    Finally, returns the final integer.
    Example: s="iiii", k=2.
    """
    mapping = {
        "a": "1", "b": "2", "c": "3", "d": "4", "e": "5",
        "f": "6", "g": "7", "h": "8", "i": "9", "j": "10",
        "k": "11", "l": "12", "m": "13", "n": "14", "o": "15",
        "p": "16", "q": "17", "r": "18", "s": "19", "t": "20",
        "u": "21", "v": "22", "w": "23", "x": "24", "y": "25", "z": "26"
    }
    res = ""
    for ch in s:
        res += mapping[ch]
    for _ in range(k):
        ssum = sum(int(ch) for ch in res)
        res = str(ssum)
    return int(res)


# --- Next Function Block ---



# 6. For a list of strings, for each pair compute a boolean array indicating for each letter in the first
#    string whether it is absent in the second; then find the maximum length of such an array that contains True.
def common_prefix_discrepancy(strs: list) -> (int, list):
    """
    For each pair (i, j) (i < j) in strs, builds an array with True where a character of strs[i]
    is not in strs[j], False otherwise. Then returns the maximum length among those arrays
    that contain at least one True, along with the list of arrays.
    (The logic is based on the provided snippet and may be interpreted.)
    """
    arrays = []
    max_len = -1
    for i in range(len(strs) - 1):
        for j in range(i + 1, len(strs)):
            arr = []
            for ch in strs[i]:
                if ch in strs[j]:
                    arr.append(False)
                else:
                    arr.append(True)
            arrays.append(arr)
            if True in arr and len(arr) > max_len:
                max_len = len(arr)
    return max_len, arrays


# --- Next Function Block ---



# 7. Compute a cost using total, cost1 and cost2.
def compute_cost(total: int, cost1: int, cost2: int) -> int:
    """
    Given total money and two costs, ensures cost1 is smaller than cost2,
    then simulates a purchase process and returns a computed value.
    (Logic is based on the provided snippet.)
    """
    if cost2 > cost1:
        # Swap cost1 and cost2 if needed.
        cost1, cost2 = cost2, cost1
    prd = 0
    for i in range(total // cost1):
        ttl = total - cost1 * i
        count = 1
        while ttl > 0:
            count += 1
            ttl -= cost2
        if ttl == 0:
            prd += count
    return prd + 1


# --- Next Function Block ---



# 8. Decode a string of the form "a1c1e1" into letters by shifting the previous letter.
def decode_string(s: str) -> str:
    """
    For each character in s, if it's a letter, output it.
    If it's a digit, take the previous letter's index in the alphabet and shift by that digit.
    Example: "a1c1e1" becomes "abcdef" (depending on dictionary).
    """
    alpha = "abcdefghijklmnopqrstuvwxyz"
    res = ""
    for i in range(len(s)):
        if s[i].isalpha():
            res += s[i]
        else:
            # s[i] is digit; shift previous letter.
            prev = s[i-1]
            ind = alpha.index(prev) + int(s[i])
            res += alpha[ind % 26]
    return res


# --- Next Function Block ---



# 9. Find the first index of target in nums, starting at index start.
def find_index(nums: list, target: int, start: int) -> int:
    """
    Returns the first index of target in nums, starting from start.
    If not found, returns -1.
    """
    for i in range(start, len(nums)):
        if nums[i] == target:
            return i
    return -1


# --- Next Function Block ---



# 10. Return substring of a numeric string up to and including the last odd digit (scanning from right).
def last_odd_substring(num: str) -> str:
    """
    Returns the substring of num up to (and including) the last odd digit when scanning from right.
    """
    for i in reversed(range(len(num))):
        if int(num[i]) % 2 == 1:
            return num[:i+1]
    return ""


# --- Next Function Block ---



# 11. Return the maximum digit that appears at least 3 times in num, repeated three times.
def triple_max_frequent_digit(num: str) -> str:
    """
    Finds all digits that appear at least 3 times in num.
    Returns the maximum such digit repeated three times.
    """
    freq = {}
    candidates = []
    for ch in num:
        freq[ch] = freq.get(ch, 0) + 1
        if freq[ch] >= 3 and int(ch) not in candidates:
            candidates.append(int(ch))
    if candidates:
        return str(max(candidates)) * 3
    return ""


# --- Next Function Block ---



# 12. Alternate approach: Check for each digit if its triple exists in num and choose the maximum.
def triple_max_digit_condition(num: str) -> str:
    """
    Checks each digit in num; if digit repeated three times is a substring,
    and the digit is larger than the current candidate, update candidate.
    Returns the candidate digit repeated three times.
    """
    grt = -1
    for ch in num:
        if (ch * 3) in num and int(ch) > grt:
            grt = int(ch)
    return str(grt) * 3 if grt > -1 else ""


# --- Next Function Block ---



# 13. Count keys in a dictionary.
def dict_key_count(d: dict) -> int:
    """
    Returns the number of keys in dictionary d.
    """
    return len(d)


# --- Next Function Block ---



# 14. Check if both left and right values appear in any of the given ranges.
def check_range(ranges: list, left: int, right: int) -> bool:
    """
    Checks if left and right exist in any range (list of two numbers) from ranges.
    Returns True if both found; otherwise False.
    """
    isLeft = False
    isRight = False
    for r in ranges:
        if left in r or isLeft:
            isLeft = True
            if right in r:
                isRight = True
    return isLeft and isRight


# --- Next Function Block ---



# 15. Simulate a lock. Given a starting lock (e.g. ["0","0","0","0"]) and a target lock as a string,
#     increment digits until lock equals target; count the moves.
def open_lock(target: str) -> (list, int):
    """
    Starting from ["0", "0", "0", "0"], increments individual digits (left-to-right)
    until the lock matches target. Returns the final lock state (as a list of strings) and the move count.
    """
    lock = ["0", "0", "0", "0"]
    target_list = list(target)
    count = 0
    i = 0
    while lock != target_list and i < len(lock):
        if lock[i] != target_list[i]:
            # Increment digit by 1 (as string)
            lock[i] = str(int(lock[i]) + 1)
            count += 1
        else:
            i += 1
    return lock, count


# --- Next Function Block ---



# 16. Count Pythagorean triplets (brute force) for numbers 1 to num.
def count_pythagorean_triplets(num: int) -> int:
    """
    Counts the number of Pythagorean triplets (idx, jdx, kdx) with 1 <= idx, jdx, kdx <= num.
    """
    count = 0
    for a in range(1, num+1):
        for b in range(1, num+1):
            if a == b:
                continue
            for c in range(max(a, b) + 1, num+1):
                if a * a + b * b == c * c:
                    count += 1
                    # Uncomment to print the triplet:
                    # print(a, b, c)
    return count


# --- Next Function Block ---



# 17. Count Pythagorean triplets (variant with three loops, skipping i == j).
def count_pythagorean_triplets_variant(num: int) -> int:
    """
    Another variant to count Pythagorean triplets using three nested loops.
    """
    count = 0
    for k in range(1, num+1):
        for i in range(1, k):
            for j in range(1, k):
                if i == j:
                    continue
                if i * i + j * j == k * k:
                    count += 1
    return count


# --- Next Function Block ---



# 18. Count numbers that have at least one non-identical partner.
def count_non_identical_partners(nums: list) -> int:
    """
    For each pair of distinct numbers in nums, collects the unique numbers that appear in such pairs.
    Returns the count of unique numbers that appear in a pair with a different number.
    """
    arr = []
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            if nums[i] != nums[j]:
                if nums[i] not in arr:
                    arr.append(nums[i])
                if nums[j] not in arr:
                    arr.append(nums[j])
    return len(arr)


# --- Next Function Block ---



# 19. Check if all characters in a string have the same frequency.
def all_equal_frequency(s: str) -> bool:
    """
    Returns True if every character in s occurs the same number of times; otherwise False.
    """
    freq = {ch: s.count(ch) for ch in s}
    first = next(iter(freq.values()))
    for count in freq.values():
        if count != first:
            return False
    return True


# --- Next Function Block ---



# 20. Count word frequencies in a sentence.
def count_word_frequencies(text: str) -> dict:
    """
    Returns a dictionary with word frequencies from text.
    """
    words = text.split()
    freq = {}
    for word in words:
        freq[word] = freq.get(word, 0) + 1
    return freq


# --- Next Function Block ---



# 21. Compute differences in groups: for sorted nums in descending order,
#     for each index i (up to len(nums)-k), for j in i+1 to i+1+k, record the difference.
def differences_in_groups(nums: list, k: int) -> list:
    """
    Sorts nums in reverse order and, for each index i up to len(nums)-k, computes differences with the next k numbers.
    Returns the list of differences.
    """
    result = []
    nums.sort(reverse=True)
    for i in range(len(nums) - k):
        for j in range(i+1, i+1+k):
            result.append(nums[i] - nums[j])
    return result


# --- Next Function Block ---



# 22. Reverse substring up to a given character.
def reverse_up_to_char(word: str, ch: str) -> str:
    """
    Finds the first occurrence of ch in word, reverses the substring up to and including that character,
    then concatenates the remainder.
    """
    ind = word.index(ch)
    return word[:ind+1][::-1] + word[ind+1:]


# --- Next Function Block ---



# 23. Compute maximum differences for each element:
def max_differences(nums: list) -> list:
    """
    For each index in nums, computes the maximum difference (nums[j]-nums[i]) for j > i.
    Returns a list with -1 as the first element and the maximum differences for subsequent indices.
    """
    result = [-1]
    for i in range(len(nums)-1):
        diffs = []
        for j in range(i+1, len(nums)):
            if nums[j] > nums[i]:
                diffs.append(nums[j] - nums[i])
        if diffs:
            result.append(max(diffs))
    return result


# --- Next Function Block ---



# 24. Find maximum gap (j - i) such that colors[i] != colors[j].
def max_index_gap_different(colors: list) -> int:
    """
    Returns the maximum index gap between two elements in colors that are different.
    """
    max_gap = -1
    n = len(colors)
    for i in range(n-1):
        for j in range(i+1, n):
            if colors[i] != colors[j] and (j - i) > max_gap:
                max_gap = j - i
    return max_gap


# --- Next Function Block ---



# 25. Shifting letters: using shifts list to transform s.
def shifting_letters(s: str, shifts: list) -> str:
    """
    For each index i in s, sums shifts from i to end, adds the index of s[i] in the alphabet,
    takes modulo 26, and returns the corresponding letter. Builds the final string.
    """
    alphabet = [chr(i) for i in range(ord('a'), ord('z')+1)]
    res = ""
    for i in range(len(s)):
        total = sum(shifts[i:]) + alphabet.index(s[i])
        total %= 26
        res += alphabet[total]
    return res


# --- Next Function Block ---



# 26. Reshape a 1D list into an m x n matrix.
def reshape_matrix(original: list, m: int, n: int) -> list:
    """
    Reshapes the list 'original' into a matrix with m rows and n columns.
    Assumes len(original) == m * n.
    """
    matrix = []
    k = 0
    for i in range(m):
        row = []
        for j in range(n):
            row.append(original[k])
            k += 1
        matrix.append(row)
    return matrix


# --- Next Function Block ---



# 27. Merge two lists of pairs (ambiguous logic from snippet).
def merge_pair_lists(nums1: list, nums2: list) -> list:
    """
    Given two lists of pairs, for each corresponding pair, if their first elements are equal,
    add their second elements; otherwise, collect the pair from the second list.
    Then, insert these collected pairs into the longer list based on the first element.
    (Logic is ambiguous; this is one interpretation.)
    """
    longest = nums1 if len(nums1) >= len(nums2) else nums2
    shortest = nums2 if longest is nums1 else nums1
    extra = []
    for i in range(len(shortest)):
        pair_long = longest[i]
        pair_short = shortest[i]
        if pair_long[0] == pair_short[0]:
            pair_long[1] += pair_short[1]
        else:
            extra.append(pair_short)
    # Insert extra pairs into longest based on first element (index = first element - 1)
    for pair in extra:
        ind = pair[0] - 1
        longest.insert(ind, pair)
    return longest


# --- Next Function Block ---



# 28. Print every 5th element’s first two numbers from an array.
def print_every_fifth(arr: list) -> None:
    """
    Iterates over arr with a step of 5 and prints arr[i] and arr[i+1] if available.
    """
    for i in range(0, len(arr), 5):
        if i + 1 < len(arr):
            print(arr[i])
            print(arr[i+1])


# --- Next Function Block ---



# 29. Intersection among three lists.
def intersect_three_lists(nums1: list, nums2: list, nums3: list) -> list:
    """
    Returns the list of unique elements that appear in at least two of the three lists.
    """
    set1 = set(nums1)
    set2 = set(nums2)
    set3 = set(nums3)
    # Intersection among any two:
    inter = (set1 & set2) | (set1 & set3) | (set2 & set3)
    return list(inter)


# --- Next Function Block ---



# 30. Check if all characters in a string occur with equal frequency.
def all_equal_frequency(s: str) -> bool:
    """
    Returns True if all characters in s have the same frequency; otherwise False.
    """
    freq = {ch: s.count(ch) for ch in s}
    return len(set(freq.values())) == 1


# --- Next Function Block ---



# 31. Count word frequencies.
def word_frequencies(text: str) -> dict:
    """
    Splits text by spaces and returns a dictionary of word frequencies.
    """
    words = text.split()
    freq = {}
    for word in words:
        freq[word] = freq.get(word, 0) + 1
    return freq


# --- Next Function Block ---




def most_frequent_prefix(strs: list) -> str:
    """
    Attempts to compute the prefix of the first string that appears most frequently among the strings.
    (The logic is ambiguous; here we simply return the longest common prefix.)
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# --- Next Function Block ---



# 74. Find all common prefixes from the first string that appear in every string.
def all_common_prefixes(strs: list) -> list:
    """
    Returns a list of all prefixes of the first string that are common to all strings in the list.
    """
    if not strs:
        return []
    common = []
    base = strs[0]
    for i in range(1, len(base) + 1):
        prefix = base[:i]
        if all(s.startswith(prefix) for s in strs):
            common.append(prefix)
    return common


# --- Next Function Block ---



# 75. For each number in nums, compute the sum of absolute differences with all numbers.
def sum_abs_differences(nums: list) -> list:
    """
    Returns a list where for each element in nums, the value is the sum of absolute differences
    between that element and every element in nums.
    """
    result = []
    for i in nums:
        total = sum(abs(i - j) for j in nums)
        result.append(total)
    return result


# --- Next Function Block ---




# anagrams.py
def are_anagrams(s: str, t: str) -> bool:
    """
    Returns True if strings s and t have the same character frequencies.
    """
    if len(s) != len(t):
        return False

    sdict = {}
    tdict = {}

    for i in range(len(s)):
        scount = 1
        tcount = 1
        for j in range(len(s)):
            if i != j:
                if s[i] == s[j]:
                    scount += 1
                if t[i] == t[j]:
                    tcount += 1
        sdict[s[i]] = scount
        tdict[t[i]] = tcount

    return sdict == tdict


# --- Next Function Block ---


# dominoes.py
def count_domino_pairs(dominoes: list) -> int:
    """
    Counts the number of equivalent domino pairs.
    Dominoes are considered equivalent if their sorted values are equal.
    """
    domino_count = {}
    count = 0
    for domino in dominoes:
        # Sort to get a consistent representation
        sorted_domino = tuple(sorted(domino))
        if sorted_domino in domino_count:
            count += domino_count[sorted_domino]
            domino_count[sorted_domino] += 1
        else:
            domino_count[sorted_domino] = 1
    return count


# --- Next Function Block ---


# compare_sorted_numbers.py
def compare_sorted_lists(nums: list):
    """
    Returns a tuple (sorted_set, sorted_nums) if the set and list differ,
    otherwise returns False.
    """
    sorted_set = sorted(set(nums))
    nums_sorted = sorted(nums)
    if sorted_set == nums_sorted:
        return False
    else:
        return sorted_set, nums_sorted


# --- Next Function Block ---


# pascals_triangle.py
def generate_pascals_triangle(n: int) -> list:
    """
    Generates Pascal's triangle with n rows.
    """
    triangle = []
    for i in range(n):
        row = [1]
        if i > 0:
            last_row = triangle[-1]
            for j in range(1, i):
                row.append(last_row[j-1] + last_row[j])
            row.append(1)
        triangle.append(row)
    return triangle


# --- Next Function Block ---


# day_of_year.py
def day_of_year(date_str: str) -> int:
    """
    Given a date string in 'YYYY-MM-DD' format, returns its day-of-year.
    """
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    year, month, day = map(int, date_str.split("-"))
    day_count = sum(days_in_month[:month-1]) + day
    # Check for leap year: divisible by 4 and (not divisible by 100 or divisible by 400)
    if (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)) and month > 2:
        day_count += 1
    return day_count


# --- Next Function Block ---


# majority_element.py
def majority_element(nums: list):
    """
    Returns the element that occurs most frequently in nums.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    max_count = 0
    majority = None
    for num, count in freq.items():
        if count > max_count:
            max_count = count
            majority = num
    return majority


# --- Next Function Block ---


# tribonacci.py
def tribonacci(n: int) -> int:
    """
    Returns the (n+1)th Tribonacci number.
    Starting with trib[0]=0, trib[1]=0, trib[2]=1.
    """
    trib = [0, 0, 1]
    for i in range(2, n + 1):
        trib.append(trib[i-2] + trib[i-1] + trib[i])
    return trib[n+1]


# --- Next Function Block ---


# factorial_division.py
def compute_factorial_divided(n: int) -> int:
    """
    Computes (2*n)! divided by 2^n.
    """
    num = n * 2
    factorial = 1
    for i in range(num, 0, -1):
        factorial *= i
    return factorial // (2 ** n)


# --- Next Function Block ---


# min_frequency_element.py
def min_frequency_element(nums: list):
    """
    Returns the element with the minimum frequency in nums.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    min_count = float('inf')
    element = None
    for num, count in freq.items():
        if count < min_count:
            min_count = count
            element = num
    return element


# --- Next Function Block ---


# search_insert.py
def search_insert(nums: list, target: int):
    """
    Returns a tuple (position, new_list) where position is the index of target in the sorted list.
    If target is not in nums, it is inserted into the correct sorted position.
    """
    if target in nums:
        return nums.index(target), nums
    for i, num in enumerate(nums):
        if target < num:
            nums.insert(i, target)
            return i, nums
    nums.append(target)
    return len(nums) - 1, nums


# --- Next Function Block ---


# str_str.py
def find_substring(haystack: str, needle: str) -> int:
    """
    Returns the index of the first occurrence of needle in haystack, or -1 if not found.
    """
    return haystack.find(needle)


# --- Next Function Block ---




# patterns.py

def reverse_vowels(s: str) -> str:
    """
    Reverses only the vowels in the string.
    Example: "hello" -> "holle"
    """
    vowels = ['a','e','i','o','u','A','E','I','O','U']
    s_list = list(s)
    # Collect vowels in order.
    collected = [ch for ch in s_list if ch in vowels]
    # Reverse the collected vowels.
    collected = collected[::-1]
    idx = 0
    # Replace vowels in s_list with reversed ones.
    for i in range(len(s_list)):
        if s_list[i] in vowels:
            s_list[i] = collected[idx]
            idx += 1
    return "".join(s_list)


# --- Next Function Block ---



def sort_vowels_in_string(s: str) -> str:
    """
    Extracts vowels from s, sorts them (by ascii), then replaces vowels in order.
    Example: "lEetcOde" -> vowels sorted: ['E','O','e','o'] and then reinserted.
    """
    vowels = ['a','e','i','o','u','A','E','I','O','U']
    s_list = list(s)
    # Collect ascii codes of vowels.
    vowel_codes = [ord(ch) for ch in s_list if ch in vowels]
    vowel_codes.sort()
    sorted_vowels = "".join(chr(code) for code in vowel_codes)
    idx = 0
    res = ""
    for ch in s_list:
        if ch in vowels:
            res += sorted_vowels[idx]
            idx += 1
        else:
            res += ch
    return res


# --- Next Function Block ---



def unique_chars(s: str) -> str:
    """
    Returns a string made of unique characters in s (order arbitrary).
    Example: "pwwkew" -> a string with unique letters.
    """
    return "".join(set(s))


# --- Next Function Block ---



def reduce_value(n: float) -> float:
    """
    Divides n by 2 repeatedly until n <= 2.
    """
    while n > 2:
        n /= 2
    return n


# --- Next Function Block ---



def move_zeros_nested(nums: list) -> list:
    """
    Moves zeros in a list to the end using nested loops.
    Example: [0,0,1,0,3,12] becomes a list with non-zeros first.
    """
    nums = nums[:]  # copy to avoid mutation
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            if nums[i] == 0 and nums[j] != 0:
                nums[i], nums[j] = nums[j], 0
    return nums


# --- Next Function Block ---



def move_zeros_remove(nums: list) -> list:
    """
    Moves zeros to the end by removing and appending.
    Example: [0,1,0,3,12] becomes [1,3,12,0,0].
    """
    nums = nums[:]  # copy
    for i in nums[:]:
        if i == 0:
            nums.remove(i)
            nums.append(0)
    return nums


# --- Next Function Block ---



def combine_adjacent_equal(nums: list) -> list:
    """
    Combines two equal adjacent numbers by doubling the first and zeroing the second.
    Then moves zeros to the end.
    Example: [1,2,2,1,1,0] --> after combination and shifting zeros.
    """
    nums = nums[:]  # copy
    for i in range(len(nums)-1):
        if nums[i] == nums[i+1]:
            nums[i] *= 2
            nums[i+1] = 0
    # Remove zeros and append them at the end.
    result = [num for num in nums if num != 0]
    result.extend([0] * (len(nums) - len(result)))
    return result


# --- Next Function Block ---



def int_to_roman(num: int) -> str:
    """
    Converts an integer to a Roman numeral string.
    """
    mapping = {1000:'M', 500:'D', 100:'C', 50:'L', 10:'X', 5:'V', 1:'I'}
    out = ""
    n = num
    while n > 0:
        if n >= 1000:
            n -= 1000
            out += mapping[1000]
        elif n >= 900:
            n -= 900
            out += mapping[100] + mapping[1000]
        elif n >= 500:
            n -= 500
            out += mapping[500]
        elif n >= 400:
            n -= 400
            out += mapping[100] + mapping[500]
        elif n >= 100:
            n -= 100
            out += mapping[100]
        elif n >= 90:
            n -= 90
            out += mapping[10] + mapping[100]
        elif n >= 50:
            n -= 50
            out += mapping[50]
        elif n >= 40:
            n -= 40
            out += mapping[10] + mapping[50]
        elif n >= 10:
            n -= 10
            out += mapping[10]
        elif n >= 9:
            n -= 9
            out += mapping[1] + mapping[10]
        elif n >= 5:
            n -= 5
            out += mapping[5]
        elif n >= 4:
            n -= 4
            out += mapping[1] + mapping[5]
        else:
            n -= 1
            out += mapping[1]
    return out


# --- Next Function Block ---



def multiply_str_numbers(num1: str, num2: str) -> int:
    """
    Converts two string numbers to integers and returns their product.
    """
    return int(num1) * int(num2)


# --- Next Function Block ---



def min_diff_pair(arr: list) -> list:
    """
    Given a sorted array, finds and returns the pair of numbers with the minimum difference.
    """
    arr = sorted(arr)
    diffs = []
    pairs = []
    for i in range(len(arr)-1):
        diff = arr[i+1] - arr[i]
        diffs.append(diff)
        pairs.append([arr[i], arr[i+1]])
    min_diff = min(diffs) if diffs else None
    for pair in pairs:
        if pair[1] - pair[0] == min_diff:
            return pair
    return []


# --- Next Function Block ---



def insert_zeros_after_even(nums: list) -> list:
    """
    Inserts two zeros immediately after every even number in the list.
    """
    i = 0
    nums = nums[:]  # copy
    while i < len(nums):
        if nums[i] % 2 == 0:
            nums.insert(i+1, 0)
            nums.insert(i+2, 0)
            i += 3
        else:
            i += 1
    return nums


# --- Next Function Block ---



def remove_two_after_condition(arr: list) -> list:
    """
    If an element in arr is divisible by 5 and there's a next element, remove the next two elements.
    (Note: This logic is based on the given code and may remove fewer than two if not available.)
    """
    arr = arr[:]  # copy
    i = 0
    while i < len(arr) - 1:
        if arr[i] % 5 == 0:
            # Remove next two elements if possible.
            if i+1 < len(arr):
                arr.pop(i+1)
            if i+1 < len(arr):
                arr.pop(i+1)
        i += 1
    return arr


# --- Next Function Block ---



def check_coordinate_difference(coordinates: list) -> bool:
    """
    Given a list of [x,y] coordinates, attempts to check if the differences between consecutive coordinates are consistent.
    (The original logic is ambiguous; this function mimics the provided approach.)
    """
    if not coordinates:
        return True
    diff = coordinates[0][0] - coordinates[0][1]
    diffx = []
    diffy = []
    h = 0
    out = True
    for i in range(len(coordinates)):
        k = coordinates[i]
        if i < len(coordinates) - 1:
            l = coordinates[i+1]
        for j in range(len(k) - 1):
            if diff:
                if k[0] - k[1] == diff:
                    if i < len(coordinates) - 1:
                        diffx.append(l[0] - k[0])
                        diffy.append(l[1] - k[1])
                        if h > 0 and diffx[h-1] == diffx[h] and diffy[h-1] == diffy[h]:
                            h += 1
                        elif diff != 0 and diffx[h] % diff == 0 and diffy[h] % diff == 0:
                            h += 1
                        else:
                            out = False
                            break
                else:
                    out = False
                    break
            else:
                diff = k[0] - k[1]
    return out


# --- Next Function Block ---



def max_profit_difference(arr: list) -> int:
    """
    Given a list of prices (or similar), finds the pair with the minimum difference and returns the difference between sell and buy.
    If the difference is negative, returns 0.
    (Logic based on the provided snippet.)
    """
    diff_map = {}
    for i in range(len(arr)-1):
        minval = arr[0]  # initial min value difference (this logic is ambiguous)
        for j in range(i+1, len(arr)):
            if arr[i] - arr[j] < minval:
                minval = arr[i] - arr[j]
                buyval = arr[i]
                sellval = arr[j]
        diff_map[minval] = [buyval, sellval]
    key = min(diff_map) if diff_map else 0
    val = diff_map.get(key, [0, 0])
    res = val[1] - val[0]
    if res <= 0:
        res = 0
    return res


# --- Next Function Block ---



def find_min_in_list(arr: list) -> int:
    """
    Returns the minimum value in the list.
    """
    if not arr:
        return None
    min_val = arr[0]
    for i in arr:
        if i < min_val:
            min_val = i
    return min_val


# --- Next Function Block ---



def print_star_pattern():
    """
    Prints a pattern:
    For each i from 1 to 3:
      - Print a line with '*' (with newline)
      - Then print i blocks of a square pattern where each block is a row of i stars repeated 'size' times.
      'size' doubles for each i.
    """
    size = 2
    for i in range(1, 4):
        # Print i lines with "*"
        for j in range(i):
            print("*")
        # Print square blocks
        for k in range(i):
            for l in range(size):
                print("*", end=" ")
            print()  # new line after each block row
        size *= 2


# --- Next Function Block ---





# patterns.py

def symmetric_differences(arr: list) -> list:
    """
    Given an array, computes absolute differences between elements
    from the start and end moving inward.
    Example:
      Input: [7,3,5,2,10,6,8,1,4,9]
      Output: list of differences for first half of array with corresponding symmetric elements.
    """
    size = len(arr)
    diff = []
    i, n = 0, size - 1
    for _ in range(size // 2):
        # If indices cross, break (though loop is already half-length)
        if i == n:
            break
        diff.append(abs(arr[i] - arr[n]))
        i += 1
        n -= 1
    return diff


# --- Next Function Block ---



def product_minus_sum(n: int) -> int:
    """
    Converts an integer to string, computes the product of its digits,
    the sum of its digits, and returns (product - sum).
    Example: n=234 -> (2*3*4) - (2+3+4) = 24 - 9 = 15
    """
    s = str(n)
    prod = 1
    total = 0
    for ch in s:
        digit = int(ch)
        total += digit
        prod *= digit
    return prod - total


# --- Next Function Block ---



def sum_of_multiples(n: int) -> int:
    """
    Sums all numbers in the range [1, n) that are divisible by 3, 5, or 7.
    Example: n=7 sums numbers in 1...6 meeting the condition.
    """
    total = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0 or i % 7 == 0:
            total += i
    return total


# --- Next Function Block ---



def nine_minus_one(n: int) -> int:
    """
    For a given integer n, creates a number with the same number of digits all '9's
    and a number with the same number of digits all '1's, then returns their difference.
    Example: n=555 -> "999" - "111" = 888.
    """
    s = str(n)
    large = int("9" * len(s))
    small = int("1" * len(s))
    return large - small


# --- Next Function Block ---



def product_of_list(nums: list, verbose: bool = False) -> int:
    """
    Multiplies the numbers in the list (iterating in reverse order).
    Optionally prints each number.
    """
    product = 1
    for num in nums[::-1]:
        if verbose:
            print(num)
        product *= num
    return product


# --- Next Function Block ---



def longest_common_prefix(strs: list) -> str:
    """
    Returns the longest common prefix among the list of strings.
    If there is none, returns an empty string.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        # Shorten the prefix until s starts with it
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def max_right(arr: list) -> list:
    """
    Given an array, returns a new list where each element at index i is
    replaced by the maximum element to its right; the last element is -1.
    Example: [7,3,5,2,10] -> [10,10,10,10,-1]
    """
    size = len(arr)
    if size == 0:
        return []
    result = [None] * size
    result[-1] = -1
    max_so_far = arr[-1]
    for i in range(size - 2, -1, -1):
        if arr[i] > max_so_far:
            max_so_far = arr[i]
        result[i] = max_so_far
    return result


# --- Next Function Block ---



def generate_random_array(n: int) -> tuple:
    """
    Generates an array of n-1 distinct random integers between -n and n (excluding 0),
    then appends -sum(array) if not already present, or adjusts if it is.
    Returns a tuple: (array, count, -count), where count is the sum of the initial array.
    """
    import random
    array = []
    count = 0
    while len(array) < n - 1:
        val = random.randint(-n, n)
        if val not in array and val != 0:
            array.append(val)
            count += val
    if -count not in array:
        array.append(-count)
    else:
        idx = array.index(-count)
        array[idx] = 0
        array.append(-count + (-count))
    return array, count, -count


# --- Next Function Block ---



def modify_number(num: int) -> int:
    """
    Given a number, replaces the first digit that is less than 9 with 9.
    Then, in a while loop, if a digit (starting from the right) equals 6,
    adds 3 times its positional value to the original number and stops.
    Returns the modified number.
    """
    s = str(num)
    ret = ""
    ins = True
    for ch in s:
        digit = int(ch)
        if digit < 9 and ins:
            ret += "9"
            ins = False
        else:
            ret += ch
    modified = int(ret)
    
    # Process digits from right side
    temp = num
    count = 0
    while temp > 1:
        if temp % 10 == 6:
            modified += 3 * (10 ** count)
            break
        count += 1
        temp //= 10
    return modified


# --- Next Function Block ---



def pascal_row(row_index: int) -> list:
    """
    Returns the row_index-th row of Pascal's Triangle.
    Example: row_index=0 returns [1], row_index=1 returns [1,1], etc.
    """
    triangle = []
    for i in range(row_index + 1):
        row = [1]
        if i > 0:
            prev = triangle[-1]
            for j in range(1, i):
                row.append(prev[j-1] + prev[j])
            row.append(1)
        triangle.append(row)
    return triangle[row_index]


# --- Next Function Block ---



def min_max_game(nums: list) -> int:
    """
    Given a list of numbers, repeatedly perform the following:
      - Partition the list into pairs.
      - For each pair, if it's the turn for 'min', choose the minimum; otherwise, choose the maximum.
      - Continue until one number remains.
    Returns the final number.
    """
    turn = True  # True means take min, False means take max.
    while len(nums) > 1:
        new_nums = []
        for i in range(0, len(nums) - 1, 2):
            if turn:
                new_nums.append(min(nums[i], nums[i+1]))
            else:
                new_nums.append(max(nums[i], nums[i+1]))
            turn = not turn
        if len(nums) % 2 == 1:
            new_nums.append(nums[-1])
        nums = new_nums
    return nums[0]


# --- Next Function Block ---



def chunk_string(s: str, k: int) -> list:
    """
    Splits the string s into chunks of length k.
    The final chunk may be shorter if s is not divisible by k.
    """
    return [s[i:i+k] for i in range(0, len(s), k)]


# --- Next Function Block ---



def min_max_game_progression(nums: list) -> list:
    """
    Implements the Min Max Game (LeetCode #2293) and returns all intermediate lists.
    """
    result = [nums]
    flag = True
    while len(result[-1]) > 1:
        current = result[-1]
        new_list = []
        i = 0
        while i < len(current) - 1:
            if flag:
                new_list.append(min(current[i], current[i+1]))
            else:
                new_list.append(max(current[i], current[i+1]))
            flag = not flag
            i += 2
        result.append(new_list)
    return result


# --- Next Function Block ---



def most_frequent(nums: list):
    """
    Returns the most frequent element in the list.
    """
    freq = {}
    max_count = 0
    max_elem = None
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
        if freq[num] > max_count:
            max_count = freq[num]
            max_elem = num
    return max_elem


# --- Next Function Block ---



def compute_ranks(arr: list) -> list:
    """
    Computes the rank for each element in the original array.
    Rank is defined as:
       - Unique elements are sorted.
       - The rank is 1 for the smallest element, 2 for the next, etc.
    Returns a list of ranks corresponding to the original array.
    """
    sorted_unique = sorted(set(arr))
    rank_dict = {num: rank+1 for rank, num in enumerate(sorted_unique)}
    return [rank_dict[num] for num in arr]


# --- Next Function Block ---



def print_symmetric_pairs(s: str) -> None:
    """
    Prints pairs of characters from the string: first with last, second with second-last, etc.
    """
    size = len(s)
    for i in range(size // 2):
        print(s[i], s[size - 1 - i])


# --- Next Function Block ---



def max_area(height: list) -> int:
    """
    Given a list of heights, returns the maximum area formed by two indices,
    defined as min(height[i], height[j]) * (j - i). (O(n^2) brute force approach.)
    """
    max_area_val = 0
    size = len(height)
    for i in range(size - 1):
        for j in range(i + 1, size):
            area = min(height[i], height[j]) * (j - i)
            if area > max_area_val:
                max_area_val = area
    return max_area_val


# --- Next Function Block ---




# patterns.py

# 1. Happy Number Check (using sum of squares of digits)
def is_happy(n: int, max_iter: int = 100) -> bool:
    """
    Determines if a number is "happy". A number is happy if repeatedly replacing
    it with the sum of the squares of its digits eventually leads to 1.
    """
    for _ in range(max_iter):
        s = str(n)
        total = sum(int(ch) ** 2 for ch in s)
        n = total
        if n == 1:
            return True
    return False


# --- Next Function Block ---


# 2. k Least Ones Rows in a Binary Matrix
def k_least_ones_rows(mat: list, k: int) -> list:
    """
    Given a binary matrix, counts the number of 1's in each row and returns
    the indices of the k rows with the fewest 1's.
    """
    row_counts = {i: sum(row) for i, row in enumerate(mat)}
    sorted_rows = sorted(row_counts.items(), key=lambda x: x[1])
    return [i for i, _ in sorted_rows[:k]]


# --- Next Function Block ---


# 3. Check if s is a Subsequence of t
def is_subsequence(s: str, t: str) -> bool:
    """
    Returns True if s is a subsequence of t.
    """
    pos = 0
    for char in s:
        pos = t.find(char, pos)
        if pos == -1:
            return False
        pos += 1
    return True


# --- Next Function Block ---


# 4. Digit Root (Repeated sum of digits until single digit)
def digit_root(n: int) -> int:
    """
    Repeatedly sums the digits of n until a single digit is obtained.
    """
    while n >= 10:
        n = sum(int(d) for d in str(n))
    return n


# --- Next Function Block ---


# 5. Count Numbers Smaller Than Current
def count_smaller_numbers(nums: list) -> list:
    """
    For each number in nums, counts how many numbers in nums are smaller.
    """
    result = []
    for i in range(len(nums)):
        count = sum(1 for j in range(len(nums)) if nums[i] > nums[j])
        result.append(count)
    return result


# --- Next Function Block ---


# 6. Intersection of Two Lists (unique common elements)
def intersection(nums1: list, nums2: list) -> list:
    """
    Returns a list of unique elements common to both nums1 and nums2.
    """
    return list(set(nums1).intersection(set(nums2)))


# --- Next Function Block ---


# 7. Palindrome Check
def is_palindrome(s: str) -> bool:
    """
    Returns True if s is a palindrome.
    """
    return s == s[::-1]


# --- Next Function Block ---


# 8. Interleave Two Strings
def interleave_strings(word1: str, word2: str) -> str:
    """
    Interleaves characters of word1 and word2. If one word is longer,
    appends the remainder at the end.
    """
    result = []
    max_len = max(len(word1), len(word2))
    for i in range(max_len):
        if i < len(word1):
            result.append(word1[i])
        if i < len(word2):
            result.append(word2[i])
    return "".join(result)


# --- Next Function Block ---


# 9. Maximum Sum with Reversed Numbers
def max_sum_with_reversed(nums: list) -> int:
    """
    For each number in nums that has more than one digit, reverse its digits.
    If the reversed number is also in nums, track the maximum sum of the original
    and reversed numbers.
    """
    max_sum = -1
    for num in nums:
        s = str(num)
        if len(s) > 1:
            rev = int(s[::-1])
            if rev in nums:
                max_sum = max(max_sum, num + rev)
    return max_sum


# --- Next Function Block ---


# 10. Alternate Rearrangement of Characters
def alternate_rearrange(s: str) -> str:
    """
    Rearranges characters from s by alternating from a sorted list of unique characters,
    decrementing their frequency until the result's length equals the original.
    (This mimics a complex custom ordering from the provided snippet.)
    """
    freq = {}
    for ch in s:
        freq[ch] = freq.get(ch, 0) + 1
    unique_chars = sorted(set(s))
    result = ""
    i = 0
    reverse = False
    const = False
    while len(result) < len(s) and unique_chars:
        # If the current character is exhausted, remove it.
        if freq[unique_chars[i]] <= 0:
            unique_chars.pop(i)
            if not unique_chars:
                break
            i = len(unique_chars)-1 if reverse else 0
            continue
        result += unique_chars[i]
        freq[unique_chars[i]] -= 1
        # Toggle direction at boundaries.
        if i == 0:
            reverse = False
        elif i == len(unique_chars) - 1:
            reverse = True
        const = True
        if len(unique_chars) <= 1:
            i = 0
        elif reverse:
            i -= 1
        else:
            i += 1
    return result


# --- Next Function Block ---


# 11. Count Pairs with Sum Less Than Target
def count_pairs_with_sum_less_than(nums: list, target: int) -> int:
    """
    Counts the number of unique pairs (i, j) with i < j such that the sum is less than target.
    """
    count = 0
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            if nums[i] + nums[j] < target:
                count += 1
    return count


# --- Next Function Block ---


# 12. Count Pairs with Sum in [lower, upper]
def count_pairs_in_range(nums: list, lower: int, upper: int) -> int:
    """
    Counts the number of unique pairs (i, j) with i < j such that the sum is between lower and upper (inclusive).
    """
    count = 0
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            s = nums[i] + nums[j]
            if lower <= s <= upper:
                count += 1
    return count


# --- Next Function Block ---


# 13. Check First Letters of Words Against a String
def check_first_letters(words: list, s: str) -> bool:
    """
    Checks if the first letter of each word in words matches the corresponding character in s.
    Returns False if lengths differ.
    """
    if len(words) != len(s):
        return False
    for i in range(len(words)):
        if words[i][0] != s[i]:
            return False
    return True


# --- Next Function Block ---


# 14. Count Unique Numbers in Intervals
def count_unique_numbers_in_intervals(intervals: list) -> int:
    """
    Given a list of intervals [start, end], counts the number of unique integers in all intervals.
    """
    unique_nums = set()
    for start, end in intervals:
        unique_nums.update(range(start, end + 1))
    return len(unique_nums)


# --- Next Function Block ---


# 15. Return Length of List
def list_length(lst: list) -> int:
    """
    Returns the length of lst.
    """
    return len(lst)


# --- Next Function Block ---


# 16. Create Target Array in Given Order
def create_target_array(nums: list, index: list) -> list:
    """
    Given two lists, nums and index, inserts each element from nums into a target list at the corresponding index.
    """
    target = []
    for num, idx in zip(nums, index):
        target.insert(idx, num)
    return target


# --- Next Function Block ---


# 17. Common Divisors of Two Numbers
def common_divisors(a: int, b: int) -> list:
    """
    Returns a list of common divisors of a and b.
    """
    c = a if a < b else b
    divisors = []
    for i in range(1, c + 1):
        if a % i == 0 and b % i == 0:
            divisors.append(i)
    return divisors


# --- Next Function Block ---


# 18. ID with Maximum Gap in Logs
def id_of_max_gap(logs: list) -> int:
    """
    Given logs as [id, time] pairs, returns the id corresponding to the maximum gap between times.
    Assumes logs are ordered by time.
    """
    kdiff = 0
    selected_id = 0
    pos = 0
    for log in logs:
        current_id, time = log
        gap = time - pos
        if gap > kdiff:
            kdiff = gap
            selected_id = current_id
        pos = time
    return selected_id


# --- Next Function Block ---


# 19. Print Negative Pairs
def print_negative_pairs(nums: list) -> None:
    """
    For each number in nums, if its negative exists in nums, prints the negative value with a tag.
    """
    nums_sorted = sorted(nums, reverse=True)
    for num in nums_sorted:
        if -num in nums:
            print(-num, "9")


# --- Next Function Block ---


# 20. Power Calculation
def power(x: float, n: int) -> float:
    """
    Returns x raised to the power n.
    """
    return x ** n


# --- Next Function Block ---


# 21. Range Count
def range_count(low: int, high: int) -> int:
    """
    Returns the difference between high and low.
    """
    return high - low


# --- Next Function Block ---


# 22. Average of Salaries
def average_salary(salaries: list) -> float:
    """
    Returns the average of the salaries in the list.
    """
    return sum(salaries) / len(salaries) if salaries else 0


# --- Next Function Block ---


# 23. Rotate Array Right by k
def rotate_right(nums: list, k: int) -> list:
    """
    Rotates the list nums to the right by k positions.
    """
    n = len(nums)
    k = k % n  # Handle cases where k >= n
    return nums[-k:] + nums[:-k]


# --- Next Function Block ---


# 24. Element Equal to Its Frequency
def element_equal_to_frequency(arr: list) -> int:
    """
    Returns the first element whose value equals its frequency in the array.
    If none exists, returns -1.
    """
    freq = {}
    for num in arr:
        freq[num] = freq.get(num, 0) + 1
    for num in arr:
        if num == freq[num]:
            return num
    return -1


# --- Next Function Block ---


# 25. Longest Repeating Character Substring Length
def longest_repeating_substring_length(s: str) -> int:
    """
    Returns the length of the longest substring of s consisting of the same character.
    """
    if not s:
        return 0
    max_len = 1
    current_len = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_len += 1
        else:
            max_len = max(max_len, current_len)
            current_len = 1
    return max(max_len, current_len)


# --- Next Function Block ---


# 26. Get Dictionary Keys
def get_dict_keys(d: dict) -> list:
    """
    Returns a list of keys in dictionary d.
    """
    return list(d.keys())


# --- Next Function Block ---


# 27. Demonstrate Abstract Base Classes
from abc import ABC, abstractmethod
class A(ABC):
    @abstractmethod
    def printf(self):
        pass

class B(A):
    def printf(self):
        print("Hi from B")
    def Scan(self):
        print("Hey")

def test_inheritance():
    """
    Demonstrates inheritance using abstract base classes.
    """
    obj = B()
    obj.printf()
    obj.Scan()


# --- Next Function Block ---


# 28. Custom Fibonacci Variant (starting with [1,2])
def custom_fib(n: int) -> int:
    """
    Returns the nth element in a Fibonacci-like sequence starting with 1 and 2.
    """
    if n == 1:
        return 1
    if n == 2:
        return 2
    seq = [1, 2]
    for i in range(2, n):
        seq.append(seq[-1] + seq[-2])
    return seq[-1]


# --- Next Function Block ---


# 29. Vehicle Class with Destructor
class Vehicle:
    def __init__(self):
        print("Vehicle created.")
    def __del__(self):
        print("Destructor called, vehicle deleted.")
    def display(self):
        print("Hello")

def test_vehicle_class():
    """
    Creates a Vehicle instance, calls display, then deletes it.
    """
    car = Vehicle()
    car.display()
    del car


# --- Next Function Block ---


# 30. Most Frequent Element in a List
def most_frequent_element(nums: list) -> int:
    """
    Returns the element with the highest frequency in nums.
    """
    freq = {}
    max_count = 0
    max_elem = None
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
        if freq[num] > max_count:
            max_count = freq[num]
            max_elem = num
    return max_elem


# --- Next Function Block ---


# 31. Print Duplicates in a List
def print_duplicates(nums: list) -> None:
    """
    Prints elements that appear more than once in the list.
    """
    seen = set()
    duplicates = set()
    for num in nums:
        if num in seen:
            duplicates.add(num)
        else:
            seen.add(num)
    for dup in duplicates:
        print(dup)


# --- Next Function Block ---


# 32. First Duplicate Element (from set comprehension)
def first_duplicate(nums: list):
    """
    Returns the first element that appears more than once in nums.
    If none, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---


# 33. Capitalize First Letter of a String
def capitalize_first_letter(s: str) -> str:
    """
    Capitalizes the first letter of the string s.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---


# 34. Interleave Halves of an Array
def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list nums and an integer n, interleaves the first n elements with the next n elements.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---


# 35. Extract Number from String
def extract_number(s: str) -> int:
    """
    Splits the string s by spaces and returns the last integer found.
    If none found, returns 0.
    """
    num = 0
    for token in s.split():
        try:
            num = int(token)
        except ValueError:
            continue
    return num


# --- Next Function Block ---


# 36. Longest Common Prefix (Brute Force)
def longest_common_prefix_brute(strs: list) -> str:
    """
    Finds the longest common prefix among a list of strings using brute force.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# --- Next Function Block ---


# 37. Remove Duplicates In-place (Sorted Array Variant)
def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---


# 38. Normalize Email Addresses
def normalize_email(email: str) -> str:
    """
    Normalizes an email address by removing dots from the local name and ignoring everything after a '+'.
    """
    local, domain = email.split('@')
    local = local.split('+')[0].replace('.', '')
    return local + '@' + domain


# --- Next Function Block ---


def normalize_emails(emails: list) -> list:
    """
    Normalizes a list of emails.
    """
    return [normalize_email(email) for email in emails]


# --- Next Function Block ---


# 39. Adjust Prices (Subtract first smaller element)
def adjust_prices(prices: list) -> list:
    """
    For each price in the list, if a subsequent price is smaller,
    subtract that price from the current and break.
    """
    adjusted = prices[:]  # make a copy
    for i in range(len(adjusted)-1):
        for j in range(i+1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] = adjusted[i] - adjusted[j]
                break
    return adjusted


# --- Next Function Block ---


# 40. Sum Diagonals of a Matrix
def sum_diagonals(mat: list) -> int:
    """
    Sums the elements on both the main diagonal and the secondary diagonal of a square matrix.
    If the matrix has an odd center, it is counted only once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i]  # primary diagonal
        total += mat[i][n - 1 - i]  # secondary diagonal
    # If n is odd, subtract the center value (counted twice)
    if n % 2 == 1:
        total -= mat[n//2][n//2]
    return total


# --- Next Function Block ---




# patterns.py

def is_diagonal_matrix(grid: list) -> bool:
    """
    Returns True if grid is a square matrix with nonzero entries only on the main diagonal,
    and zeros off the diagonal.
    """
    n = len(grid)
    for i in range(n):
        for j in range(len(grid[i])):
            if i == j:
                if grid[i][j] == 0:
                    return False
            else:
                if grid[i][j] != 0:
                    return False
    return True


# --- Next Function Block ---



def xor_of_sequence(n: int, start: int = 3, step: int = 2) -> int:
    """
    Generates a sequence of n numbers, starting from 'start' and increasing by 'step',
    and returns their bitwise XOR.
    """
    seq = []
    xor_val = 0
    i = start
    while len(seq) < n:
        seq.append(i)
        xor_val ^= i
        i += step
    return xor_val


# --- Next Function Block ---



def count_elements_geq(arr: list, target) -> int:
    """
    Counts the number of elements in arr that are greater than or equal to target.
    """
    count = 0
    for elem in arr:
        if elem >= target:
            count += 1
    return count


# --- Next Function Block ---



def max_account_value(accounts: list) -> int:
    """
    Given a list of accounts (each account is a list of numbers), returns the maximum total (row sum).
    """
    max_val = 0
    for acc in accounts:
        total = sum(acc)
        if total > max_val:
            max_val = total
    return max_val


# --- Next Function Block ---



def count_equal_pairs(nums: list) -> int:
    """
    Counts the number of pairs (i, j) with i < j such that nums[i] == nums[j].
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if nums[i] == nums[j]:
                count += 1
    return count


# --- Next Function Block ---



def duplicate_list(nums: list) -> list:
    """
    Returns a new list by appending a copy of nums to itself.
    """
    return nums + nums


# --- Next Function Block ---



def final_value_after_operations(operations: list) -> int:
    """
    Given a list of operations (strings "++X" or "X++"), returns the final value of x.
    """
    x = 0
    for op in operations:
        if op in ["++X", "X++"]:
            x += 1
        else:
            x -= 1
    return x


# --- Next Function Block ---



def kids_with_greatest_candies(candies: list, extraCandies: int) -> list:
    """
    Returns a list of booleans indicating whether each kid can have the greatest number of candies
    after receiving extraCandies.
    """
    max_candies = max(candies)
    result = []
    for c in candies:
        result.append(c + extraCandies >= max_candies)
    return result


# --- Next Function Block ---



def running_sum(nums: list) -> list:
    """
    Returns a list where each element at index i is the sum of nums[0:i+1].
    """
    total = 0
    result = []
    for num in nums:
        total += num
        result.append(total)
    return result


# --- Next Function Block ---



def sentence_with_most_words(sentences: list) -> list:
    """
    Returns the list of words of the sentence that has the maximum word count.
    """
    max_words = []
    for sentence in sentences:
        words = sentence.split()
        if len(words) > len(max_words):
            max_words = words
    return max_words


# --- Next Function Block ---



def prefix_difference(nums: list) -> list:
    """
    Computes two prefix sum arrays:
      - left prefix sum from the start,
      - right prefix sum from the end,
    then returns a list of absolute differences between the left prefix at index i
    and the corresponding right prefix from the opposite end.
    """
    n = len(nums)
    left = [0] * n
    right = [0] * n
    s_left = 0
    s_right = 0
    for i in range(n):
        left[i] = s_left
        s_left += nums[i]
        right[i] = s_right
        s_right += nums[n - 1 - i]
    diff = []
    for i in range(n):
        diff.append(abs(left[i] - right[n - 1 - i]))
    return diff


# --- Next Function Block ---



def print_custom_pattern(n: int) -> None:
    """
    Prints a custom pattern based on a grid of size (n*n).
    (Note: The pattern logic is derived from the given code and may be adjusted as needed.)
    """
    total = n * n
    for i in range(total):
        for j in range(total):
            # This condition is based on the provided snippet; adjust as needed.
            if (i == 0 and j == total // 2) or \
               (i > 0 and (total / 2) - 2 < j < (total / 2) + 1) or \
               (i > (total / 2) - 2 and 1 < j < 5) or \
               (i > (total / 2) - 2 and 5 < j < 9) or \
               (i > (total / 2) - 2 and total - 6 < j < total - 2) or \
               (i > (total / 2) - 2 and total - 10 < j < total - 6) or \
               (i >= total // 2) or \
               (i == 12 and 0 < j < total - 1):
                print("*", end=" ")
            else:
                print("  ", end=" ")
        print()


# --- Next Function Block ---



def convert_date(date: str) -> str:
    """
    Converts a date from format "20th Oct 2052" to "2052-10-20".
    Assumes day part may contain ordinal suffixes.
    """
    month_map = {
        "Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04",
        "May": "05", "Jun": "06", "Jul": "07", "Aug": "08",
        "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"
    }
    parts = date.split()
    day_part = parts[0]
    # Remove non-digit characters
    day = "".join(filter(str.isdigit, day_part))
    if len(day) == 1:
        day = "0" + day
    month = month_map[parts[1]]
    year = parts[2]
    return f"{year}-{month}-{day}"


# --- Next Function Block ---



def count_odds(low: int, high: int) -> int:
    """
    Counts the number of odd numbers in the inclusive range [low, high].
    """
    count = 0
    for i in range(low, high + 1):
        if i % 2 != 0:
            count += 1
    return count


# --- Next Function Block ---



def rearrange_string(s: str, indices: list) -> str:
    """
    Rearranges characters in s according to indices.
    """
    mapping = {index: char for index, char in zip(indices, s)}
    sorted_mapping = dict(sorted(mapping.items()))
    result = "".join(sorted_mapping[i] for i in sorted_mapping)
    return result


# --- Next Function Block ---



def repeat_alternate(nums: list) -> list:
    """
    For even-indexed elements in nums, repeats the element at index i+1 a number of times equal to nums[i].
    Example: For nums = [1,2,3,4], returns [2] repeated 1 time and [4] repeated 3 times => [2,4,4,4].
    """
    result = []
    for i in range(0, len(nums), 2):
        if i + 1 < len(nums):
            result.extend([nums[i+1]] * nums[i])
    return result


# --- Next Function Block ---



def first_k_words(s: str, k: int) -> str:
    """
    Returns the first k words from the string s.
    """
    words = s.split()
    return " ".join(words[:k])


# --- Next Function Block ---



def compare_word_lists(word1: list, word2: list) -> bool:
    """
    Concatenates the elements of both lists (word by word) and compares the resulting strings.
    Returns True if they are equal.
    """
    stg1 = "".join(word1)
    stg2 = "".join(word2)
    return stg1 == stg2


# --- Next Function Block ---



def sum_minus_digit_sum(nums: list) -> int:
    """
    For a list of numbers, returns the difference between the sum of the numbers and
    the sum of all their digits.
    """
    total = sum(nums)
    digit_sum = 0
    for num in nums:
        for ch in str(num):
            digit_sum += int(ch)
    return total - digit_sum


# --- Next Function Block ---



def count_pairs_with_difference(nums: list, k: int) -> int:
    """
    Counts the number of pairs (i, j) with i < j such that the absolute difference is k.
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if abs(nums[i] - nums[j]) == k:
                count += 1
    return count


# --- Next Function Block ---



def count_special_pairs(nums: list, k: int) -> int:
    """
    Counts the number of pairs (i, j) with i < j such that nums[i] == nums[j]
    and (i * j) % k == 0.
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if nums[i] == nums[j] and (i * j) % k == 0:
                count += 1
    return count


# --- Next Function Block ---



def format_number_with_dots(n: int) -> str:
    """
    Formats a number with dots as thousand separators.
    Example: 1234567 -> "1.234.567"
    """
    s = str(n)
    result = ""
    count = 0
    # Process digits from right to left.
    for ch in s[::-1]:
        if count == 3:
            result = "." + result
            count = 0
        result = ch + result
        count += 1
    return result


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the count of words that consist solely of characters in allowed.
    """
    count = 0
    for word in words:
        valid = True
        for ch in word:
            if ch not in allowed:
                valid = False
                break
        if valid:
            count += 1
    return count


# --- Next Function Block ---



def sum_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Inserts "[.]" between each segment of an IP address.
    Example: "1.1.1.1" -> "1[.]1[.]1[.]1"
    """
    parts = address.split(".")
    return "[.]".join(parts)


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Counts how many characters in stones are also in jewels.
    """
    count = 0
    for ch in stones:
        if ch in jewels:
            count += 1
    return count


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string based on the following rules:
    "G" -> "G"
    "()" -> "o"
    "(al)" -> "al"
    Example: "G()(al)" -> "Goal"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims extra spaces and redistributes spaces evenly between words.
    (A simple approach; may not cover all edge cases.)
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    # Minimum spaces between words:
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            # Distribute extra spaces to the left
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Brute-force approach to the container with most water problem.
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters that appear exactly once in s.
    If all characters are unique, returns -1.
    """
    freq = {}
    for ch in s:
        freq[ch] = freq.get(ch, 0) + 1
    unique_chars = [ch for ch, count in freq.items() if count == 1]
    if len(unique_chars) == len(s):
        return -1
    return len(unique_chars)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For characters that repeat in s, returns the maximum gap (distance - 1)
    between two occurrences. If none repeat, returns -1.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element found in nums.
    If no duplicate exists, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Capitalizes the first letter of the string.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list nums and an integer n, interleaves the first n elements with the next n elements.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Splits the string by spaces and returns the last integer found (if any).
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among the list of strings.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes email addresses by removing dots in the local part (before '+')
    and ignoring any characters after '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price, subtracts the first subsequent smaller price (if found) and stops.
    """
    adjusted = prices[:]  # copy list
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the primary and secondary diagonal of a square matrix.
    For an odd-length matrix, the center element is counted only once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---





def count_elements_based_on_min_freq(nums: list) -> int:
    """
    Sorts the list and builds a frequency dictionary.
    Finds the number (key) with the lowest frequency and then counts how many elements in the sorted list are 
    greater than or equal to that number.
    """
    nums_sorted = sorted(nums)
    freq = {}
    for num in nums_sorted:
        freq[num] = freq.get(num, 0) + 1
    sorted_freq = sorted(freq.items(), key=lambda x: x[1])
    min_elem, _ = sorted_freq[0]
    total = sum(1 for num in nums_sorted if num >= min_elem)
    return total


# --- Next Function Block ---



def print_pattern_1(n: int) -> None:
    """
    Prints a pattern based on a condition:
    For each row i (1-indexed) and each column j (0-indexed) in a grid of width n, prints a star (*) or space.
    The condition is:
      - if (j < i and i <= 3) or (i > 3 and j <= n - i): print a space
      - else: print a star.
    """
    for i in range(1, n + 1):
        for j in range(n):
            if (j < i and i <= 3) or (i > 3 and j <= n - i):
                print(" ", end="  ")
            else:
                print("*", end="  ")
        print()


# --- Next Function Block ---



def print_pattern_2(n: int) -> None:
    """
    Prints a pattern on an n*n grid.
    For each cell (i, j) where 0 <= i, j < n*n, prints a star if j < 13 - i*i or j > 11 + i*i; otherwise prints spaces.
    (The condition is taken from the snippet; adjust as needed.)
    """
    total = n * n
    for i in range(total):
        for j in range(total):
            if j < 13 - i * i or j > 11 + i * i:
                print("*", end=" ")
            else:
                print("  ", end="")
        print()


# --- Next Function Block ---



def reconstruct_from_pieces(arr: list, pieces: list) -> (bool, list):
    """
    Tries to reconstruct the array by selecting unique pieces from 'pieces' that appear in 'arr'.
    Flattens the collected pieces and compares the result with arr.
    Returns a tuple (is_equal, reconstructed_array).
    """
    collected = []
    used = []
    for piece in pieces:
        if piece not in used and any(num in arr for num in piece):
            used.append(piece)
            collected.extend(piece)
    return (collected == arr, collected)


# --- Next Function Block ---



def is_arithmetic_progression(arr: list) -> bool:
    """
    Checks if the sorted array forms an arithmetic progression.
    """
    arr = sorted(arr)
    if len(arr) < 2:
        return True
    diff = arr[1] - arr[0]
    for i in range(1, len(arr) - 1):
        if arr[i + 1] - arr[i] != diff:
            return False
    return True


# --- Next Function Block ---



def check_progressions(*arrays) -> list:
    """
    For each array provided, returns True if it forms an arithmetic progression (when sorted), otherwise False.
    """
    results = []
    for arr in arrays:
        results.append(is_arithmetic_progression(arr))
    return results


# --- Next Function Block ---



def count_word_occurrences(sequence: str, word: str) -> int:
    """
    Returns the number of non-overlapping occurrences of word in sequence.
    """
    return sequence.count(word)


# --- Next Function Block ---



def count_word_occurrences_replace(sequence: str, word: str) -> int:
    """
    Uses string replacement to calculate the number of times word appears in sequence.
    """
    reduced = sequence.replace(word, "")
    return (len(sequence) - len(reduced)) // len(word)


# --- Next Function Block ---



def compute_subtractions(n: int) -> int:
    """
    Repeatedly subtracts floor(i/2) from i until i <= 1, summing all subtractions.
    """
    count = 0
    i = n
    while i > 1:
        sub = i // 2
        i = i - sub
        count += sub
    return count


# --- Next Function Block ---



def convert_zigzag(s: str, numRows: int) -> str:
    """
    Attempts to create a zigzag conversion of s for numRows.
    (Note: This implementation follows the provided snippet's structure and may differ from the standard solution.)
    """
    if numRows == 1 or numRows >= len(s):
        return s
    result = ""
    i = 0
    diff = numRows
    while len(result) < len(s):
        if i >= len(s):
            i -= len(s)
            if i % 2 == 0:
                diff = 2
                i = 1
            else:
                diff = numRows
        result += s[i]
        i += diff
    return result


# --- Next Function Block ---



def equal_vowel_halves(s: str) -> bool:
    """
    Splits string s into two halves and returns True if both halves have the same count of vowels.
    """
    vowels = set('aeiouAEIOU')
    half = len(s) // 2
    first_half = s[:half]
    second_half = s[half:]
    return sum(1 for ch in first_half if ch in vowels) == sum(1 for ch in second_half if ch in vowels)


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Given a list of vote strings, returns the vote with the highest frequency.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each i from 0 to len(s)-1, creates a pattern of 'R' repeated i times followed by 'L' repeated i times.
    Counts the total occurrences of these patterns in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    Given a list of items (each item is a list) and a ruleKey ("type", "color", or other),
    selects the element at the corresponding position (0 for "type", 1 for "color", 2 otherwise)
    and counts how many items have ruleValue at that position.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints the grid row by row.
    """
    for row in grid:
        for elem in row:
            print(elem, end=" ")
        print()


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of numbers that appear only once in the list.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times, adding (count+pos) to the sum.
    Resets count to 0 and increments pos when count reaches 7.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Returns a new list where each element is replaced by the element at the index equal to its value.
    """
    result = []
    for i in range(len(nums)):
        result.append(nums[nums[i]])
    return result


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Computes the difference between the sum of numbers in [1, n] not divisible by m and the sum of numbers divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (for i from 1 to 31) that exists in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers: 2, 4, 6, ... up to limit*2.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor of the minimum and maximum of the list.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts to reorder a list based on a nested loop strategy and checks if the
    resulting list equals the sorted version of the original list.
    (Logic follows the provided snippet; behavior may be non-standard.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 in str1 and returns the result.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx + len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Returns the sum of the minimum value of each row in a triangle (list of lists).
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of 'digit' from 'number' and returns a tuple with the resulting string and 
    a list of indices where the digit was found.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if all elements in nums have unique frequencies.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum count between occurrences of '1' and '0' in s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Determines if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Compares the string s against two alternating patterns ("0101..." and "1010...")
    and returns the minimum number of mismatches.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Iterates over the string s and when consecutive duplicate characters are found,
    flips the second one ("0" becomes "1" and vice versa) and counts the flips.
    Returns the modified string and the count of flips.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i + 1]:
            count += 1
            s_list[i + 1] = "1" if s_list[i + 1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the vote (string) with the highest frequency from the list.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each possible i, builds a pattern with i 'R's followed by i 'L's,
    and counts how many times each such pattern appears in s.
    Returns the total count.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    For each item in items (a list of lists), checks the element at a position determined by ruleKey 
    ("type" → index 0, "color" → index 1, otherwise index 2) and counts items that equal ruleValue.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints each element of a 2D grid.
    """
    for row in grid:
        for val in row:
            print(val, end=" ")
        print()


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of numbers that appear exactly once in the list.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times while updating two counters (count and pos) and returns the sum of (count+pos) over the iterations.
    Resets count to 0 and increments pos when count reaches 7.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Creates a new list where each element is replaced by the element at the index equal to its value.
    """
    return [nums[nums[i]] for i in range(len(nums))]


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Sums numbers from 1 to n that are not divisible by m and subtracts the sum of numbers that are divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (for i in range(1, 32)) that exists in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers from 2 to 2*limit.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor of the minimum and maximum values in the list.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts a reordering of the list based on the provided snippet.
    Returns True if the concatenation of the modified sublists equals the sorted original list.
    (Note: The original logic is unclear.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 in str1 and returns the modified string.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx+len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Sums the minimum element of each row in a triangle.
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of a digit from a number (given as a string).
    Returns the resulting string and a list of indices where removals occurred.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if all numbers in nums have unique frequencies.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum between the count of '1's and '0's in the string s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Returns True if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Computes the number of mismatches between s and two alternating patterns ("0101..." and "1010...").
    Returns the smaller mismatch count.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Flips the second of any two consecutive identical characters ("0" becomes "1", "1" becomes "0").
    Returns the resulting string and the count of flips.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i + 1]:
            count += 1
            s_list[i + 1] = "1" if s_list[i + 1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the vote (string) with the highest frequency.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each possible repetition count i, builds a pattern of i 'R's followed by i 'L's,
    and sums up how many times these patterns appear in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    For a list of items (each item is a list) and a ruleKey ("type", "color", or other),
    selects the element at index 0 for "type", index 1 for "color", and index 2 otherwise,
    then counts how many items have that element equal to ruleValue.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints the elements of a 2D grid.
    """
    for row in grid:
        print(" ".join(str(x) for x in row))


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of the numbers that appear exactly once in the list.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times, updating a counter and position.
    Adds (count + pos) on each iteration; resets count after 7 iterations and increments pos.
    Returns the total sum.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Constructs a new list where each element at index i is replaced by nums[nums[i]].
    """
    return [nums[nums[i]] for i in range(len(nums))]


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Returns the difference between the sum of numbers 1 to n that are not divisible by m and the sum of those divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (for i in 1..31) found in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers from 2 to 2*limit.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor (GCD) of the minimum and maximum of nums.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts a reordering (as in the provided snippet) and returns True if the concatenation
    of modified segments equals the sorted version of the original list.
    (The logic is based on the snippet and may be non-standard.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 in str1 and returns the resulting string.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx + len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Returns the sum of the minimum elements of each row in a triangle (list of lists).
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of the specified digit from the number (as a string).
    Returns a tuple of the new string and a list of indices where the digit was found.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if the frequency of each number in nums is unique.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum count between occurrences of '1' and '0' in the string s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Returns True if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Computes the number of mismatches between s and two alternating patterns ("0101..." and "1010...").
    Returns the smaller mismatch count.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Iterates over the string s and, when two consecutive identical characters are found,
    flips the second character ("0" becomes "1" and vice versa). Returns the modified string and the count of flips.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i + 1]:
            count += 1
            s_list[i + 1] = "1" if s_list[i + 1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the candidate (vote) with the highest number of votes.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each possible repetition count i, builds a pattern of 'R'*i + 'L'*i,
    and returns the total number of occurrences of such patterns in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    Counts how many items in a list of lists have the value ruleValue at a specific index:
      - 0 for ruleKey "type"
      - 1 for ruleKey "color"
      - 2 otherwise.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of numbers in the list that appear exactly once.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times, updating counters 'count' and 'pos'. Adds (count+pos) to the sum,
    resets count to 0 and increments pos after 7 iterations. Returns the final sum.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Creates a new list by mapping each index i to the element at index nums[i].
    """
    return [nums[nums[i]] for i in range(len(nums))]


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Computes the difference between the sum of numbers 1 to n that are not divisible by m
    and the sum of numbers that are divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (i * n for some i in 1..31) that is present in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers from 2 to 2*limit.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor (GCD) of the minimum and maximum values in nums.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts a reordering based on the provided logic and returns True if the concatenation of 
    modified segments equals the sorted original list.
    (The logic is directly derived from the snippet and might be non-standard.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 in str1 and returns the result.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx + len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Returns the sum of the minimum elements from each row of a triangle (list of lists).
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of the given digit from the string 'number'.
    Returns a tuple with the new string and the list of indices where the digit was found.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if each number in nums has a unique frequency.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum count between the number of '1's and '0's in s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Returns True if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Compares s against two alternating patterns ("0101..." and "1010...") and returns the minimum mismatch count.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Flips the second character in any pair of consecutive identical characters ("0" <-> "1")
    and returns the modified string along with the count of flips.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i + 1]:
            count += 1
            s_list[i + 1] = "1" if s_list[i + 1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the candidate with the highest vote count.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each possible i (0 <= i < len(s)), builds a pattern of i 'R's followed by i 'L's and sums
    the occurrences of these patterns in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    Counts how many items (each a list) have ruleValue at a position determined by ruleKey:
      - 0 for "type"
      - 1 for "color"
      - 2 otherwise.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints a 2D grid.
    """
    for row in grid:
        print(" ".join(str(x) for x in row))


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of numbers in nums that appear exactly once.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times, updating two counters (count and pos), adding (count+pos) each time.
    Resets count after 7 iterations and increments pos. Returns the total sum.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Returns a new list where each element is replaced by the element at index equal to its value.
    """
    return [nums[nums[i]] for i in range(len(nums))]


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Computes the difference between the sum of numbers from 1 to n that are not divisible by m 
    and the sum of numbers that are divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (for i in 1..31) that is present in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers from 2 to 2*limit.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor of the minimum and maximum values in nums.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts a reordering based on a nested deletion loop and returns True if the concatenation 
    of the removed elements and the remaining list equals the sorted original list.
    (Logic is directly based on the snippet and may be non-standard.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 from str1 and returns the resulting string.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx+len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Returns the sum of the minimum element from each row of a triangle.
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of a given digit from the number (as a string).
    Returns a tuple containing the new string and a list of indices where the digit was removed.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if all numbers in nums have unique frequencies.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum count between occurrences of '1' and '0' in s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Returns True if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Computes the mismatch count between s and two alternating patterns ("0101..." and "1010...")
    and returns the minimum of the two counts.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Iterates over s and flips the second character of any adjacent duplicate pair
    (switching '0' to '1' and vice versa). Returns the modified string and the flip count.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i+1]:
            count += 1
            s_list[i+1] = "1" if s_list[i+1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the candidate with the highest vote count from the list.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each i (from 0 to len(s)-1), creates a pattern of 'R'*i followed by 'L'*i,
    and sums the number of times such patterns occur in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    For a list of items (each a list), returns the count of items where the element at position 
    (0 for "type", 1 for "color", 2 otherwise) equals ruleValue.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def sum_of_prefix_differences(nums: list) -> list:
    """
    Computes two prefix sum arrays (left from the start and right from the end) and returns 
    a list of absolute differences between corresponding elements.
    """
    n = len(nums)
    left = [0] * n
    right = [0] * n
    s_left, s_right = 0, 0
    for i in range(n):
        left[i] = s_left
        s_left += nums[i]
        right[i] = s_right
        s_right += nums[n - 1 - i]
    return [abs(left[i] - right[n - 1 - i]) for i in range(n)]


# --- Next Function Block ---



def print_custom_pattern(n: int) -> None:
    """
    Prints a pattern on an n*n grid.
    The pattern logic follows the snippet condition: if j < 13 - i*i or j > 11 + i*i, print "*"; else print spaces.
    """
    total = n * n
    for i in range(total):
        for j in range(total):
            if j < 13 - i * i or j > 11 + i * i:
                print("*", end=" ")
            else:
                print("  ", end="")
        print()


# --- Next Function Block ---



def convert_date(date: str) -> str:
    """
    Converts a date from a format like "20th Oct 2052" to "2052-10-20".
    Assumes the day part may have ordinal suffixes.
    """
    month_map = {"Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04",
                 "May": "05", "Jun": "06", "Jul": "07", "Aug": "08",
                 "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"}
    parts = date.split()
    day = "".join(filter(str.isdigit, parts[0]))
    if len(day) == 1:
        day = "0" + day
    month = month_map[parts[1]]
    year = parts[2]
    return f"{year}-{month}-{day}"


# --- Next Function Block ---



def count_odds_in_range(low: int, high: int) -> int:
    """
    Returns the count of odd numbers in the inclusive range [low, high].
    """
    return sum(1 for i in range(low, high + 1) if i % 2 != 0)


# --- Next Function Block ---



def rearrange_string(s: str, indices: list) -> str:
    """
    Rearranges the characters in s according to the provided indices.
    """
    mapping = {idx: ch for idx, ch in zip(indices, s)}
    sorted_mapping = dict(sorted(mapping.items()))
    return "".join(sorted_mapping[i] for i in sorted_mapping)


# --- Next Function Block ---



def repeat_alternate(nums: list) -> list:
    """
    For every even-indexed element in nums, repeats the element at index i+1 a number of times equal to nums[i].
    Returns the resulting list.
    Example: for nums = [1,2,3,4], returns [2,4,4,4].
    """
    result = []
    for i in range(0, len(nums), 2):
        if i + 1 < len(nums):
            result.extend([nums[i+1]] * nums[i])
    return result


# --- Next Function Block ---



def first_k_words(s: str, k: int) -> str:
    """
    Returns the first k words from the string s.
    """
    words = s.split()
    return " ".join(words[:k])


# --- Next Function Block ---



def compare_word_lists(word1: list, word2: list) -> bool:
    """
    Concatenates the lists of strings and returns True if the resulting strings are equal.
    """
    return "".join(word1) == "".join(word2)


# --- Next Function Block ---



def sum_minus_digit_sum(nums: list) -> int:
    """
    Returns the difference between the sum of numbers in nums and the sum of all their digits.
    """
    total = sum(nums)
    digit_sum = sum(int(ch) for num in nums for ch in str(num))
    return total - digit_sum


# --- Next Function Block ---



def count_pairs_with_difference(nums: list, k: int) -> int:
    """
    Counts unique pairs (i, j) with i < j in nums such that abs(nums[i] - nums[j]) == k.
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if abs(nums[i] - nums[j]) == k:
                count += 1
    return count


# --- Next Function Block ---



def count_special_pairs(nums: list, k: int) -> int:
    """
    Counts pairs (i, j) with i < j where nums[i] equals nums[j] and (i*j) % k == 0.
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if nums[i] == nums[j] and (i * j) % k == 0:
                count += 1
    return count


# --- Next Function Block ---



def format_number_with_dots(n: int) -> str:
    """
    Formats the integer n by inserting dots as thousand separators.
    Example: 1234567 -> "1.234.567"
    """
    s = str(n)
    result = ""
    count = 0
    for ch in s[::-1]:
        if count == 3:
            result = "." + result
            count = 0
        result = ch + result
        count += 1
    return result


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the count of words in the list that contain only characters from allowed.
    """
    count = 0
    for word in words:
        if all(ch in allowed for ch in word):
            count += 1
    return count


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Formats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are also in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string: "G" remains, "()" becomes "o", and "(al)" becomes "al".
    Example: "G()(al)" -> "Goal"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims the text and redistributes spaces evenly between words.
    (A simple implementation that may not cover all edge cases.)
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area for the container with most water problem (brute force approach).
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For characters that repeat in s, returns the maximum gap (distance minus one)
    between two occurrences. If none repeat, returns -1.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps)


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums; if none exist, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Capitalizes the first letter of the string.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list 'nums' of length 2*n, interleaves the first n elements with the next n elements.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Splits s by spaces and returns the last integer found, or 0 if none.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Finds the longest common prefix among the list of strings using a brute-force approach.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes a list of emails by removing dots and ignoring characters after '+' in the local part.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price in the list, finds the first subsequent smaller price and subtracts it from the current price.
    Returns the modified list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the primary and secondary diagonal of a square matrix.
    If the matrix has an odd center, that value is subtracted once (since it was counted twice).
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the count of words in the list that contain only characters from allowed.
    """
    count = 0
    for word in words:
        if all(ch in allowed for ch in word):
            count += 1
    return count


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the number of characters in stones that are present in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string:
      "G" remains "G",
      "()" becomes "o",
      "(al)" becomes "al".
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels (starting from 'A').
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims the text and redistributes spaces evenly between words.
    (A simple approach; edge cases may vary.)
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area that can be formed by two lines in the list 'height'.
    (Brute-force O(n^2) approach.)
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For each character that repeats in s, computes the gap (difference in indices minus one)
    between its first and last occurrence. Returns the maximum such gap; if no repeats, returns -1.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums.
    If there are no duplicates, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Returns s with its first letter capitalized.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first half with the second half.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Returns the last integer found in s when splitting by spaces.
    If no integer is found, returns 0.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among the list of strings using a brute-force approach.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates in-place from a sorted list and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes emails by removing dots from the local part and ignoring everything after a '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price in prices, finds the first subsequent smaller price and subtracts it from the current price.
    Returns the adjusted list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the main and secondary diagonals of a square matrix.
    For odd-sized matrices, the center element is subtracted once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the number of words that consist solely of characters in allowed.
    """
    count = 0
    for word in words:
        if all(ch in allowed for ch in word):
            count += 1
    return count


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing each '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the number of characters in stones that are also in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string:
      - "G" -> "G"
      - "()" -> "o"
      - "(al)" -> "al"
    Example: "G()(al)" -> "Goal"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels (starting from 'A').
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims extra spaces from the text and redistributes spaces evenly between words.
    (Simple implementation.)
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area that can be formed by two indices in height (brute-force approach).
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For characters that repeat in s, returns the maximum gap (index difference minus one)
    between two occurrences. Returns -1 if no character repeats.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums, or None if there is none.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Returns the string s with its first letter capitalized.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first n elements with the last n elements.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Splits s by spaces and returns the last integer found, or 0 if none.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Finds the longest common prefix among the given list of strings.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes emails by removing dots in the local part and ignoring characters after '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price, finds the first subsequent smaller price and subtracts it from the current price.
    Returns the adjusted list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the main and secondary diagonals of a square matrix.
    If the matrix has an odd center, subtracts the center value once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the count of words that consist solely of characters in allowed.
    """
    return sum(1 for word in words if all(ch in allowed for ch in word))


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all odd-length subarrays of arr.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are also in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Interprets the command string:
      - "G" becomes "G"
      - "()" becomes "o"
      - "(al)" becomes "al"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims and redistributes spaces evenly between words in the text.
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum container area using a brute-force approach.
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters that appear exactly once in s.
    If all characters are unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For characters that repeat in s, returns the maximum gap (difference in indices minus one).
    Returns -1 if no character repeats.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums; returns None if there are no duplicates.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Returns the string s with its first letter capitalized.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first half with the second half.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Returns the last integer found in s when splitting by spaces, or 0 if none.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among the given strings using a brute-force method.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates in-place from a sorted list and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes email addresses by removing dots in the local part (before '+')
    and ignoring any characters after '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price in prices, subtracts the first subsequent smaller price (if found) and returns the modified list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of both the primary and secondary diagonals of a square matrix.
    If the matrix has an odd dimension, subtracts the center element once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the number of words that contain only characters found in allowed.
    """
    return sum(1 for word in words if all(ch in allowed for ch in word))


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing each '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the number of characters in stones that are also in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Interprets a command string:
      - "G" remains "G"
      - "()" becomes "o"
      - "(al)" becomes "al"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims the text and evenly redistributes spaces between words.
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area that can be formed between two lines in the list 'height'.
    (Brute-force approach.)
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    Returns the maximum gap (difference in indices minus one) between any two occurrences 
    of the same character in s. Returns -1 if no repeats exist.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element found in nums. Returns None if there is no duplicate.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Returns s with its first character capitalized.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first half with the second half.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Splits s by spaces and returns the last integer found; returns 0 if none is found.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among a list of strings using a brute-force approach.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates in-place from a sorted list and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes a list of emails by removing dots ('.') from the local part and ignoring everything after a '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price, finds the first subsequent smaller price and subtracts it from the current price.
    Returns the adjusted list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the primary and secondary diagonals of a square matrix.
    For odd dimensions, the center element is subtracted once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n//2][n//2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the number of words that consist only of characters in allowed.
    """
    return sum(1 for word in words if all(ch in allowed for ch in word))


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are also present in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string by mapping:
      "G" -> "G"
      "()" -> "o"
      "(al)" -> "al"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims extra spaces from text and evenly redistributes them between words.
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area that can be contained between two lines in the list height.
    (Brute-force approach.)
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For each character that repeats in s, returns the maximum gap (index difference minus one)
    between any two occurrences. If no character repeats, returns -1.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums, or None if no duplicate exists.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Capitalizes the first letter of s.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first half with the second half.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Returns the last integer found in s after splitting by spaces; returns 0 if none.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among a list of strings.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes emails by removing '.' from the local part and ignoring characters after '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price in prices, subtracts the first subsequent smaller price (if any) from it.
    Returns the adjusted list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the primary and secondary diagonals of a square matrix.
    If the matrix size is odd, the center element is counted only once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the number of words composed solely of characters in allowed.
    """
    return sum(1 for word in words if all(ch in allowed for ch in word))


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all odd-length subarrays of arr.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string by mapping:
      "G" -> "G",
      "()" -> "o",
      "(al)" -> "al".
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims the text and redistributes spaces evenly between words.
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return re


# --- Next Function Block ---


# patterns.py

def count_elements_geq_lowest_freq(nums: list) -> int:
    """
    Sorts the list, builds a frequency dictionary, then finds the smallest frequency entry.
    Returns the count of numbers in nums that are greater than or equal to the key
    of the lowest-frequency element.
    Example:
      nums = [3,9,7,8,3,8,6,6]
      Sorted nums: [3,3,6,6,7,8,8,9]
      Frequency: {3:2, 6:2, 7:1, 8:2, 9:1}
      Lowest frequency entry: (7,1)
      Count numbers >= 7 → 7,8,8,9 → 4
    """
    nums.sort()
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    # Get the (number, count) pair with the minimum count
    low = sorted(freq.items(), key=lambda x: x[1])[0]
    total = sum(1 for num in nums if num >= low[0])
    return total


# --- Next Function Block ---



def print_pattern_1(n: int) -> None:
    """
    Prints a pattern for n rows.
    (Based on the snippet with two nested loops and conditional spacing.)
    """
    for i in range(1, n + 1):
        for j in range(n):
            # Example condition: for i <= 3, print spaces for j < i; for i > 3, print spaces for j <= n-i.
            if (j < i and i <= 3) or (i > 3 and j <= n - i):
                print(" ", end="  ")
            else:
                print("*", end="  ")
        print("\n", end="")


# --- Next Function Block ---



def print_pattern_2(n: int) -> None:
    """
    Prints a second pattern based on an n*n grid.
    (The conditions are taken from the provided snippet.)
    """
    total = n * n
    for i in range(total):
        for j in range(total):
            # The condition is taken as provided; adjust if needed.
            if j < 13 - i * i or j > 11 + i * i:
                print("*", end=" ")
            else:
                print("  ", end="")
        print("\n", end="")


# --- Next Function Block ---



def convert_date(date: str) -> str:
    """
    Converts a date string like "20th Oct 2052" to the format "2052-10-20".
    """
    month_map = {
        "Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04",
        "May": "05", "Jun": "06", "Jul": "07", "Aug": "08",
        "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"
    }
    parts = date.split(" ")
    # Remove non-digit characters from the day part.
    day = "".join(ch for ch in parts[0] if ch.isdigit())
    if len(day) == 1:
        day = "0" + day
    month = month_map[parts[1]]
    year = parts[2]
    return f"{year}-{month}-{day}"


# --- Next Function Block ---



def count_odds_in_range(low: int, high: int) -> int:
    """
    Counts the number of odd numbers in the inclusive range [low, high].
    """
    count = 0
    for i in range(low, high + 1):
        if i % 2 != 0:
            count += 1
    return count


# --- Next Function Block ---



def reorder_string(s: str, indices: list) -> str:
    """
    Reorders string s based on the list of indices.
    Example:
       s = "codeleet", indices = [4,5,6,7,0,2,1,3] → returns "leetcode"
    """
    mapping = {idx: ch for idx, ch in zip(indices, s)}
    # Sort by index and join the characters.
    result = "".join(mapping[i] for i in sorted(mapping))
    return result


# --- Next Function Block ---



def running_sum(nums: list) -> list:
    """
    Returns a list of the running (cumulative) sum of nums.
    """
    total = 0
    result = []
    for num in nums:
        total += num
        result.append(total)
    return result


# --- Next Function Block ---



def sentence_with_most_words(sentences: list) -> list:
    """
    Splits each sentence into words and returns the word list for the sentence with the most words.
    """
    max_words = []
    for sentence in sentences:
        words = sentence.split()
        if len(words) > len(max_words):
            max_words = words
    return max_words


# --- Next Function Block ---



def prefix_diff(nums: list) -> list:
    """
    Computes two arrays:
      - left prefix sums (excluding current index)
      - right prefix sums (from the end)
    Returns a list of absolute differences between left prefix at index i and the reversed right prefix.
    """
    n = len(nums)
    left = []
    right = []
    s_left = 0
    s_right = 0
    for i in range(n):
        left.append(s_left)
        s_left += nums[i]
        right.append(s_right)
        s_right += nums[n - 1 - i]
    diff = []
    for i in range(n):
        diff.append(abs(left[i] - right[n - 1 - i]))
    return diff


# --- Next Function Block ---



def count_frequency_and_elements(nums: list) -> int:
    """
    Builds a frequency dictionary for nums, then finds the entry with the lowest frequency.
    Counts and prints indices and values for numbers in nums that are greater than or equal to the key
    of that lowest-frequency entry. Returns the total count.
    """
    nums.sort()
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    # Get the (number, count) pair with the minimum frequency.
    low = sorted(freq.items(), key=lambda x: x[1])[0]
    total = 0
    for i, num in enumerate(nums):
        if num >= low[0]:
            total += 1
            print(i, num)
    return total


# --- Next Function Block ---



def validate_pieces(arr: list, pieces: list) -> bool:
    """
    Given an array 'arr' and a list of lists 'pieces', attempts to reassemble arr
    by selecting pieces (each piece is a list of integers) if their elements appear in arr.
    Returns True if the concatenated pieces equal arr; otherwise, False.
    (Logic is based on the snippet and may need adjustment.)
    """
    assembled = []
    used = []
    # For each piece in pieces, if not already used and if its elements appear in arr, add it.
    for piece in pieces:
        if piece not in used and all(x in arr for x in piece):
            assembled.extend(piece)
            used.append(piece)
    return assembled == arr


# --- Next Function Block ---



def is_arithmetic_sequence(arr: list) -> bool:
    """
    Checks if the sorted list arr forms an arithmetic sequence.
    """
    if len(arr) < 2:
        return True
    arr = sorted(arr)
    diff = arr[1] - arr[0]
    for i in range(1, len(arr)):
        if arr[i] - arr[i - 1] != diff:
            return False
    return True


# --- Next Function Block ---



def are_all_arithmetic(lists: list) -> list:
    """
    Given a list of lists (each list of numbers), returns a list of booleans indicating whether
    each individual list is an arithmetic sequence.
    """
    result = []
    for lst in lists:
        result.append(is_arithmetic_sequence(lst))
    return result


# --- Next Function Block ---



def max_occurrences_of_word(sequence: str, word: str) -> int:
    """
    Returns the maximum number of non-overlapping occurrences of 'word' in 'sequence'.
    (Uses both a replace method and the built-in count for verification.)
    """
    count_builtin = sequence.count(word)
    # Alternatively, you might iterate over sequence to count non-overlapping occurrences.
    i, count = 0, 0
    while i <= len(sequence) - len(word):
        if sequence[i:i+len(word)] == word:
            count += 1
            i += len(word)
        else:
            i += 1
    # Return whichever count is higher (they should be equal if word does not overlap)
    return max(count, count_builtin)


# --- Next Function Block ---



def sum_halves(n: int) -> int:
    """
    Given n, repeatedly subtract half (floor division) until i <= 1.
    Returns the sum of all subtracted values.
    """
    count = 0
    while n > 1:
        sub = n // 2
        n = n - sub
        count += sub
    return count


# --- Next Function Block ---



def zigzag_convert(s: str, numRows: int) -> str:
    """
    Converts the string s into a zigzag pattern on numRows and reads line by line.
    (A simplified version of the zigzag conversion problem.)
    """
    if numRows == 1 or numRows >= len(s):
        return s
    rows = [''] * numRows
    cur_row, step = 0, 1
    for char in s:
        rows[cur_row] += char
        if cur_row == 0:
            step = 1
        elif cur_row == numRows - 1:
            step = -1
        cur_row += step
    return "".join(rows)


# --- Next Function Block ---



def equal_half_vowels(s: str) -> bool:
    """
    Checks if the first half and second half of string s have the same number of vowels.
    Assumes s length is even.
    """
    vowels = set("aeiouAEIOU")
    half = len(s) // 2
    first_half = s[:half]
    second_half = s[half:]
    count_first = sum(1 for ch in first_half if ch in vowels)
    count_second = sum(1 for ch in second_half if ch in vowels)
    return count_first == count_second


# --- Next Function Block ---



def election_winner(votes: list) -> str:
    """
    Given a list of votes (strings), returns the candidate with the most votes.
    """
    vote_counts = {}
    for vote in votes:
        vote_counts[vote] = vote_counts.get(vote, 0) + 1
    # Find candidate with maximum votes
    winner = max(vote_counts.items(), key=lambda x: x[1])[0]
    return winner


# --- Next Function Block ---



def count_special_substrings(s: str, r: str = "R", l: str = "L") -> int:
    """
    Constructs substrings of the form r repeated i times concatenated with l repeated i times,
    counts occurrences in s.
    """
    count_total = 0
    for i in range(1, len(s) + 1):
        substr = r * i + l * i
        if substr in s:
            occurrence = s.count(substr)
            print(substr, occurrence)
            count_total += occurrence
    return count_total


# --- Next Function Block ---



def count_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    Given a list of item lists and a rule specified by ruleKey ("type", "color", or "name"),
    counts how many items have the ruleValue at the corresponding index.
    Assumes: type → index 0, color → index 1, name → index 2.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints all elements of a 2D grid.
    """
    for row in grid:
        for elem in row:
            print(elem, end=" ")
        print()


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Sums numbers that appear only once in the list.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def sum_with_pattern(n: int) -> int:
    """
    For n iterations, accumulates a sum based on an increasing count and a position that resets every 7 counts.
    """
    total = 0
    count = 0
    pos = 1
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_mapping(nums: list) -> list:
    """
    Returns a new list where each element is nums[nums[i]].
    Assumes that all nums[i] are valid indices.
    """
    return [nums[x] for x in nums]


# --- Next Function Block ---



def sum_diff_by_divisibility(n: int, m: int) -> int:
    """
    Sums numbers from 1 to n that are not divisible by m and subtracts the sum of numbers that are divisible by m.
    """
    total_non_div = 0
    total_div = 0
    for i in range(1, n + 1):
        if i % m == 0:
            total_div += i
        else:
            total_non_div += i
    return total_non_div - total_div


# --- Next Function Block ---



def first_multiple_in_list(n: int, arr: list) -> int:
    """
    Returns the first multiple of n that is present in arr.
    """
    i = 1
    while True:
        multiple = i * n
        if multiple in arr:
            return multiple
        i += 1


# --- Next Function Block ---


def first_n_evens(n: int) -> list:
    """
    Returns a list of the first n even numbers.
    """
    return [i * 2 for i in range(1, n + 1)]


# --- Next Function Block ---


def gcd_from_list(nums: list) -> int:
    """
    Returns the greatest common divisor (GCD) of the minimum and maximum elements in nums.
    (Assumes positive numbers.)
    """
    from math import gcd
    low = min(nums)
    high = max(nums)
    return gcd(low, high)


# --- Next Function Block ---


def has_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    (This happens if n is a perfect square of a prime.)
    """
    import math
    if n < 4:
        return False
    sqrt_n = math.isqrt(n)
    if sqrt_n * sqrt_n != n:
        return False
    # Check if sqrt_n is prime.
    for i in range(2, int(math.sqrt(sqrt_n)) + 1):
        if sqrt_n % i == 0:
            return False
    return True


# --- Next Function Block ---


def custom_sort_validation(nums: list) -> bool:
    """
    Attempts a custom sort by removing and appending elements.
    Returns True if the custom-sorted list equals the actual sorted list.
    (Logic based on the provided snippet.)
    """
    original = nums[:]
    target = sorted(nums)
    arr = []
    i = 0
    # Use a copy for processing.
    temp = nums[:]
    while i < len(temp) - 1:
        if temp[i+1] < temp[i]:
            # Append the element at i+1 and remove it.
            arr.append(temp[i+1])
            del temp[i+1]
        else:
            i += 1
    result = arr + temp
    return result == target


# --- Next Function Block ---


def custom_remove_substring(str1: str, str2: str) -> str:
    """
    (Based on the provided snippet)
    If str2 is in str1, finds the first occurrence indices and removes that part.
    Otherwise returns str1.
    Note: If str2 is empty, returns str1.
    """
    if not str2:
        return str1
    idx = str1.find(str2)
    if idx != -1:
        return str1[:idx] + str1[idx+len(str2):]
    return str1


# --- Next Function Block ---


def sum_of_triangle_row_mins(triangle: list) -> int:
    """
    Given a triangle (list of lists), returns the sum of the minimum value in each row.
    """
    total = 0
    for row in triangle:
        total += min(row)
    return total


# --- Next Function Block ---


def remove_digit_and_record_indices(number: str, digit: str) -> (str, list):
    """
    Removes occurrences of digit from number and records the indices (of digit in original).
    Returns a tuple of (modified string, list of indices where digit was found).
    """
    indices = []
    result = ""
    for idx, ch in enumerate(number):
        if ch == digit:
            indices.append(idx)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---


def check_frequency_uniqueness(arr: list) -> bool:
    """
    Returns True if the sorted list of frequencies of elements equals the sorted unique frequencies.
    (Based on the provided snippet.)
    """
    freq = {}
    for num in arr:
        freq[num] = freq.get(num, 0) + 1
    freq_vals = sorted(freq.values())
    unique_vals = sorted(set(freq_vals))
    return freq_vals == unique_vals


# --- Next Function Block ---


def sum_of_divisible_elements(n: int) -> int:
    """
    For n = 7 (example), sums numbers from 1 to n and returns the difference between sum of numbers
    not divisible by a given condition and those that are divisible.
    (Based on the snippet where numbers divisible by m are summed separately.)
    This version uses m = 3 as in the snippet.
    """
    sum_non = 0
    sum_div = 0
    for i in range(1, n + 1):
        if i % 3 == 0:
            sum_div += i
        else:
            sum_non += i
    return sum_non - sum_div


# --- Next Function Block ---


def first_duplicate_in_list(nums: list):
    """
    Returns the first duplicate element in nums. If none found, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---


def rotate_array_right(nums: list, k: int) -> list:
    """
    Rotates the list nums to the right by k positions.
    """
    n = len(nums)
    k %= n
    return nums[-k:] + nums[:-k]


# --- Next Function Block ---


def sum_of_subarrays_with_odd_length(arr: list) -> int:
    """
    Sums all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---


def reformat_ip(address: str) -> str:
    """
    Reformats an IP address by inserting "[.]" between segments.
    Example: "1.1.1.1" -> "1[.]1[.]1[.]1"
    """
    parts = address.split(".")
    return "[.]".join(parts)


# --- Next Function Block ---


def count_jewels_in_stones(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are in jewels.
    """
    count = 0
    for ch in stones:
        if ch in jewels:
            count += 1
    return count


# --- Next Function Block ---


def interpret_command(command: str) -> str:
    """
    Interprets the command string:
      - "G" remains "G"
      - "()" is replaced by "o"
      - "(al)" is replaced by "al"
    Example: "G()(al)" -> "Goal"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---


def excel_columns(n: int) -> list:
    """
    Returns a list of the first n Excel column labels starting from 'A'.
    """
    return [chr(ord('A') + i) for i in range(n)]


# --- Next Function Block ---


def reformat_text(text: str) -> str:
    """
    Trims extra spaces and redistributes spaces evenly between words.
    (Simple approach: assumes extra spaces are those beyond single spaces.)
    """
    words = text.strip().split()
    return " ".join(words)


# --- Next Function Block ---



# 1. Given a number, sort its digits and compute the sum of the integer
#    formed by concatenating the smallest and largest digit with the remaining two in order.
def sorted_digits_sum(num: int) -> int:
    """
    Converts num to its digit list, sorts the digits, then returns:
      int(sorted[0] + sorted[3]) + int(sorted[1] + sorted[2])
    Example: 2932 -> digits sorted = ['2','2','3','9'] → int('2'+'9') + int('2'+'3') = 29 + 23 = 52.
    """
    s = str(num)
    arr = list(s)
    arr.sort()
    # Concatenate first and last digit; then second and third.
    return int(arr[0] + arr[3]) + int(arr[1] + arr[2])


# --- Next Function Block ---



# 2. Alternating digit sum: add digits at even indices, subtract at odd.
def alternating_digit_sum(n: int) -> int:
    """
    Converts n to a string and alternately adds and subtracts digits.
    Example: 111 -> (1 - 1 + 1) = 1.
    """
    s = str(n)
    total = 0
    for i in range(len(s)):
        if i % 2 == 0:
            total += int(s[i])
        else:
            total -= int(s[i])
    return total


# --- Next Function Block ---



# 3. Extract all digits from a list of numbers.
def extract_digits(nums: list) -> list:
    """
    For each number in nums, extracts its digits and returns a flat list of all digits.
    Example: [13,25] -> [1, 3, 2, 5]
    """
    result = []
    for num in nums:
        for ch in str(num):
            result.append(int(ch))
    return result


# --- Next Function Block ---



# 4. Count numbers (1 to num) whose digit sum is even.
def count_even_digit_sum(num: int) -> int:
    """
    For every number from 1 to num, computes the sum of digits (printing each sum),
    and counts how many have an even digit sum.
    """
    count = 0
    for i in range(1, num + 1):
        s = str(i)
        digit_sum = sum(int(ch) for ch in s)
        # Uncomment the next line to print each sum:
        # print(digit_sum)
        if digit_sum % 2 == 0:
            count += 1
    return count


# --- Next Function Block ---



# 5. Letter-sum transformation.
def letter_sum_transformation(s: str, k: int) -> int:
    """
    Maps each letter in s to a number (a->1, b->2, ..., z->26) by concatenation.
    Then, for k iterations, sums all digits of the resulting string and reassigns.
    Finally, returns the final integer.
    Example: s="iiii", k=2.
    """
    mapping = {
        "a": "1", "b": "2", "c": "3", "d": "4", "e": "5",
        "f": "6", "g": "7", "h": "8", "i": "9", "j": "10",
        "k": "11", "l": "12", "m": "13", "n": "14", "o": "15",
        "p": "16", "q": "17", "r": "18", "s": "19", "t": "20",
        "u": "21", "v": "22", "w": "23", "x": "24", "y": "25", "z": "26"
    }
    res = ""
    for ch in s:
        res += mapping[ch]
    for _ in range(k):
        ssum = sum(int(ch) for ch in res)
        res = str(ssum)
    return int(res)


# --- Next Function Block ---



# 6. For a list of strings, for each pair compute a boolean array indicating for each letter in the first
#    string whether it is absent in the second; then find the maximum length of such an array that contains True.
def common_prefix_discrepancy(strs: list) -> (int, list):
    """
    For each pair (i, j) (i < j) in strs, builds an array with True where a character of strs[i]
    is not in strs[j], False otherwise. Then returns the maximum length among those arrays
    that contain at least one True, along with the list of arrays.
    (The logic is based on the provided snippet and may be interpreted.)
    """
    arrays = []
    max_len = -1
    for i in range(len(strs) - 1):
        for j in range(i + 1, len(strs)):
            arr = []
            for ch in strs[i]:
                if ch in strs[j]:
                    arr.append(False)
                else:
                    arr.append(True)
            arrays.append(arr)
            if True in arr and len(arr) > max_len:
                max_len = len(arr)
    return max_len, arrays


# --- Next Function Block ---



# 7. Compute a cost using total, cost1 and cost2.
def compute_cost(total: int, cost1: int, cost2: int) -> int:
    """
    Given total money and two costs, ensures cost1 is smaller than cost2,
    then simulates a purchase process and returns a computed value.
    (Logic is based on the provided snippet.)
    """
    if cost2 > cost1:
        # Swap cost1 and cost2 if needed.
        cost1, cost2 = cost2, cost1
    prd = 0
    for i in range(total // cost1):
        ttl = total - cost1 * i
        count = 1
        while ttl > 0:
            count += 1
            ttl -= cost2
        if ttl == 0:
            prd += count
    return prd + 1


# --- Next Function Block ---



# 8. Decode a string of the form "a1c1e1" into letters by shifting the previous letter.
def decode_string(s: str) -> str:
    """
    For each character in s, if it's a letter, output it.
    If it's a digit, take the previous letter's index in the alphabet and shift by that digit.
    Example: "a1c1e1" becomes "abcdef" (depending on dictionary).
    """
    alpha = "abcdefghijklmnopqrstuvwxyz"
    res = ""
    for i in range(len(s)):
        if s[i].isalpha():
            res += s[i]
        else:
            # s[i] is digit; shift previous letter.
            prev = s[i-1]
            ind = alpha.index(prev) + int(s[i])
            res += alpha[ind % 26]
    return res


# --- Next Function Block ---



# 9. Find the first index of target in nums, starting at index start.
def find_index(nums: list, target: int, start: int) -> int:
    """
    Returns the first index of target in nums, starting from start.
    If not found, returns -1.
    """
    for i in range(start, len(nums)):
        if nums[i] == target:
            return i
    return -1


# --- Next Function Block ---



# 10. Return substring of a numeric string up to and including the last odd digit (scanning from right).
def last_odd_substring(num: str) -> str:
    """
    Returns the substring of num up to (and including) the last odd digit when scanning from right.
    """
    for i in reversed(range(len(num))):
        if int(num[i]) % 2 == 1:
            return num[:i+1]
    return ""


# --- Next Function Block ---



# 11. Return the maximum digit that appears at least 3 times in num, repeated three times.
def triple_max_frequent_digit(num: str) -> str:
    """
    Finds all digits that appear at least 3 times in num.
    Returns the maximum such digit repeated three times.
    """
    freq = {}
    candidates = []
    for ch in num:
        freq[ch] = freq.get(ch, 0) + 1
        if freq[ch] >= 3 and int(ch) not in candidates:
            candidates.append(int(ch))
    if candidates:
        return str(max(candidates)) * 3
    return ""


# --- Next Function Block ---



# 12. Alternate approach: Check for each digit if its triple exists in num and choose the maximum.
def triple_max_digit_condition(num: str) -> str:
    """
    Checks each digit in num; if digit repeated three times is a substring,
    and the digit is larger than the current candidate, update candidate.
    Returns the candidate digit repeated three times.
    """
    grt = -1
    for ch in num:
        if (ch * 3) in num and int(ch) > grt:
            grt = int(ch)
    return str(grt) * 3 if grt > -1 else ""


# --- Next Function Block ---



# 13. Count keys in a dictionary.
def dict_key_count(d: dict) -> int:
    """
    Returns the number of keys in dictionary d.
    """
    return len(d)


# --- Next Function Block ---



# 14. Check if both left and right values appear in any of the given ranges.
def check_range(ranges: list, left: int, right: int) -> bool:
    """
    Checks if left and right exist in any range (list of two numbers) from ranges.
    Returns True if both found; otherwise False.
    """
    isLeft = False
    isRight = False
    for r in ranges:
        if left in r or isLeft:
            isLeft = True
            if right in r:
                isRight = True
    return isLeft and isRight


# --- Next Function Block ---



# 15. Simulate a lock. Given a starting lock (e.g. ["0","0","0","0"]) and a target lock as a string,
#     increment digits until lock equals target; count the moves.
def open_lock(target: str) -> (list, int):
    """
    Starting from ["0", "0", "0", "0"], increments individual digits (left-to-right)
    until the lock matches target. Returns the final lock state (as a list of strings) and the move count.
    """
    lock = ["0", "0", "0", "0"]
    target_list = list(target)
    count = 0
    i = 0
    while lock != target_list and i < len(lock):
        if lock[i] != target_list[i]:
            # Increment digit by 1 (as string)
            lock[i] = str(int(lock[i]) + 1)
            count += 1
        else:
            i += 1
    return lock, count


# --- Next Function Block ---



# 16. Count Pythagorean triplets (brute force) for numbers 1 to num.
def count_pythagorean_triplets(num: int) -> int:
    """
    Counts the number of Pythagorean triplets (idx, jdx, kdx) with 1 <= idx, jdx, kdx <= num.
    """
    count = 0
    for a in range(1, num+1):
        for b in range(1, num+1):
            if a == b:
                continue
            for c in range(max(a, b) + 1, num+1):
                if a * a + b * b == c * c:
                    count += 1
                    # Uncomment to print the triplet:
                    # print(a, b, c)
    return count


# --- Next Function Block ---



# 17. Count Pythagorean triplets (variant with three loops, skipping i == j).
def count_pythagorean_triplets_variant(num: int) -> int:
    """
    Another variant to count Pythagorean triplets using three nested loops.
    """
    count = 0
    for k in range(1, num+1):
        for i in range(1, k):
            for j in range(1, k):
                if i == j:
                    continue
                if i * i + j * j == k * k:
                    count += 1
    return count


# --- Next Function Block ---



# 18. Count numbers that have at least one non-identical partner.
def count_non_identical_partners(nums: list) -> int:
    """
    For each pair of distinct numbers in nums, collects the unique numbers that appear in such pairs.
    Returns the count of unique numbers that appear in a pair with a different number.
    """
    arr = []
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            if nums[i] != nums[j]:
                if nums[i] not in arr:
                    arr.append(nums[i])
                if nums[j] not in arr:
                    arr.append(nums[j])
    return len(arr)


# --- Next Function Block ---



# 19. Check if all characters in a string have the same frequency.
def all_equal_frequency(s: str) -> bool:
    """
    Returns True if every character in s occurs the same number of times; otherwise False.
    """
    freq = {ch: s.count(ch) for ch in s}
    first = next(iter(freq.values()))
    for count in freq.values():
        if count != first:
            return False
    return True


# --- Next Function Block ---



# 20. Count word frequencies in a sentence.
def count_word_frequencies(text: str) -> dict:
    """
    Returns a dictionary with word frequencies from text.
    """
    words = text.split()
    freq = {}
    for word in words:
        freq[word] = freq.get(word, 0) + 1
    return freq


# --- Next Function Block ---



# 21. Compute differences in groups: for sorted nums in descending order,
#     for each index i (up to len(nums)-k), for j in i+1 to i+1+k, record the difference.
def differences_in_groups(nums: list, k: int) -> list:
    """
    Sorts nums in reverse order and, for each index i up to len(nums)-k, computes differences with the next k numbers.
    Returns the list of differences.
    """
    result = []
    nums.sort(reverse=True)
    for i in range(len(nums) - k):
        for j in range(i+1, i+1+k):
            result.append(nums[i] - nums[j])
    return result


# --- Next Function Block ---



# 22. Reverse substring up to a given character.
def reverse_up_to_char(word: str, ch: str) -> str:
    """
    Finds the first occurrence of ch in word, reverses the substring up to and including that character,
    then concatenates the remainder.
    """
    ind = word.index(ch)
    return word[:ind+1][::-1] + word[ind+1:]


# --- Next Function Block ---



# 23. Compute maximum differences for each element:
def max_differences(nums: list) -> list:
    """
    For each index in nums, computes the maximum difference (nums[j]-nums[i]) for j > i.
    Returns a list with -1 as the first element and the maximum differences for subsequent indices.
    """
    result = [-1]
    for i in range(len(nums)-1):
        diffs = []
        for j in range(i+1, len(nums)):
            if nums[j] > nums[i]:
                diffs.append(nums[j] - nums[i])
        if diffs:
            result.append(max(diffs))
    return result


# --- Next Function Block ---



# 24. Find maximum gap (j - i) such that colors[i] != colors[j].
def max_index_gap_different(colors: list) -> int:
    """
    Returns the maximum index gap between two elements in colors that are different.
    """
    max_gap = -1
    n = len(colors)
    for i in range(n-1):
        for j in range(i+1, n):
            if colors[i] != colors[j] and (j - i) > max_gap:
                max_gap = j - i
    return max_gap


# --- Next Function Block ---



# 25. Shifting letters: using shifts list to transform s.
def shifting_letters(s: str, shifts: list) -> str:
    """
    For each index i in s, sums shifts from i to end, adds the index of s[i] in the alphabet,
    takes modulo 26, and returns the corresponding letter. Builds the final string.
    """
    alphabet = [chr(i) for i in range(ord('a'), ord('z')+1)]
    res = ""
    for i in range(len(s)):
        total = sum(shifts[i:]) + alphabet.index(s[i])
        total %= 26
        res += alphabet[total]
    return res


# --- Next Function Block ---



# 26. Reshape a 1D list into an m x n matrix.
def reshape_matrix(original: list, m: int, n: int) -> list:
    """
    Reshapes the list 'original' into a matrix with m rows and n columns.
    Assumes len(original) == m * n.
    """
    matrix = []
    k = 0
    for i in range(m):
        row = []
        for j in range(n):
            row.append(original[k])
            k += 1
        matrix.append(row)
    return matrix


# --- Next Function Block ---



# 27. Merge two lists of pairs (ambiguous logic from snippet).
def merge_pair_lists(nums1: list, nums2: list) -> list:
    """
    Given two lists of pairs, for each corresponding pair, if their first elements are equal,
    add their second elements; otherwise, collect the pair from the second list.
    Then, insert these collected pairs into the longer list based on the first element.
    (Logic is ambiguous; this is one interpretation.)
    """
    longest = nums1 if len(nums1) >= len(nums2) else nums2
    shortest = nums2 if longest is nums1 else nums1
    extra = []
    for i in range(len(shortest)):
        pair_long = longest[i]
        pair_short = shortest[i]
        if pair_long[0] == pair_short[0]:
            pair_long[1] += pair_short[1]
        else:
            extra.append(pair_short)
    # Insert extra pairs into longest based on first element (index = first element - 1)
    for pair in extra:
        ind = pair[0] - 1
        longest.insert(ind, pair)
    return longest


# --- Next Function Block ---



# 28. Print every 5th element’s first two numbers from an array.
def print_every_fifth(arr: list) -> None:
    """
    Iterates over arr with a step of 5 and prints arr[i] and arr[i+1] if available.
    """
    for i in range(0, len(arr), 5):
        if i + 1 < len(arr):
            print(arr[i])
            print(arr[i+1])


# --- Next Function Block ---



# 29. Intersection among three lists.
def intersect_three_lists(nums1: list, nums2: list, nums3: list) -> list:
    """
    Returns the list of unique elements that appear in at least two of the three lists.
    """
    set1 = set(nums1)
    set2 = set(nums2)
    set3 = set(nums3)
    # Intersection among any two:
    inter = (set1 & set2) | (set1 & set3) | (set2 & set3)
    return list(inter)


# --- Next Function Block ---



# 30. Check if all characters in a string occur with equal frequency.
def all_equal_frequency(s: str) -> bool:
    """
    Returns True if all characters in s have the same frequency; otherwise False.
    """
    freq = {ch: s.count(ch) for ch in s}
    return len(set(freq.values())) == 1


# --- Next Function Block ---



# 31. Count word frequencies.
def word_frequencies(text: str) -> dict:
    """
    Splits text by spaces and returns a dictionary of word frequencies.
    """
    words = text.split()
    freq = {}
    for word in words:
        freq[word] = freq.get(word, 0) + 1
    return freq


# --- Next Function Block ---




def most_frequent_prefix(strs: list) -> str:
    """
    Attempts to compute the prefix of the first string that appears most frequently among the strings.
    (The logic is ambiguous; here we simply return the longest common prefix.)
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# --- Next Function Block ---



# 74. Find all common prefixes from the first string that appear in every string.
def all_common_prefixes(strs: list) -> list:
    """
    Returns a list of all prefixes of the first string that are common to all strings in the list.
    """
    if not strs:
        return []
    common = []
    base = strs[0]
    for i in range(1, len(base) + 1):
        prefix = base[:i]
        if all(s.startswith(prefix) for s in strs):
            common.append(prefix)
    return common


# --- Next Function Block ---



# 75. For each number in nums, compute the sum of absolute differences with all numbers.
def sum_abs_differences(nums: list) -> list:
    """
    Returns a list where for each element in nums, the value is the sum of absolute differences
    between that element and every element in nums.
    """
    result = []
    for i in nums:
        total = sum(abs(i - j) for j in nums)
        result.append(total)
    return result


# --- Next Function Block ---




# patterns.py

# 1. Compute an arithmetic expression: num + t*2
def add_and_multiply(num: int, t: int) -> int:
    return num + t * 2


# --- Next Function Block ---



# 2. (Placeholder) Process a string and remove paired characters.
# NOTE: The original code was ambiguous. This version simply returns a list of characters.
def process_string(s: str) -> list:
    arr = list(s)
    # If s length is odd, return False (or an empty list)
    if len(s) % 2 == 1:
        return []
    # The original logic attempted removals based on a dictionary,
    # but since it was unclear, we return the sorted list as a placeholder.
    return sorted(arr)


# --- Next Function Block ---



# 3. Validate parentheses using a stack (an alternative to the given complex snippet)
def validate_parentheses(s: str) -> bool:
    mapping = {"(": ")", "[": "]", "{": "}"}
    stack = []
    for char in s:
        if char in mapping:
            stack.append(mapping[char])
        else:
            if not stack or char != stack.pop():
                return False
    return not stack


# --- Next Function Block ---



# 4. Reverse a number's string representation.
def reverse_number(num: int) -> str:
    return str(num)[::-1]


# --- Next Function Block ---



# 5. Simulate stack operations to build an array.
def simulate_stack_ops(n: int, target: list) -> list:
    """
    Simulates "Push" and "Pop" operations to build an array from 1 to n until the array equals target.
    (This logic is taken from the snippet; note that with target == [] the loop never runs.)
    """
    res = []
    arr = []
    i = 1
    k = 0
    while i <= n and arr != target:
        arr.append(i)
        res.append("Push")
        if target and arr[k] != target[k]:
            arr.pop()
            res.append("Pop")
        else:
            k += 1
        i += 1
    return res


# --- Next Function Block ---



# 6. Find a special value in an array based on frequency (ambiguous snippet)
def find_special_value(arr: list, k: int) -> int:
    """
    Iterates over the array and tracks a "great" value based on adjacent comparisons
    and frequency counting. (The original snippet logic is unclear; this is one interpretation.)
    """
    d = {}
    i = 1
    count = 0
    # Use k to decide a target count (if k>1, j starts at 2; else 1)
    j_target = 2 if k > 1 else 1
    while count != j_target and i < len(arr):
        great = arr[i] if arr[i] > arr[i - 1] else arr[i - 1]
        d[great] = d.get(great, 0) + 1
        count = d[great]
        i += 1
    return great


# --- Next Function Block ---



def remaining_chars_after_subtraction(s: str, t: str) -> str:
    """
    Given two strings s and t, reduce the frequency of characters in t based on s and then 
    return a concatenation of characters that remain (i.e. frequency > 0).
    """
    freq = Counter(t)
    for ch in s:
        freq[ch] -= 1
    res = ""
    for ch in freq:
        if freq[ch] > 0:
            res += ch
    return res


# --- Next Function Block ---



# 8. Find the 1-indexed position of the first word in a sentence containing searchWord.
def find_word_index(sentence: str, searchWord: str) -> int:
    words = sentence.split()
    for idx, word in enumerate(words, start=1):
        if searchWord in word:
            return idx
    return -1


# --- Next Function Block ---



# 9. Count how many words in a list are prefixes of a given string.
def count_prefix_matches(words: list, s: str) -> int:
    count = 0
    for word in words:
        if s.startswith(word):
            count += 1
    return count


# --- Next Function Block ---



# 10. Check if concatenating words in order equals a target string.
def check_concatenation(words: list, target: str) -> bool:
    res = ""
    for word in words:
        res += word
        if len(res) >= len(target):
            break
    return res == target


# --- Next Function Block ---



# 11. Find the first missing positive integer from a list.
def first_missing_positive(nums: list) -> int:
    nums_set = set(nums)
    i = 1
    while True:
        if i not in nums_set:
            return i
        i += 1


# --- Next Function Block ---



# 12. Brute-force approach for longest palindromic substring.
def longest_palindromic_substring(s: str) -> str:
    out = ""
    for i in range(len(s)):
        res = ""
        for j in range(i, len(s)):
            res += s[j]
            if res == res[::-1] and len(res) > len(out):
                out = res
    return out


# --- Next Function Block ---



# 13. Split string into chunks of length k; pad the last chunk with fill if necessary.
def split_and_pad(s: str, k: int, fill: str = "x") -> list:
    arr = []
    res = ""
    for ch in s:
        if len(res) >= k:
            arr.append(res)
            res = ch
        else:
            res += ch
    if len(res) < k:
        res += fill * (k - len(res))
    arr.append(res)
    return arr


# --- Next Function Block ---



# 14. Find intervals of repeating characters (length >= threshold).
def find_repeating_intervals(s: str, threshold: int = 3) -> list:
    intervals = []
    i = 0
    while i < len(s):
        count = 0
        j = i
        while j < len(s) and s[i] == s[j]:
            count += 1
            j += 1
        if count >= threshold:
            intervals.append([i, j - 1])
        i = j
    return intervals


# --- Next Function Block ---



# 15. Get length of a specific line from a list.
def line_length(lines: list, index: int) -> int:
    if index < len(lines):
        return len(lines[index])
    return 0


# --- Next Function Block ---



# 16. Check if two strings have the same character frequencies.
def same_frequency(s: str, t: str) -> bool:
    return Counter(s) == Counter(t)


# --- Next Function Block ---



# 17. Check if there exists a duplicate element within distance k.
def contains_nearby_duplicate(nums: list, k: int) -> bool:
    for i in range(len(nums) - 1):
        for j in range(i + 1, len(nums)):
            if nums[i] == nums[j] and abs(i - j) <= k:
                return True
    return False


# --- Next Function Block ---



# 18. Simplify Unix path.
def simplify_path(path: str) -> str:
    # A simple implementation using a stack.
    parts = path.split('/')
    stack = []
    for part in parts:
        if part == '' or part == '.':
            continue
        elif part == '..':
            if stack:
                stack.pop()
        else:
            stack.append(part)
    return "/" + "/".join(stack)


# --- Next Function Block ---



# 19. Reverse result on encountering a specific character.
def reverse_on_char(s: str, char: str = "i") -> str:
    res = ""
    for ch in s:
        if ch == char:
            res = res[::-1]
        else:
            res += ch
    return res


# --- Next Function Block ---



# 20. Reverse alphabetical characters while keeping non-alphabetic in place.
def reverse_alpha_keep_nonalpha(s: str) -> str:
    alphabets = [ch for ch in s if ch.isalpha()]
    alphabets.reverse()
    res = list(s)
    for idx, ch in enumerate(s):
        if ch.isalpha():
            res[idx] = alphabets.pop(0)
    return "".join(res)


# --- Next Function Block ---



# 21. Split words by a separator and collect non-empty segments.
def split_words_by_separator(words: list, separator: str) -> list:
    result = []
    for word in words:
        segments = word.split(separator)
        for seg in segments:
            if seg:
                result.append(seg)
    return result


# --- Next Function Block ---



# 22. Transform string groups: reverse the first k characters of each group then append the rest.
def transform_string_groups(s: str, k: int) -> str:
    count = 0
    res = ""
    out = ""
    for ch in s:
        res += ch
        count += 1
        if count == k:
            out += res[::-1]
            res = ""
            count = 0
    out += res
    return out


# --- Next Function Block ---



# 23. Sum squares of numbers in list if list length divides index+1.
def sum_condition_square(nums: list) -> int:
    total = 0
    for i in range(len(nums)):
        if len(nums) % (i + 1) == 0:
            total += nums[i] * nums[i]
    return total


# --- Next Function Block ---



# 24. Custom sort of string digits: sort characters, then build string in reversed order for all but last.
def custom_sort_string(s: str) -> str:
    arr = list(s)
    arr.sort()
    res = ""
    for i in reversed(range(len(arr) - 1)):
        res += arr[i]
    res += arr[-1]
    return res


# --- Next Function Block ---



# 25. Check if any pair (i, j) satisfies i^2 + j^2 == c.
def check_sum_of_squares(c: int) -> bool:
    for i in range(0, c + 1):
        for j in range(1, c + 1):
            if i * i + j * j == c:
                return True
    return False


# --- Next Function Block ---



# 26. Sum of absolute differences for each element in nums.
def sum_abs_differences(nums: list) -> list:
    result = []
    for i in nums:
        total = sum(abs(i - j) for j in nums)
        result.append(total)
    return result


# --- Next Function Block ---





# 1. Return indices of words that contain a given substring.
def indices_of_substring_in_words(words, x):
    """
    Returns a list of indices for which the string x is a substring of each word.
    Example:
      words = ["leet", "code"], x = "e"  → returns [0]
    """
    result = []
    for i in range(len(words)):
        if x in words[i]:
            result.append(i)
    return result


# --- Next Function Block ---



# 2. Alternate elements from the sorted list.
def alternate_sorted_elements(nums):
    """
    Given a list of numbers, sorts them and then builds a new list by alternating
    between taking an element from the beginning and from the end.
    """
    nums.sort()
    result = []
    i = 0
    flag = True
    while len(result) < len(nums):
        if flag:
            result.append(nums[i])
        else:
            result.append(nums[-i])
        flag = not flag
        i += 1
    return result


# --- Next Function Block ---



# 3. Sum consecutive numbers starting from max(nums) over k terms.
def sum_from_max(nums, k):
    """
    Returns the sum of k consecutive integers starting from max(nums).
    """
    start = max(nums)
    total = 0
    for i in range(start, start + k):
        total += i
    return total


# --- Next Function Block ---



# 4. Count ones in binary representation of a number.
def count_ones_in_binary(n):
    """
    Returns the count of '1's in the binary representation of n.
    """
    b = bin(n)
    counts = Counter(b)
    return counts['1'] if '1' in counts else 0


# --- Next Function Block ---



# 5. Add two binary strings.
def binary_sum(a, b):
    """
    Returns the binary string representing the sum of binary strings a and b.
    """
    total = int(a, 2) + int(b, 2)
    return bin(total)


# --- Next Function Block ---



# 6. Add an integer k to a list of digits and return the result as a list.
def add_to_digit_list(digits, k):
    """
    Given a list of digits (e.g. [1,2,0,0]) and an integer k,
    forms the number, adds k, and returns the new number as a list of digits.
    """
    num_str = "".join(str(d) for d in digits)
    new_num = int(num_str) + k
    return [int(ch) for ch in str(new_num)]


# --- Next Function Block ---



# 7. Make a palindrome by mirroring the lower of symmetric digits.
def make_palindrome(s):
    """
    Given a string s, for each pair of symmetric characters, change both to the lesser character.
    Example: "egcfe" → "egcge"
    """
    arr = list(s)
    n = len(arr)
    for i in range(n // 2):
        j = n - i - 1
        if arr[i] != arr[j]:
            # Choose the lexicographically smaller character.
            if arr[i] < arr[j]:
                arr[j] = arr[i]
            else:
                arr[i] = arr[j]
    return "".join(arr)


# --- Next Function Block ---



# 8. Remove occurrences of "AB" or "CD" repeatedly and return final length.
def reduce_string(s):
    """
    Repeatedly removes occurrences of "AB" or "CD" from s until neither exists.
    Returns the length of the resulting string.
    """
    while "AB" in s or "CD" in s:
        res = ""
        i = 0
        while i < len(s):
            # Check for "AB" or "CD" pair.
            if i < len(s) - 1 and (s[i] == "A" and s[i+1] == "B" or s[i] == "C" and s[i+1] == "D"):
                i += 2  # skip these two characters
            else:
                res += s[i]
                i += 1
        s = res
    return len(s)


# --- Next Function Block ---



# 9. Process two strings with backspace (#) operations.
def process_backspaces(s, t):
    """
    Processes strings s and t such that every '#' represents a backspace.
    Returns the final processed strings as a tuple.
    """
    def process(s):
        res = []
        for ch in s:
            if ch == "#":
                if res:
                    res.pop()
            else:
                res.append(ch)
        return "".join(res)
    return process(s), process(t)
