

# --- Next Function Block ---

import re
import math
from abc import ABC, abstractmethod
from collections import Counter
import functools
import string
import random

class A:
    def print():
        pass
# -----------------------------------------------------
# Function 1: Insertion sort (in-place) using insertion‐like algorithm.
def insertion_sort(arr: list) -> list:
    """
    Sorts the list 'arr' using a variant of insertion sort.
    
    Example:
      Input: [4, 2, 1, 3]
      Output: [1, 2, 3, 4]
    """
    head = arr.copy()
    i = 1
    while i < len(head):
        if head[i] < head[i - 1]:
            j = i - 1
            # Move left until we find a position where head[i] is not less.
            while j >= 0 and head[i] < head[j]:
                j -= 1
            # Insert head[i] at the correct position.
            head.insert(j + 1, head[i])
            # Remove the duplicate element (since head[i] was shifted).
            del head[i + 1]
        else:
            i += 1
    return head


# --- Next Function Block ---


# -----------------------------------------------------
# Function 2: Pairwise swap (inserting elements from end into the middle)
def pairwise_swap(head: list) -> list:
    """
    Given a list 'head', inserts elements from the end into the middle positions.
    The snippet shows inserting element at the end at index i and then removing the duplicate.
    
    Example:
      Input: [1]
      Output: [1]  (For a single element, nothing changes.)
    """
    head = head.copy()
    i = 1
    j = len(head) - 1
    while j > i:
        head.insert(i, head[j])
        del head[j + 1]
        i += 2
    return head


# --- Next Function Block ---


# -----------------------------------------------------
# Function 3: Demonstrate closure with a global variable.
def demonstrate_closure() -> None:
    """
    Demonstrates variable lookup in a closure by printing a global variable.
    """
    def f():
        print(x)
    x = 1
    f()


# --- Next Function Block ---


class A:
    def print():
        pass

# -----------------------------------------------------
# Function 4: Rotate a list by k positions (to the right).
def rotate_list(head: list, k: int) -> list:
    """
    Rotates the list 'head' to the right by k positions.
    
    Example:
      head = [0,1,2], k = 3
      Since k % len(head) == 0, the rotated list is the same.
    """
    n = len(head)
    if n == 0:
        return head
    k = k % n
    # Using slicing for rotation:
    return head[-k:] + head[:-k]


# --- Next Function Block ---


# -----------------------------------------------------
# Function 5: Count distinct substrings in a reversed string.
def count_distinct_substrings(s: str) -> int:
    """
    Reverses the string s, then counts distinct substrings generated by
    expanding from each character.
    
    Note: The original snippet is ambiguous; this function uses a simple
    method to count all distinct substrings.
    """
    s = s[::-1]
    substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substrings.add(s[i:j])
    return len(substrings)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 6: Append text to a file and then read its contents.
def append_and_read_file(filename: str, text: str) -> None:
    """
    Appends 'text' to the file 'filename' and then prints its contents.
    """
    with open(filename, "a") as f:
        f.write(text)
    with open(filename, "r") as f:
        for line in f:
            print(line, end="")


# --- Next Function Block ---


# -----------------------------------------------------
# Function 7: Print numbers missing in a list.
def get_missing_numbers(arr: list) -> list:
    """
    Given a list 'arr', prints and returns numbers in range [0, max(arr))
    that are not present in arr.
    """
    missing = []
    for i in range(max(arr)):
        if i not in arr:
            missing.append(i)
    return missing


# --- Next Function Block ---


# -----------------------------------------------------
# Function 8: Reverse a subarray between two 1-indexed positions.
def reverse_subarray(head: list, left: int, right: int) -> list:
    """
    Reverses a portion of the list 'head' from index left-1 to right-1 (inclusive).
    
    Example:
      head = [1,2,3,4,5,6,8], left = 2, right = 4
      Output: [1, 4, 3, 2, 5, 6, 8]
    """
    # Convert left and right to 0-indexed.
    left_idx = left - 1
    right_idx = right
    new_list = head[:left_idx] + head[left_idx:right_idx][::-1] + head[right_idx:]
    return new_list


# --- Next Function Block ---


# -----------------------------------------------------
# Function 9: Print increasing slices of a list.
def print_increasing_slices(head: list) -> None:
    """
    For each index i in head, prints the slice head[i:j] where j increases based on a rule.
    (The original snippet increases j by j-i each iteration.)
    """
    i = 0
    j = 1
    while i < len(head):
        print(head[i:j])
        i += 1
        j += (j - i)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 10: Remove up to k occurrences across groups and return distinct group count.
def remove_k_occurrences(arr: list, k: int) -> int:
    """
    Counts the occurrences of each element in arr and then “removes” up to k occurrences across groups.
    Returns the number of groups (distinct elements) remaining after removals.
    
    This function uses the Counter to get counts, then iterates through the sorted counts.
    (Based on snippet logic, returns len(count) - j, where j is incremented when count goes below 1.)
    """
    counts = dict(sorted(Counter(arr).items(), key=lambda item: item[1]))
    j = 0
    flag = False
    for key in counts:
        while counts[key] > 0:
            if k > 0:
                counts[key] -= 1
                k -= 1
                if counts[key] < 1:
                    j += 1
            else:
                flag = True
                break
        if flag:
            break
    return len(counts) - j


# --- Next Function Block ---


# -----------------------------------------------------
# Function 11: Reverse chunks of a list (based on index modulus k).
def reverse_chunks(arr: list, k: int) -> list:
    """
    Divides the list 'arr' into chunks of size k and reverses each chunk.
    If the last chunk is smaller than k, leaves it as is.
    
    Example:
      arr = [1,2,3,4], k = 2 → returns [2,1,4,3]
    """
    result = []
    for i in range(0, len(arr), k):
        chunk = arr[i:i+k]
        if len(chunk) == k:
            result.extend(chunk[::-1])
        else:
            result.extend(chunk)
    return result


# --- Next Function Block ---


# -----------------------------------------------------
# Function 12: Transform list by conditional chunk reversal.
def transform_list_by_chunks(arr: list) -> list:
    """
    Transforms the list 'arr' by taking chunks (whose size depends on a changing parameter k)
    and reverses the chunk if its length is even, otherwise leaves it as is.
    
    The update of the start index uses the rule i = k*k - i and increments k by 1 each iteration.
    (This is one interpretation of the snippet.)
    """
    nums = []
    i = 0
    k = 1
    n = len(arr)
    while i < n:
        # Determine chunk size as k; slice from i to i+k.
        chunk = arr[i:i+k]
        if len(chunk) % 2 == 0:
            nums.extend(chunk[::-1])
        else:
            nums.extend(chunk)
        # Update i as shown in snippet: i = k*k - i.
        i = k * k - i
        k += 1
    return nums


# --- Next Function Block ---


# -----------------------------------------------------
# Function 13: Remove elements until list is sorted.
def remove_until_sorted(nums: list) -> (list, int):
    """
    Repeatedly removes an element that is out of order until the list is sorted.
    Returns a tuple of (final sorted list, number of iterations).
    
    Example:
      nums = [4,5,7,7,13]
    """
    count = 0
    while nums != sorted(nums):
        i = 0
        while i < len(nums) - 1:
            if nums[i+1] < nums[i]:
                del nums[i+1]
            else:
                i += 1
        count += 1
    return nums, count


# --- Next Function Block ---


# -----------------------------------------------------
# Function 14: Count common elements in two lists.
def count_common_elements(head: list, nums: list) -> int:
    """
    Counts how many elements in 'head' are also present in 'nums'.
    
    Example:
      head = [0,1,2,3], nums = [0,1,3] → returns 3.
    """
    count = 0
    for item in head:
        if item in nums:
            count += 1
    return count


# --- Next Function Block ---


# -----------------------------------------------------
# Function 15: Length of sublist after the maximum element.
def length_after_max(head: list) -> int:
    """
    Returns the length of the sublist after the maximum element in head.
    
    Example:
      head = [5,2,13] → maximum is 13 at index 2, so returns len(head) - 3 = 0.
    """
    if not head:
        return 0
    max_val = max(head)
    max_index = head.index(max_val)
    return len(head) - (max_index + 1)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 16: Maximum reachable index with given bricks and ladders.
def max_reachable_index(heights: list, bricks: int, ladders: int) -> int:
    """
    Simulates moving from the first building to subsequent buildings using bricks and ladders.
    For each step, if the next building is higher, uses bricks (or ladders if insufficient bricks).
    Returns the maximum index reached (0-indexed).
    
    Example:
      heights = [14,3,19,3], bricks = 17, ladders = 0.
    """
    i = 0
    while i < len(heights) - 1:
        diff = heights[i+1] - heights[i]
        if diff > 0:
            if diff > bricks and ladders > 0:
                ladders -= 1
            elif diff <= bricks:
                bricks -= diff
            else:
                break
        i += 1
    return i


# --- Next Function Block ---


# -----------------------------------------------------
# Function 17: Insert GCD between adjacent elements.
def insert_gcd_between_adjacent(arr: list) -> list:
    """
    For each pair of adjacent elements in arr, computes their GCD and inserts it between them.
    
    Example:
      arr = [18,6,10,3] 
      Returns a new list with the GCD inserted between adjacent pairs.
    """
    def gcd(a, b):
        return math.gcd(a, b)
    res = []
    for i in range(len(arr)-1):
        res.append(arr[i])
        res.append(gcd(arr[i], arr[i+1]))
    res.append(arr[-1])
    return res


# --- Next Function Block ---


# -----------------------------------------------------
# Function 18: Merge parts of two lists.
def merge_lists(list1: list, list2: list, a: int, b: int) -> list:
    """
    Merges segments of list1 and list2:
      - Takes the first a elements from list1.
      - Then all elements from list2.
      - Then all elements of list1 after index b.
    
    Example:
      list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]
      Returns: list1[:3] + list2 + list1[5:]
    """
    return list1[:a] + list2 + list1[b+1:]


# --- Next Function Block ---




# -----------------------------------------------------
# Function 1: Find the nth number in a custom sequence.
def find_nth_number(n: int) -> int:
    """
    Finds and returns the nth number in a sequence defined by:
      - For numbers less than 7, every number is counted.
      - For numbers >= 7, if the number is divisible by 7, it is skipped.
      - Otherwise, if the number is composite (i.e. it has a divisor other than 1 and itself), it is counted.
    
    This is one interpretation of the snippet.
    """
    count = 0
    i = 1
    while count < n:
        if i < 7:
            count += 1
        else:
            # Skip numbers divisible by 7.
            if i % 7 == 0:
                i += 1
                continue
            prime_flag = False  # Actually, true means composite.
            j = 2
            while j < i:
                if i % j == 0:
                    prime_flag = True
                    break
                j += 1
            if prime_flag:
                count += 1
                print("Counting:", i)
        if count == n:
            break
        i += 1
    return i


# --- Next Function Block ---


# -----------------------------------------------------
# Function 2: Process folder paths and select one per key.
def process_folders(folders: list) -> dict:
    """
    Processes a list of folder paths and builds a dictionary keyed by the first two characters.
    If a key already exists, the folder with the shorter path is kept; if equal, a new entry with the full
    folder string is added.
    
    Example:
      folders = ["/a","/a/b","/c/d","/c/d/e","/c/f"]
    """
    d = {}
    i = 0
    while i < len(folders):
        key = folders[i][:2]
        if key in d:
            # Keep the one with the shorter length
            if len(folders[i]) < len(d[key]):
                d[key] = folders[i]
            elif len(folders[i]) == len(d[key]):
                # In the snippet, a new key is added with folder itself.
                d[folders[i]] = folders[i]
        else:
            d[key] = folders[i]
        i += 1
    return d


# --- Next Function Block ---


# -----------------------------------------------------
# Function 3: Print binary representations of numbers.
def print_binary(nums: list) -> None:
    """
    Given a list of numbers, prints each number along with its binary representation.
    """
    i = 0
    while i < len(nums):
        print(bin(nums[i]), nums[i])
        i += 1


# --- Next Function Block ---


# -----------------------------------------------------
# Function 4: Calculate an expression using logarithms.
def calculate_expression(a: int, b: int) -> int:
    """
    If a is 0 and b is not, returns b.
    If b is 0 and a is not, returns a.
    Otherwise, computes int(math.log(math.exp(a) * math.exp(b))) which is equivalent to a+b.
    
    Example:
      a = 707, b = 2 → returns 709.
    """
    if a == 0 and b != 0:
        return b
    elif b == 0 and a != 0:
        return a
    else:
        return int(math.log(math.exp(a) * math.exp(b)))


# --- Next Function Block ---


# -----------------------------------------------------
# Function 5: Filter even numbers from a list.
def filter_evens(arr: list) -> list:
    """
    Returns a list of even numbers from the given list 'arr'.
    
    Example:
      arr = [1,2,3,4,5,6] → returns [2,4,6].
    """
    return list(filter(lambda x: x % 2 == 0, arr))


# --- Next Function Block ---


# -----------------------------------------------------
# Function 6: Find the maximum average subarray of length k.
def max_average_subarray(nums: list, k: int) -> float:
    """
    Finds the contiguous subarray of length k that has the maximum average.
    Prints the subarray each time a new maximum average is found.
    Returns the maximum average.
    
    Example:
      nums = [-1], k = 1.
    """
    max_avg = float('-inf')
    best_sub = None
    i = 0
    while i < len(nums) - k + 1:
        current_avg = sum(nums[i:i+k]) / k
        if current_avg > max_avg:
            max_avg = current_avg
            best_sub = nums[i:i+k]
            print("New best subarray:", best_sub)
        i += 1
    return max_avg


# --- Next Function Block ---


# -----------------------------------------------------
# Function 7: Binary search on a sorted list.
def binary_search(nums: list, target: int) -> int:
    """
    Performs a binary search on a sorted list 'nums' to find 'target'.
    Returns the index if found; otherwise, returns -1.
    
    Example:
      nums = [1,2,3,1], target = 2 → returns index 1.
    """
    start = 0
    end = len(nums) - 1
    while start <= end:
        mid = (start + end) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            start = mid + 1
        else:
            end = mid - 1
    return -1


# --- Next Function Block ---


# -----------------------------------------------------
# Function 8: Rank array elements.
def rank_array(arr: list) -> (list, dict):
    """
    Ranks the elements of 'arr' by sorting the unique values and mapping them to ranks starting at 1.
    Replaces each element in arr with its rank.
    
    Example:
      arr = [40,10,20,30] → returns ([4,1,2,3], {10: 1, 20: 2, 30: 3, 40: 4})
    """
    unique_sorted = sorted(set(arr))
    ranking = {val: idx + 1 for idx, val in enumerate(unique_sorted)}
    ranked_arr = [ranking[val] for val in arr]
    return ranked_arr, ranking


# --- Next Function Block ---


# -----------------------------------------------------
# Function 9: Evaluate a string expression.
def evaluate_expression(expr: str):
    """
    Evaluates a string expression using Python's eval.
    
    Example:
      expr = "-9.1234" → returns -9.1234.
    """
    return eval(expr)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 10: Reverse a subarray given left and right indices (1-indexed).
def reverse_subarray(head: list, left: int, right: int) -> list:
    """
    Reverses the subarray of 'head' from index left-1 to right-1 (inclusive).
    
    Example:
      head = [1,2,3,4,5,6,8], left = 2, right = 4 → returns [1,4,3,2,5,6,8].
    """
    left_idx = left - 1
    right_idx = right
    return head[:left_idx] + head[left_idx:right_idx][::-1] + head[right_idx:]


# --- Next Function Block ---


# -----------------------------------------------------
# Function 11: Merge two lists by inserting a segment.
def merge_lists(list1: list, list2: list, a: int, b: int) -> list:
    """
    Merges two lists by taking:
      - The first a elements from list1,
      - Then all elements from list2,
      - Then all elements from list1 after index b.
    
    Example:
      list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]
      Returns: list1[:3] + list2 + list1[b+1:].
    """
    return list1[:a] + list2 + list1[b+1:]


# --- Next Function Block ---





def a(n):
    for i in range(0,n+1):
        a = i
        for k in range(n-i):
            print(end=" ")
        b=False
        for j in range(1, 2*i-2):
            print(a, end="")
            if a<3:
                b=True
            if b:
                a+=1
            else:
                a-=1
        print("\r")


# --- Next Function Block ---


def b(n):
    for i in range(n+1):
        for j in range(n-i):
            print(end=" ")
        for k in range(2*i-1):
            if k==0 or k==2*i-2:
                print("*", end="")
            else:
                if i==n:
                    print("*", end="")
                else:
                    print(end=" ")
        print("\n")


# --- Next Function Block ---


def c(num):
    flag=False
    if num == 1:
        print("Not prime")
    elif num > 0:
        for i in range(2, num):
            if(num%i==0):
                flag=True
                break
        
    if flag:
        print("Not prime")
    else:
        print("Prime")


# --- Next Function Block ---


def d(n):

    for i in range(1,n+1):
        for k in range(n-i):
            print(end=" ")
        for j in range(1, i):
            print(j,end=" ")
        print(1)


# --- Next Function Block ---


def e(n):
    a=0
    for i in range(n):
        for j in range(i):
            a=a+1
            print(a,end=" ")
        print("\n")


# --- Next Function Block ---


def f(n):
    for i in range(1,n+1):
        for j in range(1,i+1):
            print(j,end=" ")
        print("\n")


# --- Next Function Block ---


def g(n):

    for i in range(n+1):
        for j in range(i*2):
            print("*",end=" ")
        for k in range(1):
            print("*",end=" ")
        print("\n")


# --- Next Function Block ---


def h(n):
    run=True
    for i in range(1, n+1):
        for j in range(1, n+1):
            if j>n-i:
                print("",j,end="")
            else:
                print(end=" ")
        print("\n")


# --- Next Function Block ---


def i(n):
    for i in range(1, n+1):
        for j in range(0, n+1):
            if j<i:
                print(end="  ")
            else:
                print(" *", end="")
        print("\n")


# --- Next Function Block ---


def j(n):
    for i in range(1, n+1):
        for j in range(n+1):
            if j>=i:
                print("*",end="")
            else:
                print(end=" ")
        print("\r")


# --- Next Function Block ---


def i(n):
    for i in range(1, n+1):
        for j in range(1,n+1):
            if j<=(n+1)-i:
                print("*",end="")
            else:
                print(end=" ")
        print("\n")


# --- Next Function Block ---



def display(limit):
    print("Crossroads")
    if limit > 1:
        display(limit - 1)


# --- Next Function Block ---

    

def j(n):
    for i in range(1, n+1):
        for j in range(1, i+1):
            if i==5 or j==1 or j==5:
                print("*", end=" ")
            else:
                print(end=" ")
        print(end="\n")


# --- Next Function Block ---


def k(n):
    for i in range(1, n+1):
        for j in range(1, n*2+1):
            if(j<=i or j>n*2-i):
                print("*",end=" ")
            else:
                print(end="  ")
        print("\n")


# --- Next Function Block ---


def l(n):
    for i in range(1, n*2+1):
        for j in range(1, i+1):
            if(j<=i and i<=n):
                print("*",end=" ")
            elif(j<=n*2-i):
                print("*", end=" ")
        
        print("\n")


# --- Next Function Block ---


def m(n):
    for i in range(1, n+1):
        for j in range(1, n+1):
            if j<=n-i:
                print(end=" ")
            elif i%2!=0:          
                print(i,end=" ")
        print("")


# --- Next Function Block ---


def n(n):
    for i in range(1, n+1):
        for k in range(1, n+2-i):
            print(end="  ")
        for j in range(1, 2*i):
            print(j,end=" ")
        
        print("\n")


# --- Next Function Block ---


def o(n):
    for i in range(1, n*2+1):
        for j in range(1, n+1):
            if j<=n+1-i and i<=n:
                print("*",end=" ")
            elif j<=i-n and i>n:
                print("*",end=" ")
        print("\r")


# --- Next Function Block ---


def p(n):
    for i in range(1, n+1):
        for j in range(1, n+1):
            if j<=i or j>n-i:
                print("*", end=" ")
            else:
                print(end="  ")
        print("\n")


# --- Next Function Block ---


def q(n):
    count = 1
    for i in range(0, n+1):
        for j in range(1, i+1):
            print(j, end=" ")
        print("1\n")


# --- Next Function Block ---


def r(n):
    for i in range(1, n+1):
        for j in range(1, i*2):
            print("*",end=" ")
        print("\n*\n*\n")


# --- Next Function Block ---


def s(n):
    for i in range(1, n+5):
        for j in range(1, 2*i):
            print("*",end=" ")
        print("\n")


# --- Next Function Block ---


def t(n):
    for i in range(1,n):
        for j in range(2,n):
            if j<=i or j>n-i:
                print("*", end=" ")
            else:
                print(end="  ")
        if i>=5:
            break
        print("\n")


# --- Next Function Block ---


def u(size):
    i=0
    j=0
    while i<=size:
        i=i+1
        while j<=size:
            j=j+1
            if j<=i or j>size-i:
                print("*", end=" ")
            else:
                print(end=" ")
            
        print("\n")


# --- Next Function Block ---


def v():
    print("Enter numbers")
    array = []

    for i in range(0,5):
        array.append(int(input()))
    count =0
    for i in range(4):
        for j in range(i,5):
            if(array[i]==array[j]):
                count = count+1
                print(i,j)
    print(count,"*")


# --- Next Function Block ---



class Solution:
    def isValid(self, s: str) -> bool:
        array=[]
        count=0
        if(len(s)%2==0):
            flag=True
            for i in s:
                array.append(i)
            i=0
            while i<len(array):
                if(i%2==0 and array[i]=="(" and array[i+1]==")" or array[i]=="[" and array[i+1]=="]" or array[i]=="{" and array[i+1]=="}" or i<=len(array)/2 and array[i]=="(" and array[(len(array)-1)-i]==")" or array[i]=="[" and array[(len(array)-1)-i]=="]" or array[i]=="{" and array[(len(array)-1)-i]=="}"):
                    if(ord(array[i+1])-ord(array[i])<5 and ord(array[i+1])-ord(array[i])>0):
                        i=i+1
                else:
                    print(i)
                    flag=False
                i=i+1
        else:
            flag=False
        if(flag):
            print(True)
        else:
            print(False)
    s="([])"
    isValid(0, s)

def w(nums1, nums2):
    m=0
    n=1
    k=0
    for i in range(m,m+n):
        nums1[i] = nums2[k]
        k=k+1
    for s in range((m+n)-1):
        for j in range(s+1, m+n):
            if(nums1[s]>nums1[j]):
                temp=nums1[s]
                nums1[s]=nums1[j]
                nums1[j]=temp


# --- Next Function Block ---


def y(x):
    a=str(x)
    array=[]
    isPalindrome=True
    for i in a:
        array.append(i)

    for i in range(len(array)):
        if(int(array[i])!=int(array[len(array)-1-i])):
            isPalindrome=False
    if(isPalindrome):
        print(True)
    else:
        print(False)

    def isPalindrome(x):
        return x == x[::-1]

    res=isPalindrome("122")
    print(res)


# --- Next Function Block ---


def y(nums):
    array=[]
    pos=[]
    for i in range(len(nums)-2):
        for j in range(i+1,len(nums)-1):
            for k in range(j+1,len(nums)):
                if((nums[i]+nums[j]+nums[k])==0 and i!=j and i!=k and j!=k):
                    if([nums[i],nums[j],nums[k]] or [nums[i],nums[k],nums[j]] or [nums[j],nums[i],nums[k]] or [nums[j],nums[k],nums[i]] or [nums[k],nums[i],nums[j]] or [nums[k],nums[j],nums[i]] in array):
                        pos.append([i,j,k])
                    else:
                        array.append([nums[i],nums[j],nums[k]])
    print(array,"\n")
    print(pos)


# --- Next Function Block ---


def z(x):

    val = set(x)
    st = list(val)
    print(st)

    s="fly me   to   the moon  "
    a=s[::-1]
    count=0
    alph=False
    for i in a:
        if i!=" ":
            alph=True
        if alph and i==" ":
            break
        if alph and i!=" ":
            count=count+1
    print(count)


# --- Next Function Block ---


def aa(n):
    i=n-1
    k=2
    pro=n
    val=n-k
    j=val-1
    den=val
    while i>0:
        pro=pro*i
        i=i-1
    while j>0:
        den=den*j
    if den==0:
        den=1
    print(pro/den)


# --- Next Function Block ---


def ab(s):
    resp=""
    spc=[",",".",";",":","-","_"]
    for i in s:
        if i!=" " and i not in spc:
            resp=resp+i
    resp=resp.lower()
    if resp==resp[::-1]:
        print( True)
    else:
        print( False,resp)


# --- Next Function Block ---


def ac(nums):
    array=[]
    for i in range(len(nums)):
        count=1
        for j in range(len(nums)):
            if(nums[i]==nums[j] and i!=j):
                count=count+1
        array.append(count)
    lar=array[0]
    pos=0
    for i in range(0,len(array)):
        if lar<array[i]:
            lar=array[i]
            pos=i
    print( lar)


# --- Next Function Block ---


def ad(array):
    val=2
    i=0
    while i<len(array)-k:
        if array[i]==val:
            array.pop(i)
            i=i-1
        i=i+1
    print(len(array), array)


# --- Next Function Block ---


def ae(array):
    count=0
    for i in range(len(array)):
        for j in range(len(array)):

            if(array[i]>array[j]):
                if(array[i]%2==0):
                    array[i]=int(array[i]/2)
                    array.insert(i+1, int(array[i]))
                else:
                    array[i]=int((array[i]+1)/2)-1
                    array.insert(i+1, int(array[i]+1))
    print(array)


# --- Next Function Block ---



def af(s):       
    array=[]
    stg=[]
    lar=0
    def ins(length, pos, val):
        for i in range(0,length):
            stg.insert(pos, val)
            pos=pos+1

    for i in range(len(s)):
        count=1
        for j in range(len(s)):
            if(s[i]==s[j] and i!=j):
                count=count+1
        array.append(count)

    for k in range(len(array)):
        if(array[k]%2==0):
            if(len(stg)==0):
                for i in range(array[k]):
                    stg.append(s[k])
            else:
                if(s[k] not in stg):
                    pos=int(len(stg)/2)
                    ins(array[k], pos, s[k])
        else:
            if(array[k]>lar):
                lar=array[k]
                val=k
    print(s[val])
    if(lar>0):
        if(lar==1):
            hlf=int(len(stg)/2)
            stg.insert(hlf, s[val])
        elif(len(stg)==0):
            for i in range(lar):
                stg.append(s[val])
        else:
            hlf=int(len(stg)/2)
            ins(lar, hlf, s[val])
    print(array)


# --- Next Function Block ---


def ag(s):
    dict={}
    array=[]
    lar=0
    def ins(length, pos, val):
        for i in range(0,length):
            array.insert(pos, val)
            pos=pos+1
    for i in range(len(s)):
        count=1
        for j in range(len(s)):
            if(s[i]==s[j] and i!=j):
                count=count+1
        dict={**dict, s[i]:count}
    for i in dict.keys():
        if(dict[i]%2==0):
            if(len(array)==0):
                for j in range(dict[i]):
                    array.append(i)
            else:
                pos=int(len(array)/2)
                ins(dict[i], pos, i)
        else:
            if(dict[i]>lar):
                lar=dict[i]
                val=i

    if(lar>0):
        if(lar==1):
            hlf=int(len(array)/2)
            array.insert(hlf, val)
        elif(len(array)==0):
            for i in range(lar):
                array.append(val)
        else:
            hlf=int(len(array)/2)
            ins(lar, hlf, val)

    print(dict)

    s_len = len(s)
    if s == s[::-1]:
        print(s_len)

    chars = {}
    palindrome_length = 0

    for n in s:
        if chars.get(n):
            chars[n] += 1
            if chars[n] % 2 == 0:
                palindrome_length += 2
        else:
            chars[n] = 1

    print(palindrome_length + 1 if s_len - palindrome_length != 0 else palindrome_length)


# --- Next Function Block ---


def ah(nums):
    size=0
    while size<len(nums):
        pos=size
        if(nums[size]==0):
            break
        size=(size+nums[size])
    if(size-pos+1==len(nums)):
        print (True)
    else:
        print (False)


# --- Next Function Block ---


def ai(s,t):
    same=True
    array=""
    lar=-1
    for i in range(0,len(s)):
        for j in range(0,len(t)):
            if(s[i] == t[j] and j>lar):
                array=array+s[i]
                if(j>lar):
                    lar=j
    if array == s:
        print(True)
    else:
        print(array)


# --- Next Function Block ---


def aj(x):
    res=0
    dict={'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}

    for i in s:
        res=res+dict[i]
    if(s[len(s)-2]=='I' and dict[s[len(s)-1]]>1):
        res=res-2

    print(res)


# --- Next Function Block ---


def ak(array):
    count=0
    size=len(array)-1
    for i in range(size):
        if(count>0 and array[i-1] == array[i]):
            array[i]=array[i+1]
            size=size-1
        print(array[i])
        count=count+1


# --- Next Function Block ---


# anagrams.py
def are_anagrams(s: str, t: str) -> bool:
    """
    Returns True if strings s and t have the same character frequencies.
    """
    if len(s) != len(t):
        return False

    sdict = {}
    tdict = {}

    for i in range(len(s)):
        scount = 1
        tcount = 1
        for j in range(len(s)):
            if i != j:
                if s[i] == s[j]:
                    scount += 1
                if t[i] == t[j]:
                    tcount += 1
        sdict[s[i]] = scount
        tdict[t[i]] = tcount

    return sdict == tdict


# --- Next Function Block ---


# dominoes.py
def count_domino_pairs(dominoes: list) -> int:
    """
    Counts the number of equivalent domino pairs.
    Dominoes are considered equivalent if their sorted values are equal.
    """
    domino_count = {}
    count = 0
    for domino in dominoes:
        # Sort to get a consistent representation
        sorted_domino = tuple(sorted(domino))
        if sorted_domino in domino_count:
            count += domino_count[sorted_domino]
            domino_count[sorted_domino] += 1
        else:
            domino_count[sorted_domino] = 1
    return count


# --- Next Function Block ---


# compare_sorted_numbers.py
def compare_sorted_lists(nums: list):
    """
    Returns a tuple (sorted_set, sorted_nums) if the set and list differ,
    otherwise returns False.
    """
    sorted_set = sorted(set(nums))
    nums_sorted = sorted(nums)
    if sorted_set == nums_sorted:
        return False
    else:
        return sorted_set, nums_sorted


# --- Next Function Block ---


# pascals_triangle.py
def generate_pascals_triangle(n: int) -> list:
    """
    Generates Pascal's triangle with n rows.
    """
    triangle = []
    for i in range(n):
        row = [1]
        if i > 0:
            last_row = triangle[-1]
            for j in range(1, i):
                row.append(last_row[j-1] + last_row[j])
            row.append(1)
        triangle.append(row)
    return triangle


# --- Next Function Block ---


# day_of_year.py
def day_of_year(date_str: str) -> int:
    """
    Given a date string in 'YYYY-MM-DD' format, returns its day-of-year.
    """
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    year, month, day = map(int, date_str.split("-"))
    day_count = sum(days_in_month[:month-1]) + day
    # Check for leap year: divisible by 4 and (not divisible by 100 or divisible by 400)
    if (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)) and month > 2:
        day_count += 1
    return day_count


# --- Next Function Block ---


# majority_element.py
def majority_element(nums: list):
    """
    Returns the element that occurs most frequently in nums.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    max_count = 0
    majority = None
    for num, count in freq.items():
        if count > max_count:
            max_count = count
            majority = num
    return majority


# --- Next Function Block ---


# tribonacci.py
def tribonacci(n: int) -> int:
    """
    Returns the (n+1)th Tribonacci number.
    Starting with trib[0]=0, trib[1]=0, trib[2]=1.
    """
    trib = [0, 0, 1]
    for i in range(2, n + 1):
        trib.append(trib[i-2] + trib[i-1] + trib[i])
    return trib[n+1]


# --- Next Function Block ---


# factorial_division.py
def compute_factorial_divided(n: int) -> int:
    """
    Computes (2*n)! divided by 2^n.
    """
    num = n * 2
    factorial = 1
    for i in range(num, 0, -1):
        factorial *= i
    return factorial // (2 ** n)


# --- Next Function Block ---


# min_frequency_element.py
def min_frequency_element(nums: list):
    """
    Returns the element with the minimum frequency in nums.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    min_count = float('inf')
    element = None
    for num, count in freq.items():
        if count < min_count:
            min_count = count
            element = num
    return element


# --- Next Function Block ---


# search_insert.py
def search_insert(nums: list, target: int):
    """
    Returns a tuple (position, new_list) where position is the index of target in the sorted list.
    If target is not in nums, it is inserted into the correct sorted position.
    """
    if target in nums:
        return nums.index(target), nums
    for i, num in enumerate(nums):
        if target < num:
            nums.insert(i, target)
            return i, nums
    nums.append(target)
    return len(nums) - 1, nums


# --- Next Function Block ---


# str_str.py
def find_substring(haystack: str, needle: str) -> int:
    """
    Returns the index of the first occurrence of needle in haystack, or -1 if not found.
    """
    return haystack.find(needle)


# --- Next Function Block ---




# patterns.py

def reverse_vowels(s: str) -> str:
    """
    Reverses only the vowels in the string.
    Example: "hello" -> "holle"
    """
    vowels = ['a','e','i','o','u','A','E','I','O','U']
    s_list = list(s)
    # Collect vowels in order.
    collected = [ch for ch in s_list if ch in vowels]
    # Reverse the collected vowels.
    collected = collected[::-1]
    idx = 0
    # Replace vowels in s_list with reversed ones.
    for i in range(len(s_list)):
        if s_list[i] in vowels:
            s_list[i] = collected[idx]
            idx += 1
    return "".join(s_list)


# --- Next Function Block ---



def sort_vowels_in_string(s: str) -> str:
    """
    Extracts vowels from s, sorts them (by ascii), then replaces vowels in order.
    Example: "lEetcOde" -> vowels sorted: ['E','O','e','o'] and then reinserted.
    """
    vowels = ['a','e','i','o','u','A','E','I','O','U']
    s_list = list(s)
    # Collect ascii codes of vowels.
    vowel_codes = [ord(ch) for ch in s_list if ch in vowels]
    vowel_codes.sort()
    sorted_vowels = "".join(chr(code) for code in vowel_codes)
    idx = 0
    res = ""
    for ch in s_list:
        if ch in vowels:
            res += sorted_vowels[idx]
            idx += 1
        else:
            res += ch
    return res


# --- Next Function Block ---



def unique_chars(s: str) -> str:
    """
    Returns a string made of unique characters in s (order arbitrary).
    Example: "pwwkew" -> a string with unique letters.
    """
    return "".join(set(s))


# --- Next Function Block ---



def reduce_value(n: float) -> float:
    """
    Divides n by 2 repeatedly until n <= 2.
    """
    while n > 2:
        n /= 2
    return n


# --- Next Function Block ---



def move_zeros_nested(nums: list) -> list:
    """
    Moves zeros in a list to the end using nested loops.
    Example: [0,0,1,0,3,12] becomes a list with non-zeros first.
    """
    nums = nums[:]  # copy to avoid mutation
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            if nums[i] == 0 and nums[j] != 0:
                nums[i], nums[j] = nums[j], 0
    return nums


# --- Next Function Block ---



def move_zeros_remove(nums: list) -> list:
    """
    Moves zeros to the end by removing and appending.
    Example: [0,1,0,3,12] becomes [1,3,12,0,0].
    """
    nums = nums[:]  # copy
    for i in nums[:]:
        if i == 0:
            nums.remove(i)
            nums.append(0)
    return nums


# --- Next Function Block ---



def combine_adjacent_equal(nums: list) -> list:
    """
    Combines two equal adjacent numbers by doubling the first and zeroing the second.
    Then moves zeros to the end.
    Example: [1,2,2,1,1,0] --> after combination and shifting zeros.
    """
    nums = nums[:]  # copy
    for i in range(len(nums)-1):
        if nums[i] == nums[i+1]:
            nums[i] *= 2
            nums[i+1] = 0
    # Remove zeros and append them at the end.
    result = [num for num in nums if num != 0]
    result.extend([0] * (len(nums) - len(result)))
    return result


# --- Next Function Block ---



def int_to_roman(num: int) -> str:
    """
    Converts an integer to a Roman numeral string.
    """
    mapping = {1000:'M', 500:'D', 100:'C', 50:'L', 10:'X', 5:'V', 1:'I'}
    out = ""
    n = num
    while n > 0:
        if n >= 1000:
            n -= 1000
            out += mapping[1000]
        elif n >= 900:
            n -= 900
            out += mapping[100] + mapping[1000]
        elif n >= 500:
            n -= 500
            out += mapping[500]
        elif n >= 400:
            n -= 400
            out += mapping[100] + mapping[500]
        elif n >= 100:
            n -= 100
            out += mapping[100]
        elif n >= 90:
            n -= 90
            out += mapping[10] + mapping[100]
        elif n >= 50:
            n -= 50
            out += mapping[50]
        elif n >= 40:
            n -= 40
            out += mapping[10] + mapping[50]
        elif n >= 10:
            n -= 10
            out += mapping[10]
        elif n >= 9:
            n -= 9
            out += mapping[1] + mapping[10]
        elif n >= 5:
            n -= 5
            out += mapping[5]
        elif n >= 4:
            n -= 4
            out += mapping[1] + mapping[5]
        else:
            n -= 1
            out += mapping[1]
    return out


# --- Next Function Block ---



def multiply_str_numbers(num1: str, num2: str) -> int:
    """
    Converts two string numbers to integers and returns their product.
    """
    return int(num1) * int(num2)


# --- Next Function Block ---



def min_diff_pair(arr: list) -> list:
    """
    Given a sorted array, finds and returns the pair of numbers with the minimum difference.
    """
    arr = sorted(arr)
    diffs = []
    pairs = []
    for i in range(len(arr)-1):
        diff = arr[i+1] - arr[i]
        diffs.append(diff)
        pairs.append([arr[i], arr[i+1]])
    min_diff = min(diffs) if diffs else None
    for pair in pairs:
        if pair[1] - pair[0] == min_diff:
            return pair
    return []


# --- Next Function Block ---



def insert_zeros_after_even(nums: list) -> list:
    """
    Inserts two zeros immediately after every even number in the list.
    """
    i = 0
    nums = nums[:]  # copy
    while i < len(nums):
        if nums[i] % 2 == 0:
            nums.insert(i+1, 0)
            nums.insert(i+2, 0)
            i += 3
        else:
            i += 1
    return nums


# --- Next Function Block ---



def remove_two_after_condition(arr: list) -> list:
    """
    If an element in arr is divisible by 5 and there's a next element, remove the next two elements.
    (Note: This logic is based on the given code and may remove fewer than two if not available.)
    """
    arr = arr[:]  # copy
    i = 0
    while i < len(arr) - 1:
        if arr[i] % 5 == 0:
            # Remove next two elements if possible.
            if i+1 < len(arr):
                arr.pop(i+1)
            if i+1 < len(arr):
                arr.pop(i+1)
        i += 1
    return arr


# --- Next Function Block ---



def check_coordinate_difference(coordinates: list) -> bool:
    """
    Given a list of [x,y] coordinates, attempts to check if the differences between consecutive coordinates are consistent.
    (The original logic is ambiguous; this function mimics the provided approach.)
    """
    if not coordinates:
        return True
    diff = coordinates[0][0] - coordinates[0][1]
    diffx = []
    diffy = []
    h = 0
    out = True
    for i in range(len(coordinates)):
        k = coordinates[i]
        if i < len(coordinates) - 1:
            l = coordinates[i+1]
        for j in range(len(k) - 1):
            if diff:
                if k[0] - k[1] == diff:
                    if i < len(coordinates) - 1:
                        diffx.append(l[0] - k[0])
                        diffy.append(l[1] - k[1])
                        if h > 0 and diffx[h-1] == diffx[h] and diffy[h-1] == diffy[h]:
                            h += 1
                        elif diff != 0 and diffx[h] % diff == 0 and diffy[h] % diff == 0:
                            h += 1
                        else:
                            out = False
                            break
                else:
                    out = False
                    break
            else:
                diff = k[0] - k[1]
    return out


# --- Next Function Block ---



def max_profit_difference(arr: list) -> int:
    """
    Given a list of prices (or similar), finds the pair with the minimum difference and returns the difference between sell and buy.
    If the difference is negative, returns 0.
    (Logic based on the provided snippet.)
    """
    diff_map = {}
    for i in range(len(arr)-1):
        minval = arr[0]  # initial min value difference (this logic is ambiguous)
        for j in range(i+1, len(arr)):
            if arr[i] - arr[j] < minval:
                minval = arr[i] - arr[j]
                buyval = arr[i]
                sellval = arr[j]
        diff_map[minval] = [buyval, sellval]
    key = min(diff_map) if diff_map else 0
    val = diff_map.get(key, [0, 0])
    res = val[1] - val[0]
    if res <= 0:
        res = 0
    return res


# --- Next Function Block ---



def find_min_in_list(arr: list) -> int:
    """
    Returns the minimum value in the list.
    """
    if not arr:
        return None
    min_val = arr[0]
    for i in arr:
        if i < min_val:
            min_val = i
    return min_val


# --- Next Function Block ---



def print_star_pattern():
    """
    Prints a pattern:
    For each i from 1 to 3:
      - Print a line with '*' (with newline)
      - Then print i blocks of a square pattern where each block is a row of i stars repeated 'size' times.
      'size' doubles for each i.
    """
    size = 2
    for i in range(1, 4):
        # Print i lines with "*"
        for j in range(i):
            print("*")
        # Print square blocks
        for k in range(i):
            for l in range(size):
                print("*", end=" ")
            print()  # new line after each block row
        size *= 2


# --- Next Function Block ---




# patterns.py

def symmetric_differences(arr: list) -> list:
    """
    Given an array, computes absolute differences between elements
    from the start and end moving inward.
    Example:
      Input: [7,3,5,2,10,6,8,1,4,9]
      Output: list of differences for first half of array with corresponding symmetric elements.
    """
    size = len(arr)
    diff = []
    i, n = 0, size - 1
    for _ in range(size // 2):
        # If indices cross, break (though loop is already half-length)
        if i == n:
            break
        diff.append(abs(arr[i] - arr[n]))
        i += 1
        n -= 1
    return diff


# --- Next Function Block ---



def product_minus_sum(n: int) -> int:
    """
    Converts an integer to string, computes the product of its digits,
    the sum of its digits, and returns (product - sum).
    Example: n=234 -> (2*3*4) - (2+3+4) = 24 - 9 = 15
    """
    s = str(n)
    prod = 1
    total = 0
    for ch in s:
        digit = int(ch)
        total += digit
        prod *= digit
    return prod - total


# --- Next Function Block ---



def sum_of_multiples(n: int) -> int:
    """
    Sums all numbers in the range [1, n) that are divisible by 3, 5, or 7.
    Example: n=7 sums numbers in 1...6 meeting the condition.
    """
    total = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0 or i % 7 == 0:
            total += i
    return total


# --- Next Function Block ---



def nine_minus_one(n: int) -> int:
    """
    For a given integer n, creates a number with the same number of digits all '9's
    and a number with the same number of digits all '1's, then returns their difference.
    Example: n=555 -> "999" - "111" = 888.
    """
    s = str(n)
    large = int("9" * len(s))
    small = int("1" * len(s))
    return large - small


# --- Next Function Block ---



def product_of_list(nums: list, verbose: bool = False) -> int:
    """
    Multiplies the numbers in the list (iterating in reverse order).
    Optionally prints each number.
    """
    product = 1
    for num in nums[::-1]:
        if verbose:
            print(num)
        product *= num
    return product


# --- Next Function Block ---



def longest_common_prefix(strs: list) -> str:
    """
    Returns the longest common prefix among the list of strings.
    If there is none, returns an empty string.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        # Shorten the prefix until s starts with it
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def max_right(arr: list) -> list:
    """
    Given an array, returns a new list where each element at index i is
    replaced by the maximum element to its right; the last element is -1.
    Example: [7,3,5,2,10] -> [10,10,10,10,-1]
    """
    size = len(arr)
    if size == 0:
        return []
    result = [None] * size
    result[-1] = -1
    max_so_far = arr[-1]
    for i in range(size - 2, -1, -1):
        if arr[i] > max_so_far:
            max_so_far = arr[i]
        result[i] = max_so_far
    return result


# --- Next Function Block ---



def generate_random_array(n: int) -> tuple:
    """
    Generates an array of n-1 distinct random integers between -n and n (excluding 0),
    then appends -sum(array) if not already present, or adjusts if it is.
    Returns a tuple: (array, count, -count), where count is the sum of the initial array.
    """
    import random
    array = []
    count = 0
    while len(array) < n - 1:
        val = random.randint(-n, n)
        if val not in array and val != 0:
            array.append(val)
            count += val
    if -count not in array:
        array.append(-count)
    else:
        idx = array.index(-count)
        array[idx] = 0
        array.append(-count + (-count))
    return array, count, -count


# --- Next Function Block ---



def modify_number(num: int) -> int:
    """
    Given a number, replaces the first digit that is less than 9 with 9.
    Then, in a while loop, if a digit (starting from the right) equals 6,
    adds 3 times its positional value to the original number and stops.
    Returns the modified number.
    """
    s = str(num)
    ret = ""
    ins = True
    for ch in s:
        digit = int(ch)
        if digit < 9 and ins:
            ret += "9"
            ins = False
        else:
            ret += ch
    modified = int(ret)
    
    # Process digits from right side
    temp = num
    count = 0
    while temp > 1:
        if temp % 10 == 6:
            modified += 3 * (10 ** count)
            break
        count += 1
        temp //= 10
    return modified


# --- Next Function Block ---



def pascal_row(row_index: int) -> list:
    """
    Returns the row_index-th row of Pascal's Triangle.
    Example: row_index=0 returns [1], row_index=1 returns [1,1], etc.
    """
    triangle = []
    for i in range(row_index + 1):
        row = [1]
        if i > 0:
            prev = triangle[-1]
            for j in range(1, i):
                row.append(prev[j-1] + prev[j])
            row.append(1)
        triangle.append(row)
    return triangle[row_index]


# --- Next Function Block ---



def min_max_game(nums: list) -> int:
    """
    Given a list of numbers, repeatedly perform the following:
      - Partition the list into pairs.
      - For each pair, if it's the turn for 'min', choose the minimum; otherwise, choose the maximum.
      - Continue until one number remains.
    Returns the final number.
    """
    turn = True  # True means take min, False means take max.
    while len(nums) > 1:
        new_nums = []
        for i in range(0, len(nums) - 1, 2):
            if turn:
                new_nums.append(min(nums[i], nums[i+1]))
            else:
                new_nums.append(max(nums[i], nums[i+1]))
            turn = not turn
        if len(nums) % 2 == 1:
            new_nums.append(nums[-1])
        nums = new_nums
    return nums[0]


# --- Next Function Block ---



def chunk_string(s: str, k: int) -> list:
    """
    Splits the string s into chunks of length k.
    The final chunk may be shorter if s is not divisible by k.
    """
    return [s[i:i+k] for i in range(0, len(s), k)]


# --- Next Function Block ---



def min_max_game_progression(nums: list) -> list:
    """
    Implements the Min Max Game (LeetCode #2293) and returns all intermediate lists.
    """
    result = [nums]
    flag = True
    while len(result[-1]) > 1:
        current = result[-1]
        new_list = []
        i = 0
        while i < len(current) - 1:
            if flag:
                new_list.append(min(current[i], current[i+1]))
            else:
                new_list.append(max(current[i], current[i+1]))
            flag = not flag
            i += 2
        result.append(new_list)
    return result


# --- Next Function Block ---



def most_frequent(nums: list):
    """
    Returns the most frequent element in the list.
    """
    freq = {}
    max_count = 0
    max_elem = None
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
        if freq[num] > max_count:
            max_count = freq[num]
            max_elem = num
    return max_elem


# --- Next Function Block ---



def compute_ranks(arr: list) -> list:
    """
    Computes the rank for each element in the original array.
    Rank is defined as:
       - Unique elements are sorted.
       - The rank is 1 for the smallest element, 2 for the next, etc.
    Returns a list of ranks corresponding to the original array.
    """
    sorted_unique = sorted(set(arr))
    rank_dict = {num: rank+1 for rank, num in enumerate(sorted_unique)}
    return [rank_dict[num] for num in arr]


# --- Next Function Block ---



def print_symmetric_pairs(s: str) -> None:
    """
    Prints pairs of characters from the string: first with last, second with second-last, etc.
    """
    size = len(s)
    for i in range(size // 2):
        print(s[i], s[size - 1 - i])


# --- Next Function Block ---



def max_area(height: list) -> int:
    """
    Given a list of heights, returns the maximum area formed by two indices,
    defined as min(height[i], height[j]) * (j - i). (O(n^2) brute force approach.)
    """
    max_area_val = 0
    size = len(height)
    for i in range(size - 1):
        for j in range(i + 1, size):
            area = min(height[i], height[j]) * (j - i)
            if area > max_area_val:
                max_area_val = area
    return max_area_val


# --- Next Function Block ---




# patterns.py

# 1. Happy Number Check (using sum of squares of digits)
def is_happy(n: int, max_iter: int = 100) -> bool:
    """
    Determines if a number is "happy". A number is happy if repeatedly replacing
    it with the sum of the squares of its digits eventually leads to 1.
    """
    for _ in range(max_iter):
        s = str(n)
        total = sum(int(ch) ** 2 for ch in s)
        n = total
        if n == 1:
            return True
    return False


# --- Next Function Block ---


# 2. k Least Ones Rows in a Binary Matrix
def k_least_ones_rows(mat: list, k: int) -> list:
    """
    Given a binary matrix, counts the number of 1's in each row and returns
    the indices of the k rows with the fewest 1's.
    """
    row_counts = {i: sum(row) for i, row in enumerate(mat)}
    sorted_rows = sorted(row_counts.items(), key=lambda x: x[1])
    return [i for i, _ in sorted_rows[:k]]


# --- Next Function Block ---


# 3. Check if s is a Subsequence of t
def is_subsequence(s: str, t: str) -> bool:
    """
    Returns True if s is a subsequence of t.
    """
    pos = 0
    for char in s:
        pos = t.find(char, pos)
        if pos == -1:
            return False
        pos += 1
    return True


# --- Next Function Block ---


# 4. Digit Root (Repeated sum of digits until single digit)
def digit_root(n: int) -> int:
    """
    Repeatedly sums the digits of n until a single digit is obtained.
    """
    while n >= 10:
        n = sum(int(d) for d in str(n))
    return n


# --- Next Function Block ---


# 5. Count Numbers Smaller Than Current
def count_smaller_numbers(nums: list) -> list:
    """
    For each number in nums, counts how many numbers in nums are smaller.
    """
    result = []
    for i in range(len(nums)):
        count = sum(1 for j in range(len(nums)) if nums[i] > nums[j])
        result.append(count)
    return result


# --- Next Function Block ---


# 6. Intersection of Two Lists (unique common elements)
def intersection(nums1: list, nums2: list) -> list:
    """
    Returns a list of unique elements common to both nums1 and nums2.
    """
    return list(set(nums1).intersection(set(nums2)))


# --- Next Function Block ---


# 7. Palindrome Check
def is_palindrome(s: str) -> bool:
    """
    Returns True if s is a palindrome.
    """
    return s == s[::-1]


# --- Next Function Block ---


# 8. Interleave Two Strings
def interleave_strings(word1: str, word2: str) -> str:
    """
    Interleaves characters of word1 and word2. If one word is longer,
    appends the remainder at the end.
    """
    result = []
    max_len = max(len(word1), len(word2))
    for i in range(max_len):
        if i < len(word1):
            result.append(word1[i])
        if i < len(word2):
            result.append(word2[i])
    return "".join(result)


# --- Next Function Block ---


# 9. Maximum Sum with Reversed Numbers
def max_sum_with_reversed(nums: list) -> int:
    """
    For each number in nums that has more than one digit, reverse its digits.
    If the reversed number is also in nums, track the maximum sum of the original
    and reversed numbers.
    """
    max_sum = -1
    for num in nums:
        s = str(num)
        if len(s) > 1:
            rev = int(s[::-1])
            if rev in nums:
                max_sum = max(max_sum, num + rev)
    return max_sum


# --- Next Function Block ---


# 10. Alternate Rearrangement of Characters
def alternate_rearrange(s: str) -> str:
    """
    Rearranges characters from s by alternating from a sorted list of unique characters,
    decrementing their frequency until the result's length equals the original.
    (This mimics a complex custom ordering from the provided snippet.)
    """
    freq = {}
    for ch in s:
        freq[ch] = freq.get(ch, 0) + 1
    unique_chars = sorted(set(s))
    result = ""
    i = 0
    reverse = False
    const = False
    while len(result) < len(s) and unique_chars:
        # If the current character is exhausted, remove it.
        if freq[unique_chars[i]] <= 0:
            unique_chars.pop(i)
            if not unique_chars:
                break
            i = len(unique_chars)-1 if reverse else 0
            continue
        result += unique_chars[i]
        freq[unique_chars[i]] -= 1
        # Toggle direction at boundaries.
        if i == 0:
            reverse = False
        elif i == len(unique_chars) - 1:
            reverse = True
        const = True
        if len(unique_chars) <= 1:
            i = 0
        elif reverse:
            i -= 1
        else:
            i += 1
    return result


# --- Next Function Block ---


# 11. Count Pairs with Sum Less Than Target
def count_pairs_with_sum_less_than(nums: list, target: int) -> int:
    """
    Counts the number of unique pairs (i, j) with i < j such that the sum is less than target.
    """
    count = 0
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            if nums[i] + nums[j] < target:
                count += 1
    return count


# --- Next Function Block ---


# 12. Count Pairs with Sum in [lower, upper]
def count_pairs_in_range(nums: list, lower: int, upper: int) -> int:
    """
    Counts the number of unique pairs (i, j) with i < j such that the sum is between lower and upper (inclusive).
    """
    count = 0
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            s = nums[i] + nums[j]
            if lower <= s <= upper:
                count += 1
    return count


# --- Next Function Block ---


# 13. Check First Letters of Words Against a String
def check_first_letters(words: list, s: str) -> bool:
    """
    Checks if the first letter of each word in words matches the corresponding character in s.
    Returns False if lengths differ.
    """
    if len(words) != len(s):
        return False
    for i in range(len(words)):
        if words[i][0] != s[i]:
            return False
    return True


# --- Next Function Block ---


# 14. Count Unique Numbers in Intervals
def count_unique_numbers_in_intervals(intervals: list) -> int:
    """
    Given a list of intervals [start, end], counts the number of unique integers in all intervals.
    """
    unique_nums = set()
    for start, end in intervals:
        unique_nums.update(range(start, end + 1))
    return len(unique_nums)


# --- Next Function Block ---


# 15. Return Length of List
def list_length(lst: list) -> int:
    """
    Returns the length of lst.
    """
    return len(lst)


# --- Next Function Block ---


# 16. Create Target Array in Given Order
def create_target_array(nums: list, index: list) -> list:
    """
    Given two lists, nums and index, inserts each element from nums into a target list at the corresponding index.
    """
    target = []
    for num, idx in zip(nums, index):
        target.insert(idx, num)
    return target


# --- Next Function Block ---


# 17. Common Divisors of Two Numbers
def common_divisors(a: int, b: int) -> list:
    """
    Returns a list of common divisors of a and b.
    """
    c = a if a < b else b
    divisors = []
    for i in range(1, c + 1):
        if a % i == 0 and b % i == 0:
            divisors.append(i)
    return divisors


# --- Next Function Block ---


# 18. ID with Maximum Gap in Logs
def id_of_max_gap(logs: list) -> int:
    """
    Given logs as [id, time] pairs, returns the id corresponding to the maximum gap between times.
    Assumes logs are ordered by time.
    """
    kdiff = 0
    selected_id = 0
    pos = 0
    for log in logs:
        current_id, time = log
        gap = time - pos
        if gap > kdiff:
            kdiff = gap
            selected_id = current_id
        pos = time
    return selected_id


# --- Next Function Block ---


# 19. Print Negative Pairs
def print_negative_pairs(nums: list) -> None:
    """
    For each number in nums, if its negative exists in nums, prints the negative value with a tag.
    """
    nums_sorted = sorted(nums, reverse=True)
    for num in nums_sorted:
        if -num in nums:
            print(-num, "9")


# --- Next Function Block ---


# 20. Power Calculation
def power(x: float, n: int) -> float:
    """
    Returns x raised to the power n.
    """
    return x ** n


# --- Next Function Block ---


# 21. Range Count
def range_count(low: int, high: int) -> int:
    """
    Returns the difference between high and low.
    """
    return high - low


# --- Next Function Block ---


# 22. Average of Salaries
def average_salary(salaries: list) -> float:
    """
    Returns the average of the salaries in the list.
    """
    return sum(salaries) / len(salaries) if salaries else 0


# --- Next Function Block ---


# 23. Rotate Array Right by k
def rotate_right(nums: list, k: int) -> list:
    """
    Rotates the list nums to the right by k positions.
    """
    n = len(nums)
    k = k % n  # Handle cases where k >= n
    return nums[-k:] + nums[:-k]


# --- Next Function Block ---


# 24. Element Equal to Its Frequency
def element_equal_to_frequency(arr: list) -> int:
    """
    Returns the first element whose value equals its frequency in the array.
    If none exists, returns -1.
    """
    freq = {}
    for num in arr:
        freq[num] = freq.get(num, 0) + 1
    for num in arr:
        if num == freq[num]:
            return num
    return -1


# --- Next Function Block ---


# 25. Longest Repeating Character Substring Length
def longest_repeating_substring_length(s: str) -> int:
    """
    Returns the length of the longest substring of s consisting of the same character.
    """
    if not s:
        return 0
    max_len = 1
    current_len = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_len += 1
        else:
            max_len = max(max_len, current_len)
            current_len = 1
    return max(max_len, current_len)


# --- Next Function Block ---


# 26. Get Dictionary Keys
def get_dict_keys(d: dict) -> list:
    """
    Returns a list of keys in dictionary d.
    """
    return list(d.keys())


# --- Next Function Block ---


# 27. Demonstrate Abstract Base Classes
from abc import ABC, abstractmethod
class A(ABC):
    @abstractmethod
    def printf(self):
        pass

class B(A):
    def printf(self):
        print("Hi from B")
    def Scan(self):
        print("Hey")

def test_inheritance():
    """
    Demonstrates inheritance using abstract base classes.
    """
    obj = B()
    obj.printf()
    obj.Scan()


# --- Next Function Block ---


# 28. Custom Fibonacci Variant (starting with [1,2])
def custom_fib(n: int) -> int:
    """
    Returns the nth element in a Fibonacci-like sequence starting with 1 and 2.
    """
    if n == 1:
        return 1
    if n == 2:
        return 2
    seq = [1, 2]
    for i in range(2, n):
        seq.append(seq[-1] + seq[-2])
    return seq[-1]


# --- Next Function Block ---


# 29. Vehicle Class with Destructor
class Vehicle:
    def __init__(self):
        print("Vehicle created.")
    def __del__(self):
        print("Destructor called, vehicle deleted.")
    def display(self):
        print("Hello")

def test_vehicle_class():
    """
    Creates a Vehicle instance, calls display, then deletes it.
    """
    car = Vehicle()
    car.display()
    del car


# --- Next Function Block ---


# 30. Most Frequent Element in a List
def most_frequent_element(nums: list) -> int:
    """
    Returns the element with the highest frequency in nums.
    """
    freq = {}
    max_count = 0
    max_elem = None
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
        if freq[num] > max_count:
            max_count = freq[num]
            max_elem = num
    return max_elem
