

# --- Next Function Block ---

import re
import math
from abc import ABC, abstractmethod
from collections import Counter
import functools
import string
import random

class A:
    def print():
        pass
# -----------------------------------------------------
# Function 1: Insertion sort (in-place) using insertion‐like algorithm.
def insertion_sort(arr: list) -> list:
    """
    Sorts the list 'arr' using a variant of insertion sort.
    
    Example:
      Input: [4, 2, 1, 3]
      Output: [1, 2, 3, 4]
    """
    head = arr.copy()
    i = 1
    while i < len(head):
        if head[i] < head[i - 1]:
            j = i - 1
            # Move left until we find a position where head[i] is not less.
            while j >= 0 and head[i] < head[j]:
                j -= 1
            # Insert head[i] at the correct position.
            head.insert(j + 1, head[i])
            # Remove the duplicate element (since head[i] was shifted).
            del head[i + 1]
        else:
            i += 1
    return head


# --- Next Function Block ---


# -----------------------------------------------------
# Function 2: Pairwise swap (inserting elements from end into the middle)
def pairwise_swap(head: list) -> list:
    """
    Given a list 'head', inserts elements from the end into the middle positions.
    The snippet shows inserting element at the end at index i and then removing the duplicate.
    
    Example:
      Input: [1]
      Output: [1]  (For a single element, nothing changes.)
    """
    head = head.copy()
    i = 1
    j = len(head) - 1
    while j > i:
        head.insert(i, head[j])
        del head[j + 1]
        i += 2
    return head


# --- Next Function Block ---


# -----------------------------------------------------
# Function 3: Demonstrate closure with a global variable.
def demonstrate_closure() -> None:
    """
    Demonstrates variable lookup in a closure by printing a global variable.
    """
    def f():
        print(x)
    x = 1
    f()


# --- Next Function Block ---


class A:
    def print():
        pass

# -----------------------------------------------------
# Function 4: Rotate a list by k positions (to the right).
def rotate_list(head: list, k: int) -> list:
    """
    Rotates the list 'head' to the right by k positions.
    
    Example:
      head = [0,1,2], k = 3
      Since k % len(head) == 0, the rotated list is the same.
    """
    n = len(head)
    if n == 0:
        return head
    k = k % n
    # Using slicing for rotation:
    return head[-k:] + head[:-k]


# --- Next Function Block ---


# -----------------------------------------------------
# Function 5: Count distinct substrings in a reversed string.
def count_distinct_substrings(s: str) -> int:
    """
    Reverses the string s, then counts distinct substrings generated by
    expanding from each character.
    
    Note: The original snippet is ambiguous; this function uses a simple
    method to count all distinct substrings.
    """
    s = s[::-1]
    substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substrings.add(s[i:j])
    return len(substrings)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 6: Append text to a file and then read its contents.
def append_and_read_file(filename: str, text: str) -> None:
    """
    Appends 'text' to the file 'filename' and then prints its contents.
    """
    with open(filename, "a") as f:
        f.write(text)
    with open(filename, "r") as f:
        for line in f:
            print(line, end="")


# --- Next Function Block ---


# -----------------------------------------------------
# Function 7: Print numbers missing in a list.
def get_missing_numbers(arr: list) -> list:
    """
    Given a list 'arr', prints and returns numbers in range [0, max(arr))
    that are not present in arr.
    """
    missing = []
    for i in range(max(arr)):
        if i not in arr:
            missing.append(i)
    return missing


# --- Next Function Block ---


# -----------------------------------------------------
# Function 8: Reverse a subarray between two 1-indexed positions.
def reverse_subarray(head: list, left: int, right: int) -> list:
    """
    Reverses a portion of the list 'head' from index left-1 to right-1 (inclusive).
    
    Example:
      head = [1,2,3,4,5,6,8], left = 2, right = 4
      Output: [1, 4, 3, 2, 5, 6, 8]
    """
    # Convert left and right to 0-indexed.
    left_idx = left - 1
    right_idx = right
    new_list = head[:left_idx] + head[left_idx:right_idx][::-1] + head[right_idx:]
    return new_list


# --- Next Function Block ---


# -----------------------------------------------------
# Function 9: Print increasing slices of a list.
def print_increasing_slices(head: list) -> None:
    """
    For each index i in head, prints the slice head[i:j] where j increases based on a rule.
    (The original snippet increases j by j-i each iteration.)
    """
    i = 0
    j = 1
    while i < len(head):
        print(head[i:j])
        i += 1
        j += (j - i)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 10: Remove up to k occurrences across groups and return distinct group count.
def remove_k_occurrences(arr: list, k: int) -> int:
    """
    Counts the occurrences of each element in arr and then “removes” up to k occurrences across groups.
    Returns the number of groups (distinct elements) remaining after removals.
    
    This function uses the Counter to get counts, then iterates through the sorted counts.
    (Based on snippet logic, returns len(count) - j, where j is incremented when count goes below 1.)
    """
    counts = dict(sorted(Counter(arr).items(), key=lambda item: item[1]))
    j = 0
    flag = False
    for key in counts:
        while counts[key] > 0:
            if k > 0:
                counts[key] -= 1
                k -= 1
                if counts[key] < 1:
                    j += 1
            else:
                flag = True
                break
        if flag:
            break
    return len(counts) - j


# --- Next Function Block ---


# -----------------------------------------------------
# Function 11: Reverse chunks of a list (based on index modulus k).
def reverse_chunks(arr: list, k: int) -> list:
    """
    Divides the list 'arr' into chunks of size k and reverses each chunk.
    If the last chunk is smaller than k, leaves it as is.
    
    Example:
      arr = [1,2,3,4], k = 2 → returns [2,1,4,3]
    """
    result = []
    for i in range(0, len(arr), k):
        chunk = arr[i:i+k]
        if len(chunk) == k:
            result.extend(chunk[::-1])
        else:
            result.extend(chunk)
    return result


# --- Next Function Block ---


# -----------------------------------------------------
# Function 12: Transform list by conditional chunk reversal.
def transform_list_by_chunks(arr: list) -> list:
    """
    Transforms the list 'arr' by taking chunks (whose size depends on a changing parameter k)
    and reverses the chunk if its length is even, otherwise leaves it as is.
    
    The update of the start index uses the rule i = k*k - i and increments k by 1 each iteration.
    (This is one interpretation of the snippet.)
    """
    nums = []
    i = 0
    k = 1
    n = len(arr)
    while i < n:
        # Determine chunk size as k; slice from i to i+k.
        chunk = arr[i:i+k]
        if len(chunk) % 2 == 0:
            nums.extend(chunk[::-1])
        else:
            nums.extend(chunk)
        # Update i as shown in snippet: i = k*k - i.
        i = k * k - i
        k += 1
    return nums


# --- Next Function Block ---


# -----------------------------------------------------
# Function 13: Remove elements until list is sorted.
def remove_until_sorted(nums: list) -> (list, int):
    """
    Repeatedly removes an element that is out of order until the list is sorted.
    Returns a tuple of (final sorted list, number of iterations).
    
    Example:
      nums = [4,5,7,7,13]
    """
    count = 0
    while nums != sorted(nums):
        i = 0
        while i < len(nums) - 1:
            if nums[i+1] < nums[i]:
                del nums[i+1]
            else:
                i += 1
        count += 1
    return nums, count


# --- Next Function Block ---


# -----------------------------------------------------
# Function 14: Count common elements in two lists.
def count_common_elements(head: list, nums: list) -> int:
    """
    Counts how many elements in 'head' are also present in 'nums'.
    
    Example:
      head = [0,1,2,3], nums = [0,1,3] → returns 3.
    """
    count = 0
    for item in head:
        if item in nums:
            count += 1
    return count


# --- Next Function Block ---


# -----------------------------------------------------
# Function 15: Length of sublist after the maximum element.
def length_after_max(head: list) -> int:
    """
    Returns the length of the sublist after the maximum element in head.
    
    Example:
      head = [5,2,13] → maximum is 13 at index 2, so returns len(head) - 3 = 0.
    """
    if not head:
        return 0
    max_val = max(head)
    max_index = head.index(max_val)
    return len(head) - (max_index + 1)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 16: Maximum reachable index with given bricks and ladders.
def max_reachable_index(heights: list, bricks: int, ladders: int) -> int:
    """
    Simulates moving from the first building to subsequent buildings using bricks and ladders.
    For each step, if the next building is higher, uses bricks (or ladders if insufficient bricks).
    Returns the maximum index reached (0-indexed).
    
    Example:
      heights = [14,3,19,3], bricks = 17, ladders = 0.
    """
    i = 0
    while i < len(heights) - 1:
        diff = heights[i+1] - heights[i]
        if diff > 0:
            if diff > bricks and ladders > 0:
                ladders -= 1
            elif diff <= bricks:
                bricks -= diff
            else:
                break
        i += 1
    return i


# --- Next Function Block ---


# -----------------------------------------------------
# Function 17: Insert GCD between adjacent elements.
def insert_gcd_between_adjacent(arr: list) -> list:
    """
    For each pair of adjacent elements in arr, computes their GCD and inserts it between them.
    
    Example:
      arr = [18,6,10,3] 
      Returns a new list with the GCD inserted between adjacent pairs.
    """
    def gcd(a, b):
        return math.gcd(a, b)
    res = []
    for i in range(len(arr)-1):
        res.append(arr[i])
        res.append(gcd(arr[i], arr[i+1]))
    res.append(arr[-1])
    return res


# --- Next Function Block ---


# -----------------------------------------------------
# Function 18: Merge parts of two lists.
def merge_lists(list1: list, list2: list, a: int, b: int) -> list:
    """
    Merges segments of list1 and list2:
      - Takes the first a elements from list1.
      - Then all elements from list2.
      - Then all elements of list1 after index b.
    
    Example:
      list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]
      Returns: list1[:3] + list2 + list1[5:]
    """
    return list1[:a] + list2 + list1[b+1:]


# --- Next Function Block ---




# -----------------------------------------------------
# Function 1: Find the nth number in a custom sequence.
def find_nth_number(n: int) -> int:
    """
    Finds and returns the nth number in a sequence defined by:
      - For numbers less than 7, every number is counted.
      - For numbers >= 7, if the number is divisible by 7, it is skipped.
      - Otherwise, if the number is composite (i.e. it has a divisor other than 1 and itself), it is counted.
    
    This is one interpretation of the snippet.
    """
    count = 0
    i = 1
    while count < n:
        if i < 7:
            count += 1
        else:
            # Skip numbers divisible by 7.
            if i % 7 == 0:
                i += 1
                continue
            prime_flag = False  # Actually, true means composite.
            j = 2
            while j < i:
                if i % j == 0:
                    prime_flag = True
                    break
                j += 1
            if prime_flag:
                count += 1
                print("Counting:", i)
        if count == n:
            break
        i += 1
    return i


# --- Next Function Block ---


# -----------------------------------------------------
# Function 2: Process folder paths and select one per key.
def process_folders(folders: list) -> dict:
    """
    Processes a list of folder paths and builds a dictionary keyed by the first two characters.
    If a key already exists, the folder with the shorter path is kept; if equal, a new entry with the full
    folder string is added.
    
    Example:
      folders = ["/a","/a/b","/c/d","/c/d/e","/c/f"]
    """
    d = {}
    i = 0
    while i < len(folders):
        key = folders[i][:2]
        if key in d:
            # Keep the one with the shorter length
            if len(folders[i]) < len(d[key]):
                d[key] = folders[i]
            elif len(folders[i]) == len(d[key]):
                # In the snippet, a new key is added with folder itself.
                d[folders[i]] = folders[i]
        else:
            d[key] = folders[i]
        i += 1
    return d


# --- Next Function Block ---


# -----------------------------------------------------
# Function 3: Print binary representations of numbers.
def print_binary(nums: list) -> None:
    """
    Given a list of numbers, prints each number along with its binary representation.
    """
    i = 0
    while i < len(nums):
        print(bin(nums[i]), nums[i])
        i += 1


# --- Next Function Block ---


# -----------------------------------------------------
# Function 4: Calculate an expression using logarithms.
def calculate_expression(a: int, b: int) -> int:
    """
    If a is 0 and b is not, returns b.
    If b is 0 and a is not, returns a.
    Otherwise, computes int(math.log(math.exp(a) * math.exp(b))) which is equivalent to a+b.
    
    Example:
      a = 707, b = 2 → returns 709.
    """
    if a == 0 and b != 0:
        return b
    elif b == 0 and a != 0:
        return a
    else:
        return int(math.log(math.exp(a) * math.exp(b)))


# --- Next Function Block ---


# -----------------------------------------------------
# Function 5: Filter even numbers from a list.
def filter_evens(arr: list) -> list:
    """
    Returns a list of even numbers from the given list 'arr'.
    
    Example:
      arr = [1,2,3,4,5,6] → returns [2,4,6].
    """
    return list(filter(lambda x: x % 2 == 0, arr))


# --- Next Function Block ---


# -----------------------------------------------------
# Function 6: Find the maximum average subarray of length k.
def max_average_subarray(nums: list, k: int) -> float:
    """
    Finds the contiguous subarray of length k that has the maximum average.
    Prints the subarray each time a new maximum average is found.
    Returns the maximum average.
    
    Example:
      nums = [-1], k = 1.
    """
    max_avg = float('-inf')
    best_sub = None
    i = 0
    while i < len(nums) - k + 1:
        current_avg = sum(nums[i:i+k]) / k
        if current_avg > max_avg:
            max_avg = current_avg
            best_sub = nums[i:i+k]
            print("New best subarray:", best_sub)
        i += 1
    return max_avg


# --- Next Function Block ---


# -----------------------------------------------------
# Function 7: Binary search on a sorted list.
def binary_search(nums: list, target: int) -> int:
    """
    Performs a binary search on a sorted list 'nums' to find 'target'.
    Returns the index if found; otherwise, returns -1.
    
    Example:
      nums = [1,2,3,1], target = 2 → returns index 1.
    """
    start = 0
    end = len(nums) - 1
    while start <= end:
        mid = (start + end) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            start = mid + 1
        else:
            end = mid - 1
    return -1


# --- Next Function Block ---


# -----------------------------------------------------
# Function 8: Rank array elements.
def rank_array(arr: list) -> (list, dict):
    """
    Ranks the elements of 'arr' by sorting the unique values and mapping them to ranks starting at 1.
    Replaces each element in arr with its rank.
    
    Example:
      arr = [40,10,20,30] → returns ([4,1,2,3], {10: 1, 20: 2, 30: 3, 40: 4})
    """
    unique_sorted = sorted(set(arr))
    ranking = {val: idx + 1 for idx, val in enumerate(unique_sorted)}
    ranked_arr = [ranking[val] for val in arr]
    return ranked_arr, ranking


# --- Next Function Block ---


# -----------------------------------------------------
# Function 9: Evaluate a string expression.
def evaluate_expression(expr: str):
    """
    Evaluates a string expression using Python's eval.
    
    Example:
      expr = "-9.1234" → returns -9.1234.
    """
    return eval(expr)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 10: Reverse a subarray given left and right indices (1-indexed).
def reverse_subarray(head: list, left: int, right: int) -> list:
    """
    Reverses the subarray of 'head' from index left-1 to right-1 (inclusive).
    
    Example:
      head = [1,2,3,4,5,6,8], left = 2, right = 4 → returns [1,4,3,2,5,6,8].
    """
    left_idx = left - 1
    right_idx = right
    return head[:left_idx] + head[left_idx:right_idx][::-1] + head[right_idx:]


# --- Next Function Block ---


# -----------------------------------------------------
# Function 11: Merge two lists by inserting a segment.
def merge_lists(list1: list, list2: list, a: int, b: int) -> list:
    """
    Merges two lists by taking:
      - The first a elements from list1,
      - Then all elements from list2,
      - Then all elements from list1 after index b.
    
    Example:
      list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]
      Returns: list1[:3] + list2 + list1[b+1:].
    """
    return list1[:a] + list2 + list1[b+1:]


# --- Next Function Block ---





def a(n):
    for i in range(0,n+1):
        a = i
        for k in range(n-i):
            print(end=" ")
        b=False
        for j in range(1, 2*i-2):
            print(a, end="")
            if a<3:
                b=True
            if b:
                a+=1
            else:
                a-=1
        print("\r")


# --- Next Function Block ---


def b(n):
    for i in range(n+1):
        for j in range(n-i):
            print(end=" ")
        for k in range(2*i-1):
            if k==0 or k==2*i-2:
                print("*", end="")
            else:
                if i==n:
                    print("*", end="")
                else:
                    print(end=" ")
        print("\n")


# --- Next Function Block ---


def c(num):
    flag=False
    if num == 1:
        print("Not prime")
    elif num > 0:
        for i in range(2, num):
            if(num%i==0):
                flag=True
                break
        
    if flag:
        print("Not prime")
    else:
        print("Prime")


# --- Next Function Block ---


def d(n):

    for i in range(1,n+1):
        for k in range(n-i):
            print(end=" ")
        for j in range(1, i):
            print(j,end=" ")
        print(1)


# --- Next Function Block ---


def e(n):
    a=0
    for i in range(n):
        for j in range(i):
            a=a+1
            print(a,end=" ")
        print("\n")


# --- Next Function Block ---


def f(n):
    for i in range(1,n+1):
        for j in range(1,i+1):
            print(j,end=" ")
        print("\n")


# --- Next Function Block ---


def g(n):

    for i in range(n+1):
        for j in range(i*2):
            print("*",end=" ")
        for k in range(1):
            print("*",end=" ")
        print("\n")


# --- Next Function Block ---


def h(n):
    run=True
    for i in range(1, n+1):
        for j in range(1, n+1):
            if j>n-i:
                print("",j,end="")
            else:
                print(end=" ")
        print("\n")


# --- Next Function Block ---


def i(n):
    for i in range(1, n+1):
        for j in range(0, n+1):
            if j<i:
                print(end="  ")
            else:
                print(" *", end="")
        print("\n")


# --- Next Function Block ---


def j(n):
    for i in range(1, n+1):
        for j in range(n+1):
            if j>=i:
                print("*",end="")
            else:
                print(end=" ")
        print("\r")


# --- Next Function Block ---


def i(n):
    for i in range(1, n+1):
        for j in range(1,n+1):
            if j<=(n+1)-i:
                print("*",end="")
            else:
                print(end=" ")
        print("\n")


# --- Next Function Block ---



def display(limit):
    print("Crossroads")
    if limit > 1:
        display(limit - 1)


# --- Next Function Block ---

    

def j(n):
    for i in range(1, n+1):
        for j in range(1, i+1):
            if i==5 or j==1 or j==5:
                print("*", end=" ")
            else:
                print(end=" ")
        print(end="\n")


# --- Next Function Block ---


def k(n):
    for i in range(1, n+1):
        for j in range(1, n*2+1):
            if(j<=i or j>n*2-i):
                print("*",end=" ")
            else:
                print(end="  ")
        print("\n")


# --- Next Function Block ---


def l(n):
    for i in range(1, n*2+1):
        for j in range(1, i+1):
            if(j<=i and i<=n):
                print("*",end=" ")
            elif(j<=n*2-i):
                print("*", end=" ")
        
        print("\n")


# --- Next Function Block ---


def m(n):
    for i in range(1, n+1):
        for j in range(1, n+1):
            if j<=n-i:
                print(end=" ")
            elif i%2!=0:          
                print(i,end=" ")
        print("")


# --- Next Function Block ---


def n(n):
    for i in range(1, n+1):
        for k in range(1, n+2-i):
            print(end="  ")
        for j in range(1, 2*i):
            print(j,end=" ")
        
        print("\n")


# --- Next Function Block ---


def o(n):
    for i in range(1, n*2+1):
        for j in range(1, n+1):
            if j<=n+1-i and i<=n:
                print("*",end=" ")
            elif j<=i-n and i>n:
                print("*",end=" ")
        print("\r")


# --- Next Function Block ---


def p(n):
    for i in range(1, n+1):
        for j in range(1, n+1):
            if j<=i or j>n-i:
                print("*", end=" ")
            else:
                print(end="  ")
        print("\n")


# --- Next Function Block ---


def q(n):
    count = 1
    for i in range(0, n+1):
        for j in range(1, i+1):
            print(j, end=" ")
        print("1\n")


# --- Next Function Block ---


def r(n):
    for i in range(1, n+1):
        for j in range(1, i*2):
            print("*",end=" ")
        print("\n*\n*\n")


# --- Next Function Block ---


def s(n):
    for i in range(1, n+5):
        for j in range(1, 2*i):
            print("*",end=" ")
        print("\n")


# --- Next Function Block ---


def t(n):
    for i in range(1,n):
        for j in range(2,n):
            if j<=i or j>n-i:
                print("*", end=" ")
            else:
                print(end="  ")
        if i>=5:
            break
        print("\n")


# --- Next Function Block ---


def u(size):
    i=0
    j=0
    while i<=size:
        i=i+1
        while j<=size:
            j=j+1
            if j<=i or j>size-i:
                print("*", end=" ")
            else:
                print(end=" ")
            
        print("\n")


# --- Next Function Block ---


def v():
    print("Enter numbers")
    array = []

    for i in range(0,5):
        array.append(int(input()))
    count =0
    for i in range(4):
        for j in range(i,5):
            if(array[i]==array[j]):
                count = count+1
                print(i,j)
    print(count,"*")


# --- Next Function Block ---



class Solution:
    def isValid(self, s: str) -> bool:
        array=[]
        count=0
        if(len(s)%2==0):
            flag=True
            for i in s:
                array.append(i)
            i=0
            while i<len(array):
                if(i%2==0 and array[i]=="(" and array[i+1]==")" or array[i]=="[" and array[i+1]=="]" or array[i]=="{" and array[i+1]=="}" or i<=len(array)/2 and array[i]=="(" and array[(len(array)-1)-i]==")" or array[i]=="[" and array[(len(array)-1)-i]=="]" or array[i]=="{" and array[(len(array)-1)-i]=="}"):
                    if(ord(array[i+1])-ord(array[i])<5 and ord(array[i+1])-ord(array[i])>0):
                        i=i+1
                else:
                    print(i)
                    flag=False
                i=i+1
        else:
            flag=False
        if(flag):
            print(True)
        else:
            print(False)
    s="([])"
    isValid(0, s)

def w(nums1, nums2):
    m=0
    n=1
    k=0
    for i in range(m,m+n):
        nums1[i] = nums2[k]
        k=k+1
    for s in range((m+n)-1):
        for j in range(s+1, m+n):
            if(nums1[s]>nums1[j]):
                temp=nums1[s]
                nums1[s]=nums1[j]
                nums1[j]=temp


# --- Next Function Block ---


def y(x):
    a=str(x)
    array=[]
    isPalindrome=True
    for i in a:
        array.append(i)

    for i in range(len(array)):
        if(int(array[i])!=int(array[len(array)-1-i])):
            isPalindrome=False
    if(isPalindrome):
        print(True)
    else:
        print(False)

    def isPalindrome(x):
        return x == x[::-1]

    res=isPalindrome("122")
    print(res)


# --- Next Function Block ---


def y(nums):
    array=[]
    pos=[]
    for i in range(len(nums)-2):
        for j in range(i+1,len(nums)-1):
            for k in range(j+1,len(nums)):
                if((nums[i]+nums[j]+nums[k])==0 and i!=j and i!=k and j!=k):
                    if([nums[i],nums[j],nums[k]] or [nums[i],nums[k],nums[j]] or [nums[j],nums[i],nums[k]] or [nums[j],nums[k],nums[i]] or [nums[k],nums[i],nums[j]] or [nums[k],nums[j],nums[i]] in array):
                        pos.append([i,j,k])
                    else:
                        array.append([nums[i],nums[j],nums[k]])
    print(array,"\n")
    print(pos)


# --- Next Function Block ---


def z(x):

    val = set(x)
    st = list(val)
    print(st)

    s="fly me   to   the moon  "
    a=s[::-1]
    count=0
    alph=False
    for i in a:
        if i!=" ":
            alph=True
        if alph and i==" ":
            break
        if alph and i!=" ":
            count=count+1
    print(count)


# --- Next Function Block ---


def aa(n):
    i=n-1
    k=2
    pro=n
    val=n-k
    j=val-1
    den=val
    while i>0:
        pro=pro*i
        i=i-1
    while j>0:
        den=den*j
    if den==0:
        den=1
    print(pro/den)


# --- Next Function Block ---


def ab(s):
    resp=""
    spc=[",",".",";",":","-","_"]
    for i in s:
        if i!=" " and i not in spc:
            resp=resp+i
    resp=resp.lower()
    if resp==resp[::-1]:
        print( True)
    else:
        print( False,resp)


# --- Next Function Block ---


def ac(nums):
    array=[]
    for i in range(len(nums)):
        count=1
        for j in range(len(nums)):
            if(nums[i]==nums[j] and i!=j):
                count=count+1
        array.append(count)
    lar=array[0]
    pos=0
    for i in range(0,len(array)):
        if lar<array[i]:
            lar=array[i]
            pos=i
    print( lar)


# --- Next Function Block ---


def ad(array):
    val=2
    i=0
    while i<len(array)-k:
        if array[i]==val:
            array.pop(i)
            i=i-1
        i=i+1
    print(len(array), array)


# --- Next Function Block ---


def ae(array):
    count=0
    for i in range(len(array)):
        for j in range(len(array)):

            if(array[i]>array[j]):
                if(array[i]%2==0):
                    array[i]=int(array[i]/2)
                    array.insert(i+1, int(array[i]))
                else:
                    array[i]=int((array[i]+1)/2)-1
                    array.insert(i+1, int(array[i]+1))
    print(array)


# --- Next Function Block ---



def af(s):       
    array=[]
    stg=[]
    lar=0
    def ins(length, pos, val):
        for i in range(0,length):
            stg.insert(pos, val)
            pos=pos+1

    for i in range(len(s)):
        count=1
        for j in range(len(s)):
            if(s[i]==s[j] and i!=j):
                count=count+1
        array.append(count)

    for k in range(len(array)):
        if(array[k]%2==0):
            if(len(stg)==0):
                for i in range(array[k]):
                    stg.append(s[k])
            else:
                if(s[k] not in stg):
                    pos=int(len(stg)/2)
                    ins(array[k], pos, s[k])
        else:
            if(array[k]>lar):
                lar=array[k]
                val=k
    print(s[val])
    if(lar>0):
        if(lar==1):
            hlf=int(len(stg)/2)
            stg.insert(hlf, s[val])
        elif(len(stg)==0):
            for i in range(lar):
                stg.append(s[val])
        else:
            hlf=int(len(stg)/2)
            ins(lar, hlf, s[val])
    print(array)


# --- Next Function Block ---


def ag(s):
    dict={}
    array=[]
    lar=0
    def ins(length, pos, val):
        for i in range(0,length):
            array.insert(pos, val)
            pos=pos+1
    for i in range(len(s)):
        count=1
        for j in range(len(s)):
            if(s[i]==s[j] and i!=j):
                count=count+1
        dict={**dict, s[i]:count}
    for i in dict.keys():
        if(dict[i]%2==0):
            if(len(array)==0):
                for j in range(dict[i]):
                    array.append(i)
            else:
                pos=int(len(array)/2)
                ins(dict[i], pos, i)
        else:
            if(dict[i]>lar):
                lar=dict[i]
                val=i

    if(lar>0):
        if(lar==1):
            hlf=int(len(array)/2)
            array.insert(hlf, val)
        elif(len(array)==0):
            for i in range(lar):
                array.append(val)
        else:
            hlf=int(len(array)/2)
            ins(lar, hlf, val)

    print(dict)

    s_len = len(s)
    if s == s[::-1]:
        print(s_len)

    chars = {}
    palindrome_length = 0

    for n in s:
        if chars.get(n):
            chars[n] += 1
            if chars[n] % 2 == 0:
                palindrome_length += 2
        else:
            chars[n] = 1

    print(palindrome_length + 1 if s_len - palindrome_length != 0 else palindrome_length)


# --- Next Function Block ---


def ah(nums):
    size=0
    while size<len(nums):
        pos=size
        if(nums[size]==0):
            break
        size=(size+nums[size])
    if(size-pos+1==len(nums)):
        print (True)
    else:
        print (False)


# --- Next Function Block ---


def ai(s,t):
    same=True
    array=""
    lar=-1
    for i in range(0,len(s)):
        for j in range(0,len(t)):
            if(s[i] == t[j] and j>lar):
                array=array+s[i]
                if(j>lar):
                    lar=j
    if array == s:
        print(True)
    else:
        print(array)


# --- Next Function Block ---


def aj(x):
    res=0
    dict={'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}

    for i in s:
        res=res+dict[i]
    if(s[len(s)-2]=='I' and dict[s[len(s)-1]]>1):
        res=res-2

    print(res)


# --- Next Function Block ---


def ak(array):
    count=0
    size=len(array)-1
    for i in range(size):
        if(count>0 and array[i-1] == array[i]):
            array[i]=array[i+1]
            size=size-1
        print(array[i])
        count=count+1


# --- Next Function Block ---


# anagrams.py
def are_anagrams(s: str, t: str) -> bool:
    """
    Returns True if strings s and t have the same character frequencies.
    """
    if len(s) != len(t):
        return False

    sdict = {}
    tdict = {}

    for i in range(len(s)):
        scount = 1
        tcount = 1
        for j in range(len(s)):
            if i != j:
                if s[i] == s[j]:
                    scount += 1
                if t[i] == t[j]:
                    tcount += 1
        sdict[s[i]] = scount
        tdict[t[i]] = tcount

    return sdict == tdict


# --- Next Function Block ---


# dominoes.py
def count_domino_pairs(dominoes: list) -> int:
    """
    Counts the number of equivalent domino pairs.
    Dominoes are considered equivalent if their sorted values are equal.
    """
    domino_count = {}
    count = 0
    for domino in dominoes:
        # Sort to get a consistent representation
        sorted_domino = tuple(sorted(domino))
        if sorted_domino in domino_count:
            count += domino_count[sorted_domino]
            domino_count[sorted_domino] += 1
        else:
            domino_count[sorted_domino] = 1
    return count


# --- Next Function Block ---


# compare_sorted_numbers.py
def compare_sorted_lists(nums: list):
    """
    Returns a tuple (sorted_set, sorted_nums) if the set and list differ,
    otherwise returns False.
    """
    sorted_set = sorted(set(nums))
    nums_sorted = sorted(nums)
    if sorted_set == nums_sorted:
        return False
    else:
        return sorted_set, nums_sorted


# --- Next Function Block ---


# pascals_triangle.py
def generate_pascals_triangle(n: int) -> list:
    """
    Generates Pascal's triangle with n rows.
    """
    triangle = []
    for i in range(n):
        row = [1]
        if i > 0:
            last_row = triangle[-1]
            for j in range(1, i):
                row.append(last_row[j-1] + last_row[j])
            row.append(1)
        triangle.append(row)
    return triangle


# --- Next Function Block ---


# day_of_year.py
def day_of_year(date_str: str) -> int:
    """
    Given a date string in 'YYYY-MM-DD' format, returns its day-of-year.
    """
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    year, month, day = map(int, date_str.split("-"))
    day_count = sum(days_in_month[:month-1]) + day
    # Check for leap year: divisible by 4 and (not divisible by 100 or divisible by 400)
    if (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)) and month > 2:
        day_count += 1
    return day_count


# --- Next Function Block ---


# majority_element.py
def majority_element(nums: list):
    """
    Returns the element that occurs most frequently in nums.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    max_count = 0
    majority = None
    for num, count in freq.items():
        if count > max_count:
            max_count = count
            majority = num
    return majority


# --- Next Function Block ---


# tribonacci.py
def tribonacci(n: int) -> int:
    """
    Returns the (n+1)th Tribonacci number.
    Starting with trib[0]=0, trib[1]=0, trib[2]=1.
    """
    trib = [0, 0, 1]
    for i in range(2, n + 1):
        trib.append(trib[i-2] + trib[i-1] + trib[i])
    return trib[n+1]


# --- Next Function Block ---


# factorial_division.py
def compute_factorial_divided(n: int) -> int:
    """
    Computes (2*n)! divided by 2^n.
    """
    num = n * 2
    factorial = 1
    for i in range(num, 0, -1):
        factorial *= i
    return factorial // (2 ** n)


# --- Next Function Block ---


# min_frequency_element.py
def min_frequency_element(nums: list):
    """
    Returns the element with the minimum frequency in nums.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    min_count = float('inf')
    element = None
    for num, count in freq.items():
        if count < min_count:
            min_count = count
            element = num
    return element


# --- Next Function Block ---


# search_insert.py
def search_insert(nums: list, target: int):
    """
    Returns a tuple (position, new_list) where position is the index of target in the sorted list.
    If target is not in nums, it is inserted into the correct sorted position.
    """
    if target in nums:
        return nums.index(target), nums
    for i, num in enumerate(nums):
        if target < num:
            nums.insert(i, target)
            return i, nums
    nums.append(target)
    return len(nums) - 1, nums


# --- Next Function Block ---


# str_str.py
def find_substring(haystack: str, needle: str) -> int:
    """
    Returns the index of the first occurrence of needle in haystack, or -1 if not found.
    """
    return haystack.find(needle)


# --- Next Function Block ---




# patterns.py

def reverse_vowels(s: str) -> str:
    """
    Reverses only the vowels in the string.
    Example: "hello" -> "holle"
    """
    vowels = ['a','e','i','o','u','A','E','I','O','U']
    s_list = list(s)
    # Collect vowels in order.
    collected = [ch for ch in s_list if ch in vowels]
    # Reverse the collected vowels.
    collected = collected[::-1]
    idx = 0
    # Replace vowels in s_list with reversed ones.
    for i in range(len(s_list)):
        if s_list[i] in vowels:
            s_list[i] = collected[idx]
            idx += 1
    return "".join(s_list)


# --- Next Function Block ---



def sort_vowels_in_string(s: str) -> str:
    """
    Extracts vowels from s, sorts them (by ascii), then replaces vowels in order.
    Example: "lEetcOde" -> vowels sorted: ['E','O','e','o'] and then reinserted.
    """
    vowels = ['a','e','i','o','u','A','E','I','O','U']
    s_list = list(s)
    # Collect ascii codes of vowels.
    vowel_codes = [ord(ch) for ch in s_list if ch in vowels]
    vowel_codes.sort()
    sorted_vowels = "".join(chr(code) for code in vowel_codes)
    idx = 0
    res = ""
    for ch in s_list:
        if ch in vowels:
            res += sorted_vowels[idx]
            idx += 1
        else:
            res += ch
    return res


# --- Next Function Block ---



def unique_chars(s: str) -> str:
    """
    Returns a string made of unique characters in s (order arbitrary).
    Example: "pwwkew" -> a string with unique letters.
    """
    return "".join(set(s))


# --- Next Function Block ---



def reduce_value(n: float) -> float:
    """
    Divides n by 2 repeatedly until n <= 2.
    """
    while n > 2:
        n /= 2
    return n


# --- Next Function Block ---



def move_zeros_nested(nums: list) -> list:
    """
    Moves zeros in a list to the end using nested loops.
    Example: [0,0,1,0,3,12] becomes a list with non-zeros first.
    """
    nums = nums[:]  # copy to avoid mutation
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            if nums[i] == 0 and nums[j] != 0:
                nums[i], nums[j] = nums[j], 0
    return nums


# --- Next Function Block ---



def move_zeros_remove(nums: list) -> list:
    """
    Moves zeros to the end by removing and appending.
    Example: [0,1,0,3,12] becomes [1,3,12,0,0].
    """
    nums = nums[:]  # copy
    for i in nums[:]:
        if i == 0:
            nums.remove(i)
            nums.append(0)
    return nums


# --- Next Function Block ---



def combine_adjacent_equal(nums: list) -> list:
    """
    Combines two equal adjacent numbers by doubling the first and zeroing the second.
    Then moves zeros to the end.
    Example: [1,2,2,1,1,0] --> after combination and shifting zeros.
    """
    nums = nums[:]  # copy
    for i in range(len(nums)-1):
        if nums[i] == nums[i+1]:
            nums[i] *= 2
            nums[i+1] = 0
    # Remove zeros and append them at the end.
    result = [num for num in nums if num != 0]
    result.extend([0] * (len(nums) - len(result)))
    return result


# --- Next Function Block ---



def int_to_roman(num: int) -> str:
    """
    Converts an integer to a Roman numeral string.
    """
    mapping = {1000:'M', 500:'D', 100:'C', 50:'L', 10:'X', 5:'V', 1:'I'}
    out = ""
    n = num
    while n > 0:
        if n >= 1000:
            n -= 1000
            out += mapping[1000]
        elif n >= 900:
            n -= 900
            out += mapping[100] + mapping[1000]
        elif n >= 500:
            n -= 500
            out += mapping[500]
        elif n >= 400:
            n -= 400
            out += mapping[100] + mapping[500]
        elif n >= 100:
            n -= 100
            out += mapping[100]
        elif n >= 90:
            n -= 90
            out += mapping[10] + mapping[100]
        elif n >= 50:
            n -= 50
            out += mapping[50]
        elif n >= 40:
            n -= 40
            out += mapping[10] + mapping[50]
        elif n >= 10:
            n -= 10
            out += mapping[10]
        elif n >= 9:
            n -= 9
            out += mapping[1] + mapping[10]
        elif n >= 5:
            n -= 5
            out += mapping[5]
        elif n >= 4:
            n -= 4
            out += mapping[1] + mapping[5]
        else:
            n -= 1
            out += mapping[1]
    return out


# --- Next Function Block ---



def multiply_str_numbers(num1: str, num2: str) -> int:
    """
    Converts two string numbers to integers and returns their product.
    """
    return int(num1) * int(num2)


# --- Next Function Block ---



def min_diff_pair(arr: list) -> list:
    """
    Given a sorted array, finds and returns the pair of numbers with the minimum difference.
    """
    arr = sorted(arr)
    diffs = []
    pairs = []
    for i in range(len(arr)-1):
        diff = arr[i+1] - arr[i]
        diffs.append(diff)
        pairs.append([arr[i], arr[i+1]])
    min_diff = min(diffs) if diffs else None
    for pair in pairs:
        if pair[1] - pair[0] == min_diff:
            return pair
    return []


# --- Next Function Block ---



def insert_zeros_after_even(nums: list) -> list:
    """
    Inserts two zeros immediately after every even number in the list.
    """
    i = 0
    nums = nums[:]  # copy
    while i < len(nums):
        if nums[i] % 2 == 0:
            nums.insert(i+1, 0)
            nums.insert(i+2, 0)
            i += 3
        else:
            i += 1
    return nums


# --- Next Function Block ---



def remove_two_after_condition(arr: list) -> list:
    """
    If an element in arr is divisible by 5 and there's a next element, remove the next two elements.
    (Note: This logic is based on the given code and may remove fewer than two if not available.)
    """
    arr = arr[:]  # copy
    i = 0
    while i < len(arr) - 1:
        if arr[i] % 5 == 0:
            # Remove next two elements if possible.
            if i+1 < len(arr):
                arr.pop(i+1)
            if i+1 < len(arr):
                arr.pop(i+1)
        i += 1
    return arr


# --- Next Function Block ---



def check_coordinate_difference(coordinates: list) -> bool:
    """
    Given a list of [x,y] coordinates, attempts to check if the differences between consecutive coordinates are consistent.
    (The original logic is ambiguous; this function mimics the provided approach.)
    """
    if not coordinates:
        return True
    diff = coordinates[0][0] - coordinates[0][1]
    diffx = []
    diffy = []
    h = 0
    out = True
    for i in range(len(coordinates)):
        k = coordinates[i]
        if i < len(coordinates) - 1:
            l = coordinates[i+1]
        for j in range(len(k) - 1):
            if diff:
                if k[0] - k[1] == diff:
                    if i < len(coordinates) - 1:
                        diffx.append(l[0] - k[0])
                        diffy.append(l[1] - k[1])
                        if h > 0 and diffx[h-1] == diffx[h] and diffy[h-1] == diffy[h]:
                            h += 1
                        elif diff != 0 and diffx[h] % diff == 0 and diffy[h] % diff == 0:
                            h += 1
                        else:
                            out = False
                            break
                else:
                    out = False
                    break
            else:
                diff = k[0] - k[1]
    return out


# --- Next Function Block ---



def max_profit_difference(arr: list) -> int:
    """
    Given a list of prices (or similar), finds the pair with the minimum difference and returns the difference between sell and buy.
    If the difference is negative, returns 0.
    (Logic based on the provided snippet.)
    """
    diff_map = {}
    for i in range(len(arr)-1):
        minval = arr[0]  # initial min value difference (this logic is ambiguous)
        for j in range(i+1, len(arr)):
            if arr[i] - arr[j] < minval:
                minval = arr[i] - arr[j]
                buyval = arr[i]
                sellval = arr[j]
        diff_map[minval] = [buyval, sellval]
    key = min(diff_map) if diff_map else 0
    val = diff_map.get(key, [0, 0])
    res = val[1] - val[0]
    if res <= 0:
        res = 0
    return res


# --- Next Function Block ---



def find_min_in_list(arr: list) -> int:
    """
    Returns the minimum value in the list.
    """
    if not arr:
        return None
    min_val = arr[0]
    for i in arr:
        if i < min_val:
            min_val = i
    return min_val


# --- Next Function Block ---



def print_star_pattern():
    """
    Prints a pattern:
    For each i from 1 to 3:
      - Print a line with '*' (with newline)
      - Then print i blocks of a square pattern where each block is a row of i stars repeated 'size' times.
      'size' doubles for each i.
    """
    size = 2
    for i in range(1, 4):
        # Print i lines with "*"
        for j in range(i):
            print("*")
        # Print square blocks
        for k in range(i):
            for l in range(size):
                print("*", end=" ")
            print()  # new line after each block row
        size *= 2


# --- Next Function Block ---




# patterns.py

def symmetric_differences(arr: list) -> list:
    """
    Given an array, computes absolute differences between elements
    from the start and end moving inward.
    Example:
      Input: [7,3,5,2,10,6,8,1,4,9]
      Output: list of differences for first half of array with corresponding symmetric elements.
    """
    size = len(arr)
    diff = []
    i, n = 0, size - 1
    for _ in range(size // 2):
        # If indices cross, break (though loop is already half-length)
        if i == n:
            break
        diff.append(abs(arr[i] - arr[n]))
        i += 1
        n -= 1
    return diff


# --- Next Function Block ---



def product_minus_sum(n: int) -> int:
    """
    Converts an integer to string, computes the product of its digits,
    the sum of its digits, and returns (product - sum).
    Example: n=234 -> (2*3*4) - (2+3+4) = 24 - 9 = 15
    """
    s = str(n)
    prod = 1
    total = 0
    for ch in s:
        digit = int(ch)
        total += digit
        prod *= digit
    return prod - total


# --- Next Function Block ---



def sum_of_multiples(n: int) -> int:
    """
    Sums all numbers in the range [1, n) that are divisible by 3, 5, or 7.
    Example: n=7 sums numbers in 1...6 meeting the condition.
    """
    total = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0 or i % 7 == 0:
            total += i
    return total


# --- Next Function Block ---



def nine_minus_one(n: int) -> int:
    """
    For a given integer n, creates a number with the same number of digits all '9's
    and a number with the same number of digits all '1's, then returns their difference.
    Example: n=555 -> "999" - "111" = 888.
    """
    s = str(n)
    large = int("9" * len(s))
    small = int("1" * len(s))
    return large - small


# --- Next Function Block ---



def product_of_list(nums: list, verbose: bool = False) -> int:
    """
    Multiplies the numbers in the list (iterating in reverse order).
    Optionally prints each number.
    """
    product = 1
    for num in nums[::-1]:
        if verbose:
            print(num)
        product *= num
    return product


# --- Next Function Block ---



def longest_common_prefix(strs: list) -> str:
    """
    Returns the longest common prefix among the list of strings.
    If there is none, returns an empty string.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        # Shorten the prefix until s starts with it
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def max_right(arr: list) -> list:
    """
    Given an array, returns a new list where each element at index i is
    replaced by the maximum element to its right; the last element is -1.
    Example: [7,3,5,2,10] -> [10,10,10,10,-1]
    """
    size = len(arr)
    if size == 0:
        return []
    result = [None] * size
    result[-1] = -1
    max_so_far = arr[-1]
    for i in range(size - 2, -1, -1):
        if arr[i] > max_so_far:
            max_so_far = arr[i]
        result[i] = max_so_far
    return result


# --- Next Function Block ---



def generate_random_array(n: int) -> tuple:
    """
    Generates an array of n-1 distinct random integers between -n and n (excluding 0),
    then appends -sum(array) if not already present, or adjusts if it is.
    Returns a tuple: (array, count, -count), where count is the sum of the initial array.
    """
    import random
    array = []
    count = 0
    while len(array) < n - 1:
        val = random.randint(-n, n)
        if val not in array and val != 0:
            array.append(val)
            count += val
    if -count not in array:
        array.append(-count)
    else:
        idx = array.index(-count)
        array[idx] = 0
        array.append(-count + (-count))
    return array, count, -count


# --- Next Function Block ---



def modify_number(num: int) -> int:
    """
    Given a number, replaces the first digit that is less than 9 with 9.
    Then, in a while loop, if a digit (starting from the right) equals 6,
    adds 3 times its positional value to the original number and stops.
    Returns the modified number.
    """
    s = str(num)
    ret = ""
    ins = True
    for ch in s:
        digit = int(ch)
        if digit < 9 and ins:
            ret += "9"
            ins = False
        else:
            ret += ch
    modified = int(ret)
    
    # Process digits from right side
    temp = num
    count = 0
    while temp > 1:
        if temp % 10 == 6:
            modified += 3 * (10 ** count)
            break
        count += 1
        temp //= 10
    return modified


# --- Next Function Block ---



def pascal_row(row_index: int) -> list:
    """
    Returns the row_index-th row of Pascal's Triangle.
    Example: row_index=0 returns [1], row_index=1 returns [1,1], etc.
    """
    triangle = []
    for i in range(row_index + 1):
        row = [1]
        if i > 0:
            prev = triangle[-1]
            for j in range(1, i):
                row.append(prev[j-1] + prev[j])
            row.append(1)
        triangle.append(row)
    return triangle[row_index]


# --- Next Function Block ---



def min_max_game(nums: list) -> int:
    """
    Given a list of numbers, repeatedly perform the following:
      - Partition the list into pairs.
      - For each pair, if it's the turn for 'min', choose the minimum; otherwise, choose the maximum.
      - Continue until one number remains.
    Returns the final number.
    """
    turn = True  # True means take min, False means take max.
    while len(nums) > 1:
        new_nums = []
        for i in range(0, len(nums) - 1, 2):
            if turn:
                new_nums.append(min(nums[i], nums[i+1]))
            else:
                new_nums.append(max(nums[i], nums[i+1]))
            turn = not turn
        if len(nums) % 2 == 1:
            new_nums.append(nums[-1])
        nums = new_nums
    return nums[0]


# --- Next Function Block ---



def chunk_string(s: str, k: int) -> list:
    """
    Splits the string s into chunks of length k.
    The final chunk may be shorter if s is not divisible by k.
    """
    return [s[i:i+k] for i in range(0, len(s), k)]


# --- Next Function Block ---



def min_max_game_progression(nums: list) -> list:
    """
    Implements the Min Max Game (LeetCode #2293) and returns all intermediate lists.
    """
    result = [nums]
    flag = True
    while len(result[-1]) > 1:
        current = result[-1]
        new_list = []
        i = 0
        while i < len(current) - 1:
            if flag:
                new_list.append(min(current[i], current[i+1]))
            else:
                new_list.append(max(current[i], current[i+1]))
            flag = not flag
            i += 2
        result.append(new_list)
    return result


# --- Next Function Block ---



def most_frequent(nums: list):
    """
    Returns the most frequent element in the list.
    """
    freq = {}
    max_count = 0
    max_elem = None
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
        if freq[num] > max_count:
            max_count = freq[num]
            max_elem = num
    return max_elem


# --- Next Function Block ---



def compute_ranks(arr: list) -> list:
    """
    Computes the rank for each element in the original array.
    Rank is defined as:
       - Unique elements are sorted.
       - The rank is 1 for the smallest element, 2 for the next, etc.
    Returns a list of ranks corresponding to the original array.
    """
    sorted_unique = sorted(set(arr))
    rank_dict = {num: rank+1 for rank, num in enumerate(sorted_unique)}
    return [rank_dict[num] for num in arr]


# --- Next Function Block ---



def print_symmetric_pairs(s: str) -> None:
    """
    Prints pairs of characters from the string: first with last, second with second-last, etc.
    """
    size = len(s)
    for i in range(size // 2):
        print(s[i], s[size - 1 - i])


# --- Next Function Block ---



def max_area(height: list) -> int:
    """
    Given a list of heights, returns the maximum area formed by two indices,
    defined as min(height[i], height[j]) * (j - i). (O(n^2) brute force approach.)
    """
    max_area_val = 0
    size = len(height)
    for i in range(size - 1):
        for j in range(i + 1, size):
            area = min(height[i], height[j]) * (j - i)
            if area > max_area_val:
                max_area_val = area
    return max_area_val


# --- Next Function Block ---




# patterns.py

# 1. Happy Number Check (using sum of squares of digits)
def is_happy(n: int, max_iter: int = 100) -> bool:
    """
    Determines if a number is "happy". A number is happy if repeatedly replacing
    it with the sum of the squares of its digits eventually leads to 1.
    """
    for _ in range(max_iter):
        s = str(n)
        total = sum(int(ch) ** 2 for ch in s)
        n = total
        if n == 1:
            return True
    return False


# --- Next Function Block ---


# 2. k Least Ones Rows in a Binary Matrix
def k_least_ones_rows(mat: list, k: int) -> list:
    """
    Given a binary matrix, counts the number of 1's in each row and returns
    the indices of the k rows with the fewest 1's.
    """
    row_counts = {i: sum(row) for i, row in enumerate(mat)}
    sorted_rows = sorted(row_counts.items(), key=lambda x: x[1])
    return [i for i, _ in sorted_rows[:k]]


# --- Next Function Block ---


# 3. Check if s is a Subsequence of t
def is_subsequence(s: str, t: str) -> bool:
    """
    Returns True if s is a subsequence of t.
    """
    pos = 0
    for char in s:
        pos = t.find(char, pos)
        if pos == -1:
            return False
        pos += 1
    return True


# --- Next Function Block ---


# 4. Digit Root (Repeated sum of digits until single digit)
def digit_root(n: int) -> int:
    """
    Repeatedly sums the digits of n until a single digit is obtained.
    """
    while n >= 10:
        n = sum(int(d) for d in str(n))
    return n


# --- Next Function Block ---


# 5. Count Numbers Smaller Than Current
def count_smaller_numbers(nums: list) -> list:
    """
    For each number in nums, counts how many numbers in nums are smaller.
    """
    result = []
    for i in range(len(nums)):
        count = sum(1 for j in range(len(nums)) if nums[i] > nums[j])
        result.append(count)
    return result


# --- Next Function Block ---


# 6. Intersection of Two Lists (unique common elements)
def intersection(nums1: list, nums2: list) -> list:
    """
    Returns a list of unique elements common to both nums1 and nums2.
    """
    return list(set(nums1).intersection(set(nums2)))


# --- Next Function Block ---


# 7. Palindrome Check
def is_palindrome(s: str) -> bool:
    """
    Returns True if s is a palindrome.
    """
    return s == s[::-1]


# --- Next Function Block ---


# 8. Interleave Two Strings
def interleave_strings(word1: str, word2: str) -> str:
    """
    Interleaves characters of word1 and word2. If one word is longer,
    appends the remainder at the end.
    """
    result = []
    max_len = max(len(word1), len(word2))
    for i in range(max_len):
        if i < len(word1):
            result.append(word1[i])
        if i < len(word2):
            result.append(word2[i])
    return "".join(result)


# --- Next Function Block ---


# 9. Maximum Sum with Reversed Numbers
def max_sum_with_reversed(nums: list) -> int:
    """
    For each number in nums that has more than one digit, reverse its digits.
    If the reversed number is also in nums, track the maximum sum of the original
    and reversed numbers.
    """
    max_sum = -1
    for num in nums:
        s = str(num)
        if len(s) > 1:
            rev = int(s[::-1])
            if rev in nums:
                max_sum = max(max_sum, num + rev)
    return max_sum


# --- Next Function Block ---


# 10. Alternate Rearrangement of Characters
def alternate_rearrange(s: str) -> str:
    """
    Rearranges characters from s by alternating from a sorted list of unique characters,
    decrementing their frequency until the result's length equals the original.
    (This mimics a complex custom ordering from the provided snippet.)
    """
    freq = {}
    for ch in s:
        freq[ch] = freq.get(ch, 0) + 1
    unique_chars = sorted(set(s))
    result = ""
    i = 0
    reverse = False
    const = False
    while len(result) < len(s) and unique_chars:
        # If the current character is exhausted, remove it.
        if freq[unique_chars[i]] <= 0:
            unique_chars.pop(i)
            if not unique_chars:
                break
            i = len(unique_chars)-1 if reverse else 0
            continue
        result += unique_chars[i]
        freq[unique_chars[i]] -= 1
        # Toggle direction at boundaries.
        if i == 0:
            reverse = False
        elif i == len(unique_chars) - 1:
            reverse = True
        const = True
        if len(unique_chars) <= 1:
            i = 0
        elif reverse:
            i -= 1
        else:
            i += 1
    return result


# --- Next Function Block ---


# 11. Count Pairs with Sum Less Than Target
def count_pairs_with_sum_less_than(nums: list, target: int) -> int:
    """
    Counts the number of unique pairs (i, j) with i < j such that the sum is less than target.
    """
    count = 0
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            if nums[i] + nums[j] < target:
                count += 1
    return count


# --- Next Function Block ---


# 12. Count Pairs with Sum in [lower, upper]
def count_pairs_in_range(nums: list, lower: int, upper: int) -> int:
    """
    Counts the number of unique pairs (i, j) with i < j such that the sum is between lower and upper (inclusive).
    """
    count = 0
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            s = nums[i] + nums[j]
            if lower <= s <= upper:
                count += 1
    return count


# --- Next Function Block ---


# 13. Check First Letters of Words Against a String
def check_first_letters(words: list, s: str) -> bool:
    """
    Checks if the first letter of each word in words matches the corresponding character in s.
    Returns False if lengths differ.
    """
    if len(words) != len(s):
        return False
    for i in range(len(words)):
        if words[i][0] != s[i]:
            return False
    return True


# --- Next Function Block ---


# 14. Count Unique Numbers in Intervals
def count_unique_numbers_in_intervals(intervals: list) -> int:
    """
    Given a list of intervals [start, end], counts the number of unique integers in all intervals.
    """
    unique_nums = set()
    for start, end in intervals:
        unique_nums.update(range(start, end + 1))
    return len(unique_nums)


# --- Next Function Block ---


# 15. Return Length of List
def list_length(lst: list) -> int:
    """
    Returns the length of lst.
    """
    return len(lst)


# --- Next Function Block ---


# 16. Create Target Array in Given Order
def create_target_array(nums: list, index: list) -> list:
    """
    Given two lists, nums and index, inserts each element from nums into a target list at the corresponding index.
    """
    target = []
    for num, idx in zip(nums, index):
        target.insert(idx, num)
    return target


# --- Next Function Block ---


# 17. Common Divisors of Two Numbers
def common_divisors(a: int, b: int) -> list:
    """
    Returns a list of common divisors of a and b.
    """
    c = a if a < b else b
    divisors = []
    for i in range(1, c + 1):
        if a % i == 0 and b % i == 0:
            divisors.append(i)
    return divisors


# --- Next Function Block ---


# 18. ID with Maximum Gap in Logs
def id_of_max_gap(logs: list) -> int:
    """
    Given logs as [id, time] pairs, returns the id corresponding to the maximum gap between times.
    Assumes logs are ordered by time.
    """
    kdiff = 0
    selected_id = 0
    pos = 0
    for log in logs:
        current_id, time = log
        gap = time - pos
        if gap > kdiff:
            kdiff = gap
            selected_id = current_id
        pos = time
    return selected_id


# --- Next Function Block ---


# 19. Print Negative Pairs
def print_negative_pairs(nums: list) -> None:
    """
    For each number in nums, if its negative exists in nums, prints the negative value with a tag.
    """
    nums_sorted = sorted(nums, reverse=True)
    for num in nums_sorted:
        if -num in nums:
            print(-num, "9")


# --- Next Function Block ---


# 20. Power Calculation
def power(x: float, n: int) -> float:
    """
    Returns x raised to the power n.
    """
    return x ** n


# --- Next Function Block ---


# 21. Range Count
def range_count(low: int, high: int) -> int:
    """
    Returns the difference between high and low.
    """
    return high - low


# --- Next Function Block ---


# 22. Average of Salaries
def average_salary(salaries: list) -> float:
    """
    Returns the average of the salaries in the list.
    """
    return sum(salaries) / len(salaries) if salaries else 0


# --- Next Function Block ---


# 23. Rotate Array Right by k
def rotate_right(nums: list, k: int) -> list:
    """
    Rotates the list nums to the right by k positions.
    """
    n = len(nums)
    k = k % n  # Handle cases where k >= n
    return nums[-k:] + nums[:-k]


# --- Next Function Block ---


# 24. Element Equal to Its Frequency
def element_equal_to_frequency(arr: list) -> int:
    """
    Returns the first element whose value equals its frequency in the array.
    If none exists, returns -1.
    """
    freq = {}
    for num in arr:
        freq[num] = freq.get(num, 0) + 1
    for num in arr:
        if num == freq[num]:
            return num
    return -1


# --- Next Function Block ---


# 25. Longest Repeating Character Substring Length
def longest_repeating_substring_length(s: str) -> int:
    """
    Returns the length of the longest substring of s consisting of the same character.
    """
    if not s:
        return 0
    max_len = 1
    current_len = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_len += 1
        else:
            max_len = max(max_len, current_len)
            current_len = 1
    return max(max_len, current_len)


# --- Next Function Block ---


# 26. Get Dictionary Keys
def get_dict_keys(d: dict) -> list:
    """
    Returns a list of keys in dictionary d.
    """
    return list(d.keys())


# --- Next Function Block ---


# 27. Demonstrate Abstract Base Classes
from abc import ABC, abstractmethod
class A(ABC):
    @abstractmethod
    def printf(self):
        pass

class B(A):
    def printf(self):
        print("Hi from B")
    def Scan(self):
        print("Hey")

def test_inheritance():
    """
    Demonstrates inheritance using abstract base classes.
    """
    obj = B()
    obj.printf()
    obj.Scan()


# --- Next Function Block ---


# 28. Custom Fibonacci Variant (starting with [1,2])
def custom_fib(n: int) -> int:
    """
    Returns the nth element in a Fibonacci-like sequence starting with 1 and 2.
    """
    if n == 1:
        return 1
    if n == 2:
        return 2
    seq = [1, 2]
    for i in range(2, n):
        seq.append(seq[-1] + seq[-2])
    return seq[-1]


# --- Next Function Block ---


# 29. Vehicle Class with Destructor
class Vehicle:
    def __init__(self):
        print("Vehicle created.")
    def __del__(self):
        print("Destructor called, vehicle deleted.")
    def display(self):
        print("Hello")

def test_vehicle_class():
    """
    Creates a Vehicle instance, calls display, then deletes it.
    """
    car = Vehicle()
    car.display()
    del car


# --- Next Function Block ---


# 30. Most Frequent Element in a List
def most_frequent_element(nums: list) -> int:
    """
    Returns the element with the highest frequency in nums.
    """
    freq = {}
    max_count = 0
    max_elem = None
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
        if freq[num] > max_count:
            max_count = freq[num]
            max_elem = num
    return max_elem


# --- Next Function Block ---


# 31. Print Duplicates in a List
def print_duplicates(nums: list) -> None:
    """
    Prints elements that appear more than once in the list.
    """
    seen = set()
    duplicates = set()
    for num in nums:
        if num in seen:
            duplicates.add(num)
        else:
            seen.add(num)
    for dup in duplicates:
        print(dup)


# --- Next Function Block ---


# 32. First Duplicate Element (from set comprehension)
def first_duplicate(nums: list):
    """
    Returns the first element that appears more than once in nums.
    If none, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---


# 33. Capitalize First Letter of a String
def capitalize_first_letter(s: str) -> str:
    """
    Capitalizes the first letter of the string s.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---


# 34. Interleave Halves of an Array
def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list nums and an integer n, interleaves the first n elements with the next n elements.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---


# 35. Extract Number from String
def extract_number(s: str) -> int:
    """
    Splits the string s by spaces and returns the last integer found.
    If none found, returns 0.
    """
    num = 0
    for token in s.split():
        try:
            num = int(token)
        except ValueError:
            continue
    return num


# --- Next Function Block ---


# 36. Longest Common Prefix (Brute Force)
def longest_common_prefix_brute(strs: list) -> str:
    """
    Finds the longest common prefix among a list of strings using brute force.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# --- Next Function Block ---


# 37. Remove Duplicates In-place (Sorted Array Variant)
def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---


# 38. Normalize Email Addresses
def normalize_email(email: str) -> str:
    """
    Normalizes an email address by removing dots from the local name and ignoring everything after a '+'.
    """
    local, domain = email.split('@')
    local = local.split('+')[0].replace('.', '')
    return local + '@' + domain


# --- Next Function Block ---


def normalize_emails(emails: list) -> list:
    """
    Normalizes a list of emails.
    """
    return [normalize_email(email) for email in emails]


# --- Next Function Block ---


# 39. Adjust Prices (Subtract first smaller element)
def adjust_prices(prices: list) -> list:
    """
    For each price in the list, if a subsequent price is smaller,
    subtract that price from the current and break.
    """
    adjusted = prices[:]  # make a copy
    for i in range(len(adjusted)-1):
        for j in range(i+1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] = adjusted[i] - adjusted[j]
                break
    return adjusted


# --- Next Function Block ---


# 40. Sum Diagonals of a Matrix
def sum_diagonals(mat: list) -> int:
    """
    Sums the elements on both the main diagonal and the secondary diagonal of a square matrix.
    If the matrix has an odd center, it is counted only once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i]  # primary diagonal
        total += mat[i][n - 1 - i]  # secondary diagonal
    # If n is odd, subtract the center value (counted twice)
    if n % 2 == 1:
        total -= mat[n//2][n//2]
    return total


# --- Next Function Block ---





# patterns.py

def is_diagonal_matrix(grid: list) -> bool:
    """
    Returns True if grid is a square matrix with nonzero entries only on the main diagonal,
    and zeros off the diagonal.
    """
    n = len(grid)
    for i in range(n):
        for j in range(len(grid[i])):
            if i == j:
                if grid[i][j] == 0:
                    return False
            else:
                if grid[i][j] != 0:
                    return False
    return True


# --- Next Function Block ---



def xor_of_sequence(n: int, start: int = 3, step: int = 2) -> int:
    """
    Generates a sequence of n numbers, starting from 'start' and increasing by 'step',
    and returns their bitwise XOR.
    """
    seq = []
    xor_val = 0
    i = start
    while len(seq) < n:
        seq.append(i)
        xor_val ^= i
        i += step
    return xor_val


# --- Next Function Block ---



def count_elements_geq(arr: list, target) -> int:
    """
    Counts the number of elements in arr that are greater than or equal to target.
    """
    count = 0
    for elem in arr:
        if elem >= target:
            count += 1
    return count


# --- Next Function Block ---



def max_account_value(accounts: list) -> int:
    """
    Given a list of accounts (each account is a list of numbers), returns the maximum total (row sum).
    """
    max_val = 0
    for acc in accounts:
        total = sum(acc)
        if total > max_val:
            max_val = total
    return max_val


# --- Next Function Block ---



def count_equal_pairs(nums: list) -> int:
    """
    Counts the number of pairs (i, j) with i < j such that nums[i] == nums[j].
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if nums[i] == nums[j]:
                count += 1
    return count


# --- Next Function Block ---



def duplicate_list(nums: list) -> list:
    """
    Returns a new list by appending a copy of nums to itself.
    """
    return nums + nums


# --- Next Function Block ---



def final_value_after_operations(operations: list) -> int:
    """
    Given a list of operations (strings "++X" or "X++"), returns the final value of x.
    """
    x = 0
    for op in operations:
        if op in ["++X", "X++"]:
            x += 1
        else:
            x -= 1
    return x


# --- Next Function Block ---



def kids_with_greatest_candies(candies: list, extraCandies: int) -> list:
    """
    Returns a list of booleans indicating whether each kid can have the greatest number of candies
    after receiving extraCandies.
    """
    max_candies = max(candies)
    result = []
    for c in candies:
        result.append(c + extraCandies >= max_candies)
    return result


# --- Next Function Block ---



def running_sum(nums: list) -> list:
    """
    Returns a list where each element at index i is the sum of nums[0:i+1].
    """
    total = 0
    result = []
    for num in nums:
        total += num
        result.append(total)
    return result


# --- Next Function Block ---



def sentence_with_most_words(sentences: list) -> list:
    """
    Returns the list of words of the sentence that has the maximum word count.
    """
    max_words = []
    for sentence in sentences:
        words = sentence.split()
        if len(words) > len(max_words):
            max_words = words
    return max_words


# --- Next Function Block ---



def prefix_difference(nums: list) -> list:
    """
    Computes two prefix sum arrays:
      - left prefix sum from the start,
      - right prefix sum from the end,
    then returns a list of absolute differences between the left prefix at index i
    and the corresponding right prefix from the opposite end.
    """
    n = len(nums)
    left = [0] * n
    right = [0] * n
    s_left = 0
    s_right = 0
    for i in range(n):
        left[i] = s_left
        s_left += nums[i]
        right[i] = s_right
        s_right += nums[n - 1 - i]
    diff = []
    for i in range(n):
        diff.append(abs(left[i] - right[n - 1 - i]))
    return diff


# --- Next Function Block ---



def print_custom_pattern(n: int) -> None:
    """
    Prints a custom pattern based on a grid of size (n*n).
    (Note: The pattern logic is derived from the given code and may be adjusted as needed.)
    """
    total = n * n
    for i in range(total):
        for j in range(total):
            # This condition is based on the provided snippet; adjust as needed.
            if (i == 0 and j == total // 2) or \
               (i > 0 and (total / 2) - 2 < j < (total / 2) + 1) or \
               (i > (total / 2) - 2 and 1 < j < 5) or \
               (i > (total / 2) - 2 and 5 < j < 9) or \
               (i > (total / 2) - 2 and total - 6 < j < total - 2) or \
               (i > (total / 2) - 2 and total - 10 < j < total - 6) or \
               (i >= total // 2) or \
               (i == 12 and 0 < j < total - 1):
                print("*", end=" ")
            else:
                print("  ", end=" ")
        print()


# --- Next Function Block ---



def convert_date(date: str) -> str:
    """
    Converts a date from format "20th Oct 2052" to "2052-10-20".
    Assumes day part may contain ordinal suffixes.
    """
    month_map = {
        "Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04",
        "May": "05", "Jun": "06", "Jul": "07", "Aug": "08",
        "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"
    }
    parts = date.split()
    day_part = parts[0]
    # Remove non-digit characters
    day = "".join(filter(str.isdigit, day_part))
    if len(day) == 1:
        day = "0" + day
    month = month_map[parts[1]]
    year = parts[2]
    return f"{year}-{month}-{day}"


# --- Next Function Block ---



def count_odds(low: int, high: int) -> int:
    """
    Counts the number of odd numbers in the inclusive range [low, high].
    """
    count = 0
    for i in range(low, high + 1):
        if i % 2 != 0:
            count += 1
    return count


# --- Next Function Block ---



def rearrange_string(s: str, indices: list) -> str:
    """
    Rearranges characters in s according to indices.
    """
    mapping = {index: char for index, char in zip(indices, s)}
    sorted_mapping = dict(sorted(mapping.items()))
    result = "".join(sorted_mapping[i] for i in sorted_mapping)
    return result


# --- Next Function Block ---



def repeat_alternate(nums: list) -> list:
    """
    For even-indexed elements in nums, repeats the element at index i+1 a number of times equal to nums[i].
    Example: For nums = [1,2,3,4], returns [2] repeated 1 time and [4] repeated 3 times => [2,4,4,4].
    """
    result = []
    for i in range(0, len(nums), 2):
        if i + 1 < len(nums):
            result.extend([nums[i+1]] * nums[i])
    return result


# --- Next Function Block ---



def first_k_words(s: str, k: int) -> str:
    """
    Returns the first k words from the string s.
    """
    words = s.split()
    return " ".join(words[:k])


# --- Next Function Block ---



def compare_word_lists(word1: list, word2: list) -> bool:
    """
    Concatenates the elements of both lists (word by word) and compares the resulting strings.
    Returns True if they are equal.
    """
    stg1 = "".join(word1)
    stg2 = "".join(word2)
    return stg1 == stg2


# --- Next Function Block ---



def sum_minus_digit_sum(nums: list) -> int:
    """
    For a list of numbers, returns the difference between the sum of the numbers and
    the sum of all their digits.
    """
    total = sum(nums)
    digit_sum = 0
    for num in nums:
        for ch in str(num):
            digit_sum += int(ch)
    return total - digit_sum


# --- Next Function Block ---



def count_pairs_with_difference(nums: list, k: int) -> int:
    """
    Counts the number of pairs (i, j) with i < j such that the absolute difference is k.
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if abs(nums[i] - nums[j]) == k:
                count += 1
    return count


# --- Next Function Block ---



def count_special_pairs(nums: list, k: int) -> int:
    """
    Counts the number of pairs (i, j) with i < j such that nums[i] == nums[j]
    and (i * j) % k == 0.
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if nums[i] == nums[j] and (i * j) % k == 0:
                count += 1
    return count


# --- Next Function Block ---



def format_number_with_dots(n: int) -> str:
    """
    Formats a number with dots as thousand separators.
    Example: 1234567 -> "1.234.567"
    """
    s = str(n)
    result = ""
    count = 0
    # Process digits from right to left.
    for ch in s[::-1]:
        if count == 3:
            result = "." + result
            count = 0
        result = ch + result
        count += 1
    return result


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the count of words that consist solely of characters in allowed.
    """
    count = 0
    for word in words:
        valid = True
        for ch in word:
            if ch not in allowed:
                valid = False
                break
        if valid:
            count += 1
    return count


# --- Next Function Block ---



def sum_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Inserts "[.]" between each segment of an IP address.
    Example: "1.1.1.1" -> "1[.]1[.]1[.]1"
    """
    parts = address.split(".")
    return "[.]".join(parts)


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Counts how many characters in stones are also in jewels.
    """
    count = 0
    for ch in stones:
        if ch in jewels:
            count += 1
    return count


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string based on the following rules:
    "G" -> "G"
    "()" -> "o"
    "(al)" -> "al"
    Example: "G()(al)" -> "Goal"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims extra spaces and redistributes spaces evenly between words.
    (A simple approach; may not cover all edge cases.)
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    # Minimum spaces between words:
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            # Distribute extra spaces to the left
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Brute-force approach to the container with most water problem.
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters that appear exactly once in s.
    If all characters are unique, returns -1.
    """
    freq = {}
    for ch in s:
        freq[ch] = freq.get(ch, 0) + 1
    unique_chars = [ch for ch, count in freq.items() if count == 1]
    if len(unique_chars) == len(s):
        return -1
    return len(unique_chars)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For characters that repeat in s, returns the maximum gap (distance - 1)
    between two occurrences. If none repeat, returns -1.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element found in nums.
    If no duplicate exists, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Capitalizes the first letter of the string.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list nums and an integer n, interleaves the first n elements with the next n elements.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Splits the string by spaces and returns the last integer found (if any).
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among the list of strings.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes email addresses by removing dots in the local part (before '+')
    and ignoring any characters after '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price, subtracts the first subsequent smaller price (if found) and stops.
    """
    adjusted = prices[:]  # copy list
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the primary and secondary diagonal of a square matrix.
    For an odd-length matrix, the center element is counted only once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---





def count_elements_based_on_min_freq(nums: list) -> int:
    """
    Sorts the list and builds a frequency dictionary.
    Finds the number (key) with the lowest frequency and then counts how many elements in the sorted list are 
    greater than or equal to that number.
    """
    nums_sorted = sorted(nums)
    freq = {}
    for num in nums_sorted:
        freq[num] = freq.get(num, 0) + 1
    sorted_freq = sorted(freq.items(), key=lambda x: x[1])
    min_elem, _ = sorted_freq[0]
    total = sum(1 for num in nums_sorted if num >= min_elem)
    return total


# --- Next Function Block ---



def print_pattern_1(n: int) -> None:
    """
    Prints a pattern based on a condition:
    For each row i (1-indexed) and each column j (0-indexed) in a grid of width n, prints a star (*) or space.
    The condition is:
      - if (j < i and i <= 3) or (i > 3 and j <= n - i): print a space
      - else: print a star.
    """
    for i in range(1, n + 1):
        for j in range(n):
            if (j < i and i <= 3) or (i > 3 and j <= n - i):
                print(" ", end="  ")
            else:
                print("*", end="  ")
        print()


# --- Next Function Block ---



def print_pattern_2(n: int) -> None:
    """
    Prints a pattern on an n*n grid.
    For each cell (i, j) where 0 <= i, j < n*n, prints a star if j < 13 - i*i or j > 11 + i*i; otherwise prints spaces.
    (The condition is taken from the snippet; adjust as needed.)
    """
    total = n * n
    for i in range(total):
        for j in range(total):
            if j < 13 - i * i or j > 11 + i * i:
                print("*", end=" ")
            else:
                print("  ", end="")
        print()


# --- Next Function Block ---



def reconstruct_from_pieces(arr: list, pieces: list) -> (bool, list):
    """
    Tries to reconstruct the array by selecting unique pieces from 'pieces' that appear in 'arr'.
    Flattens the collected pieces and compares the result with arr.
    Returns a tuple (is_equal, reconstructed_array).
    """
    collected = []
    used = []
    for piece in pieces:
        if piece not in used and any(num in arr for num in piece):
            used.append(piece)
            collected.extend(piece)
    return (collected == arr, collected)


# --- Next Function Block ---



def is_arithmetic_progression(arr: list) -> bool:
    """
    Checks if the sorted array forms an arithmetic progression.
    """
    arr = sorted(arr)
    if len(arr) < 2:
        return True
    diff = arr[1] - arr[0]
    for i in range(1, len(arr) - 1):
        if arr[i + 1] - arr[i] != diff:
            return False
    return True


# --- Next Function Block ---



def check_progressions(*arrays) -> list:
    """
    For each array provided, returns True if it forms an arithmetic progression (when sorted), otherwise False.
    """
    results = []
    for arr in arrays:
        results.append(is_arithmetic_progression(arr))
    return results


# --- Next Function Block ---



def count_word_occurrences(sequence: str, word: str) -> int:
    """
    Returns the number of non-overlapping occurrences of word in sequence.
    """
    return sequence.count(word)


# --- Next Function Block ---



def count_word_occurrences_replace(sequence: str, word: str) -> int:
    """
    Uses string replacement to calculate the number of times word appears in sequence.
    """
    reduced = sequence.replace(word, "")
    return (len(sequence) - len(reduced)) // len(word)


# --- Next Function Block ---



def compute_subtractions(n: int) -> int:
    """
    Repeatedly subtracts floor(i/2) from i until i <= 1, summing all subtractions.
    """
    count = 0
    i = n
    while i > 1:
        sub = i // 2
        i = i - sub
        count += sub
    return count


# --- Next Function Block ---



def convert_zigzag(s: str, numRows: int) -> str:
    """
    Attempts to create a zigzag conversion of s for numRows.
    (Note: This implementation follows the provided snippet's structure and may differ from the standard solution.)
    """
    if numRows == 1 or numRows >= len(s):
        return s
    result = ""
    i = 0
    diff = numRows
    while len(result) < len(s):
        if i >= len(s):
            i -= len(s)
            if i % 2 == 0:
                diff = 2
                i = 1
            else:
                diff = numRows
        result += s[i]
        i += diff
    return result


# --- Next Function Block ---



def equal_vowel_halves(s: str) -> bool:
    """
    Splits string s into two halves and returns True if both halves have the same count of vowels.
    """
    vowels = set('aeiouAEIOU')
    half = len(s) // 2
    first_half = s[:half]
    second_half = s[half:]
    return sum(1 for ch in first_half if ch in vowels) == sum(1 for ch in second_half if ch in vowels)


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Given a list of vote strings, returns the vote with the highest frequency.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each i from 0 to len(s)-1, creates a pattern of 'R' repeated i times followed by 'L' repeated i times.
    Counts the total occurrences of these patterns in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    Given a list of items (each item is a list) and a ruleKey ("type", "color", or other),
    selects the element at the corresponding position (0 for "type", 1 for "color", 2 otherwise)
    and counts how many items have ruleValue at that position.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints the grid row by row.
    """
    for row in grid:
        for elem in row:
            print(elem, end=" ")
        print()


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of numbers that appear only once in the list.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times, adding (count+pos) to the sum.
    Resets count to 0 and increments pos when count reaches 7.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Returns a new list where each element is replaced by the element at the index equal to its value.
    """
    result = []
    for i in range(len(nums)):
        result.append(nums[nums[i]])
    return result


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Computes the difference between the sum of numbers in [1, n] not divisible by m and the sum of numbers divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (for i from 1 to 31) that exists in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers: 2, 4, 6, ... up to limit*2.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor of the minimum and maximum of the list.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts to reorder a list based on a nested loop strategy and checks if the
    resulting list equals the sorted version of the original list.
    (Logic follows the provided snippet; behavior may be non-standard.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 in str1 and returns the result.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx + len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Returns the sum of the minimum value of each row in a triangle (list of lists).
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of 'digit' from 'number' and returns a tuple with the resulting string and 
    a list of indices where the digit was found.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if all elements in nums have unique frequencies.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum count between occurrences of '1' and '0' in s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Determines if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Compares the string s against two alternating patterns ("0101..." and "1010...")
    and returns the minimum number of mismatches.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Iterates over the string s and when consecutive duplicate characters are found,
    flips the second one ("0" becomes "1" and vice versa) and counts the flips.
    Returns the modified string and the count of flips.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i + 1]:
            count += 1
            s_list[i + 1] = "1" if s_list[i + 1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the vote (string) with the highest frequency from the list.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each possible i, builds a pattern with i 'R's followed by i 'L's,
    and counts how many times each such pattern appears in s.
    Returns the total count.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    For each item in items (a list of lists), checks the element at a position determined by ruleKey 
    ("type" → index 0, "color" → index 1, otherwise index 2) and counts items that equal ruleValue.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints each element of a 2D grid.
    """
    for row in grid:
        for val in row:
            print(val, end=" ")
        print()


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of numbers that appear exactly once in the list.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times while updating two counters (count and pos) and returns the sum of (count+pos) over the iterations.
    Resets count to 0 and increments pos when count reaches 7.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Creates a new list where each element is replaced by the element at the index equal to its value.
    """
    return [nums[nums[i]] for i in range(len(nums))]


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Sums numbers from 1 to n that are not divisible by m and subtracts the sum of numbers that are divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (for i in range(1, 32)) that exists in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers from 2 to 2*limit.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor of the minimum and maximum values in the list.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts a reordering of the list based on the provided snippet.
    Returns True if the concatenation of the modified sublists equals the sorted original list.
    (Note: The original logic is unclear.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 in str1 and returns the modified string.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx+len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Sums the minimum element of each row in a triangle.
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of a digit from a number (given as a string).
    Returns the resulting string and a list of indices where removals occurred.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if all numbers in nums have unique frequencies.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum between the count of '1's and '0's in the string s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Returns True if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Computes the number of mismatches between s and two alternating patterns ("0101..." and "1010...").
    Returns the smaller mismatch count.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Flips the second of any two consecutive identical characters ("0" becomes "1", "1" becomes "0").
    Returns the resulting string and the count of flips.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i + 1]:
            count += 1
            s_list[i + 1] = "1" if s_list[i + 1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the vote (string) with the highest frequency.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each possible repetition count i, builds a pattern of i 'R's followed by i 'L's,
    and sums up how many times these patterns appear in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    For a list of items (each item is a list) and a ruleKey ("type", "color", or other),
    selects the element at index 0 for "type", index 1 for "color", and index 2 otherwise,
    then counts how many items have that element equal to ruleValue.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints the elements of a 2D grid.
    """
    for row in grid:
        print(" ".join(str(x) for x in row))


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of the numbers that appear exactly once in the list.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times, updating a counter and position.
    Adds (count + pos) on each iteration; resets count after 7 iterations and increments pos.
    Returns the total sum.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Constructs a new list where each element at index i is replaced by nums[nums[i]].
    """
    return [nums[nums[i]] for i in range(len(nums))]


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Returns the difference between the sum of numbers 1 to n that are not divisible by m and the sum of those divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (for i in 1..31) found in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers from 2 to 2*limit.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor (GCD) of the minimum and maximum of nums.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts a reordering (as in the provided snippet) and returns True if the concatenation
    of modified segments equals the sorted version of the original list.
    (The logic is based on the snippet and may be non-standard.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 in str1 and returns the resulting string.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx + len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Returns the sum of the minimum elements of each row in a triangle (list of lists).
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of the specified digit from the number (as a string).
    Returns a tuple of the new string and a list of indices where the digit was found.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if the frequency of each number in nums is unique.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum count between occurrences of '1' and '0' in the string s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Returns True if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Computes the number of mismatches between s and two alternating patterns ("0101..." and "1010...").
    Returns the smaller mismatch count.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Iterates over the string s and, when two consecutive identical characters are found,
    flips the second character ("0" becomes "1" and vice versa). Returns the modified string and the count of flips.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i + 1]:
            count += 1
            s_list[i + 1] = "1" if s_list[i + 1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the candidate (vote) with the highest number of votes.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each possible repetition count i, builds a pattern of 'R'*i + 'L'*i,
    and returns the total number of occurrences of such patterns in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    Counts how many items in a list of lists have the value ruleValue at a specific index:
      - 0 for ruleKey "type"
      - 1 for ruleKey "color"
      - 2 otherwise.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of numbers in the list that appear exactly once.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times, updating counters 'count' and 'pos'. Adds (count+pos) to the sum,
    resets count to 0 and increments pos after 7 iterations. Returns the final sum.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Creates a new list by mapping each index i to the element at index nums[i].
    """
    return [nums[nums[i]] for i in range(len(nums))]


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Computes the difference between the sum of numbers 1 to n that are not divisible by m
    and the sum of numbers that are divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (i * n for some i in 1..31) that is present in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers from 2 to 2*limit.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor (GCD) of the minimum and maximum values in nums.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts a reordering based on the provided logic and returns True if the concatenation of 
    modified segments equals the sorted original list.
    (The logic is directly derived from the snippet and might be non-standard.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 in str1 and returns the result.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx + len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Returns the sum of the minimum elements from each row of a triangle (list of lists).
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of the given digit from the string 'number'.
    Returns a tuple with the new string and the list of indices where the digit was found.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if each number in nums has a unique frequency.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum count between the number of '1's and '0's in s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Returns True if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Compares s against two alternating patterns ("0101..." and "1010...") and returns the minimum mismatch count.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Flips the second character in any pair of consecutive identical characters ("0" <-> "1")
    and returns the modified string along with the count of flips.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i + 1]:
            count += 1
            s_list[i + 1] = "1" if s_list[i + 1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the candidate with the highest vote count.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each possible i (0 <= i < len(s)), builds a pattern of i 'R's followed by i 'L's and sums
    the occurrences of these patterns in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    Counts how many items (each a list) have ruleValue at a position determined by ruleKey:
      - 0 for "type"
      - 1 for "color"
      - 2 otherwise.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints a 2D grid.
    """
    for row in grid:
        print(" ".join(str(x) for x in row))


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of numbers in nums that appear exactly once.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times, updating two counters (count and pos), adding (count+pos) each time.
    Resets count after 7 iterations and increments pos. Returns the total sum.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Returns a new list where each element is replaced by the element at index equal to its value.
    """
    return [nums[nums[i]] for i in range(len(nums))]


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Computes the difference between the sum of numbers from 1 to n that are not divisible by m 
    and the sum of numbers that are divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (for i in 1..31) that is present in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers from 2 to 2*limit.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor of the minimum and maximum values in nums.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts a reordering based on a nested deletion loop and returns True if the concatenation 
    of the removed elements and the remaining list equals the sorted original list.
    (Logic is directly based on the snippet and may be non-standard.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 from str1 and returns the resulting string.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx+len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Returns the sum of the minimum element from each row of a triangle.
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of a given digit from the number (as a string).
    Returns a tuple containing the new string and a list of indices where the digit was removed.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if all numbers in nums have unique frequencies.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum count between occurrences of '1' and '0' in s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Returns True if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Computes the mismatch count between s and two alternating patterns ("0101..." and "1010...")
    and returns the minimum of the two counts.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Iterates over s and flips the second character of any adjacent duplicate pair
    (switching '0' to '1' and vice versa). Returns the modified string and the flip count.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i+1]:
            count += 1
            s_list[i+1] = "1" if s_list[i+1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the candidate with the highest vote count from the list.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each i (from 0 to len(s)-1), creates a pattern of 'R'*i followed by 'L'*i,
    and sums the number of times such patterns occur in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    For a list of items (each a list), returns the count of items where the element at position 
    (0 for "type", 1 for "color", 2 otherwise) equals ruleValue.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def sum_of_prefix_differences(nums: list) -> list:
    """
    Computes two prefix sum arrays (left from the start and right from the end) and returns 
    a list of absolute differences between corresponding elements.
    """
    n = len(nums)
    left = [0] * n
    right = [0] * n
    s_left, s_right = 0, 0
    for i in range(n):
        left[i] = s_left
        s_left += nums[i]
        right[i] = s_right
        s_right += nums[n - 1 - i]
    return [abs(left[i] - right[n - 1 - i]) for i in range(n)]


# --- Next Function Block ---



def print_custom_pattern(n: int) -> None:
    """
    Prints a pattern on an n*n grid.
    The pattern logic follows the snippet condition: if j < 13 - i*i or j > 11 + i*i, print "*"; else print spaces.
    """
    total = n * n
    for i in range(total):
        for j in range(total):
            if j < 13 - i * i or j > 11 + i * i:
                print("*", end=" ")
            else:
                print("  ", end="")
        print()


# --- Next Function Block ---



def convert_date(date: str) -> str:
    """
    Converts a date from a format like "20th Oct 2052" to "2052-10-20".
    Assumes the day part may have ordinal suffixes.
    """
    month_map = {"Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04",
                 "May": "05", "Jun": "06", "Jul": "07", "Aug": "08",
                 "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"}
    parts = date.split()
    day = "".join(filter(str.isdigit, parts[0]))
    if len(day) == 1:
        day = "0" + day
    month = month_map[parts[1]]
    year = parts[2]
    return f"{year}-{month}-{day}"


# --- Next Function Block ---



def count_odds_in_range(low: int, high: int) -> int:
    """
    Returns the count of odd numbers in the inclusive range [low, high].
    """
    return sum(1 for i in range(low, high + 1) if i % 2 != 0)


# --- Next Function Block ---



def rearrange_string(s: str, indices: list) -> str:
    """
    Rearranges the characters in s according to the provided indices.
    """
    mapping = {idx: ch for idx, ch in zip(indices, s)}
    sorted_mapping = dict(sorted(mapping.items()))
    return "".join(sorted_mapping[i] for i in sorted_mapping)


# --- Next Function Block ---



def repeat_alternate(nums: list) -> list:
    """
    For every even-indexed element in nums, repeats the element at index i+1 a number of times equal to nums[i].
    Returns the resulting list.
    Example: for nums = [1,2,3,4], returns [2,4,4,4].
    """
    result = []
    for i in range(0, len(nums), 2):
        if i + 1 < len(nums):
            result.extend([nums[i+1]] * nums[i])
    return result


# --- Next Function Block ---



def first_k_words(s: str, k: int) -> str:
    """
    Returns the first k words from the string s.
    """
    words = s.split()
    return " ".join(words[:k])


# --- Next Function Block ---



def compare_word_lists(word1: list, word2: list) -> bool:
    """
    Concatenates the lists of strings and returns True if the resulting strings are equal.
    """
    return "".join(word1) == "".join(word2)


# --- Next Function Block ---



def sum_minus_digit_sum(nums: list) -> int:
    """
    Returns the difference between the sum of numbers in nums and the sum of all their digits.
    """
    total = sum(nums)
    digit_sum = sum(int(ch) for num in nums for ch in str(num))
    return total - digit_sum


# --- Next Function Block ---



def count_pairs_with_difference(nums: list, k: int) -> int:
    """
    Counts unique pairs (i, j) with i < j in nums such that abs(nums[i] - nums[j]) == k.
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if abs(nums[i] - nums[j]) == k:
                count += 1
    return count


# --- Next Function Block ---



def count_special_pairs(nums: list, k: int) -> int:
    """
    Counts pairs (i, j) with i < j where nums[i] equals nums[j] and (i*j) % k == 0.
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if nums[i] == nums[j] and (i * j) % k == 0:
                count += 1
    return count


# --- Next Function Block ---



def format_number_with_dots(n: int) -> str:
    """
    Formats the integer n by inserting dots as thousand separators.
    Example: 1234567 -> "1.234.567"
    """
    s = str(n)
    result = ""
    count = 0
    for ch in s[::-1]:
        if count == 3:
            result = "." + result
            count = 0
        result = ch + result
        count += 1
    return result


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the count of words in the list that contain only characters from allowed.
    """
    count = 0
    for word in words:
        if all(ch in allowed for ch in word):
            count += 1
    return count


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Formats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are also in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string: "G" remains, "()" becomes "o", and "(al)" becomes "al".
    Example: "G()(al)" -> "Goal"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims the text and redistributes spaces evenly between words.
    (A simple implementation that may not cover all edge cases.)
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area for the container with most water problem (brute force approach).
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For characters that repeat in s, returns the maximum gap (distance minus one)
    between two occurrences. If none repeat, returns -1.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps)


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums; if none exist, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Capitalizes the first letter of the string.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list 'nums' of length 2*n, interleaves the first n elements with the next n elements.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Splits s by spaces and returns the last integer found, or 0 if none.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Finds the longest common prefix among the list of strings using a brute-force approach.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes a list of emails by removing dots and ignoring characters after '+' in the local part.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price in the list, finds the first subsequent smaller price and subtracts it from the current price.
    Returns the modified list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the primary and secondary diagonal of a square matrix.
    If the matrix has an odd center, that value is subtracted once (since it was counted twice).
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the count of words in the list that contain only characters from allowed.
    """
    count = 0
    for word in words:
        if all(ch in allowed for ch in word):
            count += 1
    return count


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the number of characters in stones that are present in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string:
      "G" remains "G",
      "()" becomes "o",
      "(al)" becomes "al".
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels (starting from 'A').
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims the text and redistributes spaces evenly between words.
    (A simple approach; edge cases may vary.)
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area that can be formed by two lines in the list 'height'.
    (Brute-force O(n^2) approach.)
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For each character that repeats in s, computes the gap (difference in indices minus one)
    between its first and last occurrence. Returns the maximum such gap; if no repeats, returns -1.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums.
    If there are no duplicates, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Returns s with its first letter capitalized.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first half with the second half.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Returns the last integer found in s when splitting by spaces.
    If no integer is found, returns 0.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among the list of strings using a brute-force approach.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates in-place from a sorted list and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes emails by removing dots from the local part and ignoring everything after a '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price in prices, finds the first subsequent smaller price and subtracts it from the current price.
    Returns the adjusted list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the main and secondary diagonals of a square matrix.
    For odd-sized matrices, the center element is subtracted once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the number of words that consist solely of characters in allowed.
    """
    count = 0
    for word in words:
        if all(ch in allowed for ch in word):
            count += 1
    return count


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing each '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the number of characters in stones that are also in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string:
      - "G" -> "G"
      - "()" -> "o"
      - "(al)" -> "al"
    Example: "G()(al)" -> "Goal"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels (starting from 'A').
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims extra spaces from the text and redistributes spaces evenly between words.
    (Simple implementation.)
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area that can be formed by two indices in height (brute-force approach).
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For characters that repeat in s, returns the maximum gap (index difference minus one)
    between two occurrences. Returns -1 if no character repeats.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums, or None if there is none.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Returns the string s with its first letter capitalized.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first n elements with the last n elements.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Splits s by spaces and returns the last integer found, or 0 if none.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Finds the longest common prefix among the given list of strings.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes emails by removing dots in the local part and ignoring characters after '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price, finds the first subsequent smaller price and subtracts it from the current price.
    Returns the adjusted list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the main and secondary diagonals of a square matrix.
    If the matrix has an odd center, subtracts the center value once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the count of words that consist solely of characters in allowed.
    """
    return sum(1 for word in words if all(ch in allowed for ch in word))


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all odd-length subarrays of arr.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are also in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Interprets the command string:
      - "G" becomes "G"
      - "()" becomes "o"
      - "(al)" becomes "al"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims and redistributes spaces evenly between words in the text.
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum container area using a brute-force approach.
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters that appear exactly once in s.
    If all characters are unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For characters that repeat in s, returns the maximum gap (difference in indices minus one).
    Returns -1 if no character repeats.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums; returns None if there are no duplicates.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Returns the string s with its first letter capitalized.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first half with the second half.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Returns the last integer found in s when splitting by spaces, or 0 if none.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among the given strings using a brute-force method.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates in-place from a sorted list and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes email addresses by removing dots in the local part (before '+')
    and ignoring any characters after '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price in prices, subtracts the first subsequent smaller price (if found) and returns the modified list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of both the primary and secondary diagonals of a square matrix.
    If the matrix has an odd dimension, subtracts the center element once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the number of words that contain only characters found in allowed.
    """
    return sum(1 for word in words if all(ch in allowed for ch in word))


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing each '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the number of characters in stones that are also in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Interprets a command string:
      - "G" remains "G"
      - "()" becomes "o"
      - "(al)" becomes "al"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims the text and evenly redistributes spaces between words.
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area that can be formed between two lines in the list 'height'.
    (Brute-force approach.)
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    Returns the maximum gap (difference in indices minus one) between any two occurrences 
    of the same character in s. Returns -1 if no repeats exist.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element found in nums. Returns None if there is no duplicate.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Returns s with its first character capitalized.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first half with the second half.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Splits s by spaces and returns the last integer found; returns 0 if none is found.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among a list of strings using a brute-force approach.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates in-place from a sorted list and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes a list of emails by removing dots ('.') from the local part and ignoring everything after a '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price, finds the first subsequent smaller price and subtracts it from the current price.
    Returns the adjusted list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the primary and secondary diagonals of a square matrix.
    For odd dimensions, the center element is subtracted once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n//2][n//2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the number of words that consist only of characters in allowed.
    """
    return sum(1 for word in words if all(ch in allowed for ch in word))


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are also present in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string by mapping:
      "G" -> "G"
      "()" -> "o"
      "(al)" -> "al"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims extra spaces from text and evenly redistributes them between words.
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area that can be contained between two lines in the list height.
    (Brute-force approach.)
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For each character that repeats in s, returns the maximum gap (index difference minus one)
    between any two occurrences. If no character repeats, returns -1.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums, or None if no duplicate exists.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Capitalizes the first letter of s.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first half with the second half.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Returns the last integer found in s after splitting by spaces; returns 0 if none.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among a list of strings.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes emails by removing '.' from the local part and ignoring characters after '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price in prices, subtracts the first subsequent smaller price (if any) from it.
    Returns the adjusted list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the primary and secondary diagonals of a square matrix.
    If the matrix size is odd, the center element is counted only once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the number of words composed solely of characters in allowed.
    """
    return sum(1 for word in words if all(ch in allowed for ch in word))


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all odd-length subarrays of arr.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string by mapping:
      "G" -> "G",
      "()" -> "o",
      "(al)" -> "al".
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims the text and redistributes spaces evenly between words.
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return re


# --- Next Function Block ---


# patterns.py

def count_elements_geq_lowest_freq(nums: list) -> int:
    """
    Sorts the list, builds a frequency dictionary, then finds the smallest frequency entry.
    Returns the count of numbers in nums that are greater than or equal to the key
    of the lowest-frequency element.
    Example:
      nums = [3,9,7,8,3,8,6,6]
      Sorted nums: [3,3,6,6,7,8,8,9]
      Frequency: {3:2, 6:2, 7:1, 8:2, 9:1}
      Lowest frequency entry: (7,1)
      Count numbers >= 7 → 7,8,8,9 → 4
    """
    nums.sort()
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    # Get the (number, count) pair with the minimum count
    low = sorted(freq.items(), key=lambda x: x[1])[0]
    total = sum(1 for num in nums if num >= low[0])
    return total


# --- Next Function Block ---



def print_pattern_1(n: int) -> None:
    """
    Prints a pattern for n rows.
    (Based on the snippet with two nested loops and conditional spacing.)
    """
    for i in range(1, n + 1):
        for j in range(n):
            # Example condition: for i <= 3, print spaces for j < i; for i > 3, print spaces for j <= n-i.
            if (j < i and i <= 3) or (i > 3 and j <= n - i):
                print(" ", end="  ")
            else:
                print("*", end="  ")
        print("\n", end="")


# --- Next Function Block ---



def print_pattern_2(n: int) -> None:
    """
    Prints a second pattern based on an n*n grid.
    (The conditions are taken from the provided snippet.)
    """
    total = n * n
    for i in range(total):
        for j in range(total):
            # The condition is taken as provided; adjust if needed.
            if j < 13 - i * i or j > 11 + i * i:
                print("*", end=" ")
            else:
                print("  ", end="")
        print("\n", end="")


# --- Next Function Block ---



def convert_date(date: str) -> str:
    """
    Converts a date string like "20th Oct 2052" to the format "2052-10-20".
    """
    month_map = {
        "Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04",
        "May": "05", "Jun": "06", "Jul": "07", "Aug": "08",
        "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"
    }
    parts = date.split(" ")
    # Remove non-digit characters from the day part.
    day = "".join(ch for ch in parts[0] if ch.isdigit())
    if len(day) == 1:
        day = "0" + day
    month = month_map[parts[1]]
    year = parts[2]
    return f"{year}-{month}-{day}"


# --- Next Function Block ---



def count_odds_in_range(low: int, high: int) -> int:
    """
    Counts the number of odd numbers in the inclusive range [low, high].
    """
    count = 0
    for i in range(low, high + 1):
        if i % 2 != 0:
            count += 1
    return count


# --- Next Function Block ---



def reorder_string(s: str, indices: list) -> str:
    """
    Reorders string s based on the list of indices.
    Example:
       s = "codeleet", indices = [4,5,6,7,0,2,1,3] → returns "leetcode"
    """
    mapping = {idx: ch for idx, ch in zip(indices, s)}
    # Sort by index and join the characters.
    result = "".join(mapping[i] for i in sorted(mapping))
    return result


# --- Next Function Block ---



def running_sum(nums: list) -> list:
    """
    Returns a list of the running (cumulative) sum of nums.
    """
    total = 0
    result = []
    for num in nums:
        total += num
        result.append(total)
    return result


# --- Next Function Block ---



def sentence_with_most_words(sentences: list) -> list:
    """
    Splits each sentence into words and returns the word list for the sentence with the most words.
    """
    max_words = []
    for sentence in sentences:
        words = sentence.split()
        if len(words) > len(max_words):
            max_words = words
    return max_words


# --- Next Function Block ---



def prefix_diff(nums: list) -> list:
    """
    Computes two arrays:
      - left prefix sums (excluding current index)
      - right prefix sums (from the end)
    Returns a list of absolute differences between left prefix at index i and the reversed right prefix.
    """
    n = len(nums)
    left = []
    right = []
    s_left = 0
    s_right = 0
    for i in range(n):
        left.append(s_left)
        s_left += nums[i]
        right.append(s_right)
        s_right += nums[n - 1 - i]
    diff = []
    for i in range(n):
        diff.append(abs(left[i] - right[n - 1 - i]))
    return diff


# --- Next Function Block ---



def count_frequency_and_elements(nums: list) -> int:
    """
    Builds a frequency dictionary for nums, then finds the entry with the lowest frequency.
    Counts and prints indices and values for numbers in nums that are greater than or equal to the key
    of that lowest-frequency entry. Returns the total count.
    """
    nums.sort()
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    # Get the (number, count) pair with the minimum frequency.
    low = sorted(freq.items(), key=lambda x: x[1])[0]
    total = 0
    for i, num in enumerate(nums):
        if num >= low[0]:
            total += 1
            print(i, num)
    return total


# --- Next Function Block ---



def validate_pieces(arr: list, pieces: list) -> bool:
    """
    Given an array 'arr' and a list of lists 'pieces', attempts to reassemble arr
    by selecting pieces (each piece is a list of integers) if their elements appear in arr.
    Returns True if the concatenated pieces equal arr; otherwise, False.
    (Logic is based on the snippet and may need adjustment.)
    """
    assembled = []
    used = []
    # For each piece in pieces, if not already used and if its elements appear in arr, add it.
    for piece in pieces:
        if piece not in used and all(x in arr for x in piece):
            assembled.extend(piece)
            used.append(piece)
    return assembled == arr


# --- Next Function Block ---



def is_arithmetic_sequence(arr: list) -> bool:
    """
    Checks if the sorted list arr forms an arithmetic sequence.
    """
    if len(arr) < 2:
        return True
    arr = sorted(arr)
    diff = arr[1] - arr[0]
    for i in range(1, len(arr)):
        if arr[i] - arr[i - 1] != diff:
            return False
    return True


# --- Next Function Block ---



def are_all_arithmetic(lists: list) -> list:
    """
    Given a list of lists (each list of numbers), returns a list of booleans indicating whether
    each individual list is an arithmetic sequence.
    """
    result = []
    for lst in lists:
        result.append(is_arithmetic_sequence(lst))
    return result


# --- Next Function Block ---



def max_occurrences_of_word(sequence: str, word: str) -> int:
    """
    Returns the maximum number of non-overlapping occurrences of 'word' in 'sequence'.
    (Uses both a replace method and the built-in count for verification.)
    """
    count_builtin = sequence.count(word)
    # Alternatively, you might iterate over sequence to count non-overlapping occurrences.
    i, count = 0, 0
    while i <= len(sequence) - len(word):
        if sequence[i:i+len(word)] == word:
            count += 1
            i += len(word)
        else:
            i += 1
    # Return whichever count is higher (they should be equal if word does not overlap)
    return max(count, count_builtin)


# --- Next Function Block ---



def sum_halves(n: int) -> int:
    """
    Given n, repeatedly subtract half (floor division) until i <= 1.
    Returns the sum of all subtracted values.
    """
    count = 0
    while n > 1:
        sub = n // 2
        n = n - sub
        count += sub
    return count


# --- Next Function Block ---



def zigzag_convert(s: str, numRows: int) -> str:
    """
    Converts the string s into a zigzag pattern on numRows and reads line by line.
    (A simplified version of the zigzag conversion problem.)
    """
    if numRows == 1 or numRows >= len(s):
        return s
    rows = [''] * numRows
    cur_row, step = 0, 1
    for char in s:
        rows[cur_row] += char
        if cur_row == 0:
            step = 1
        elif cur_row == numRows - 1:
            step = -1
        cur_row += step
    return "".join(rows)


# --- Next Function Block ---



def equal_half_vowels(s: str) -> bool:
    """
    Checks if the first half and second half of string s have the same number of vowels.
    Assumes s length is even.
    """
    vowels = set("aeiouAEIOU")
    half = len(s) // 2
    first_half = s[:half]
    second_half = s[half:]
    count_first = sum(1 for ch in first_half if ch in vowels)
    count_second = sum(1 for ch in second_half if ch in vowels)
    return count_first == count_second


# --- Next Function Block ---



def election_winner(votes: list) -> str:
    """
    Given a list of votes (strings), returns the candidate with the most votes.
    """
    vote_counts = {}
    for vote in votes:
        vote_counts[vote] = vote_counts.get(vote, 0) + 1
    # Find candidate with maximum votes
    winner = max(vote_counts.items(), key=lambda x: x[1])[0]
    return winner


# --- Next Function Block ---



def count_special_substrings(s: str, r: str = "R", l: str = "L") -> int:
    """
    Constructs substrings of the form r repeated i times concatenated with l repeated i times,
    counts occurrences in s.
    """
    count_total = 0
    for i in range(1, len(s) + 1):
        substr = r * i + l * i
        if substr in s:
            occurrence = s.count(substr)
            print(substr, occurrence)
            count_total += occurrence
    return count_total


# --- Next Function Block ---



def count_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    Given a list of item lists and a rule specified by ruleKey ("type", "color", or "name"),
    counts how many items have the ruleValue at the corresponding index.
    Assumes: type → index 0, color → index 1, name → index 2.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints all elements of a 2D grid.
    """
    for row in grid:
        for elem in row:
            print(elem, end=" ")
        print()


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Sums numbers that appear only once in the list.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def sum_with_pattern(n: int) -> int:
    """
    For n iterations, accumulates a sum based on an increasing count and a position that resets every 7 counts.
    """
    total = 0
    count = 0
    pos = 1
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_mapping(nums: list) -> list:
    """
    Returns a new list where each element is nums[nums[i]].
    Assumes that all nums[i] are valid indices.
    """
    return [nums[x] for x in nums]


# --- Next Function Block ---



def sum_diff_by_divisibility(n: int, m: int) -> int:
    """
    Sums numbers from 1 to n that are not divisible by m and subtracts the sum of numbers that are divisible by m.
    """
    total_non_div = 0
    total_div = 0
    for i in range(1, n + 1):
        if i % m == 0:
            total_div += i
        else:
            total_non_div += i
    return total_non_div - total_div


# --- Next Function Block ---



def first_multiple_in_list(n: int, arr: list) -> int:
    """
    Returns the first multiple of n that is present in arr.
    """
    i = 1
    while True:
        multiple = i * n
        if multiple in arr:
            return multiple
        i += 1


# --- Next Function Block ---


def first_n_evens(n: int) -> list:
    """
    Returns a list of the first n even numbers.
    """
    return [i * 2 for i in range(1, n + 1)]


# --- Next Function Block ---


def gcd_from_list(nums: list) -> int:
    """
    Returns the greatest common divisor (GCD) of the minimum and maximum elements in nums.
    (Assumes positive numbers.)
    """
    from math import gcd
    low = min(nums)
    high = max(nums)
    return gcd(low, high)


# --- Next Function Block ---


def has_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    (This happens if n is a perfect square of a prime.)
    """
    import math
    if n < 4:
        return False
    sqrt_n = math.isqrt(n)
    if sqrt_n * sqrt_n != n:
        return False
    # Check if sqrt_n is prime.
    for i in range(2, int(math.sqrt(sqrt_n)) + 1):
        if sqrt_n % i == 0:
            return False
    return True


# --- Next Function Block ---


def custom_sort_validation(nums: list) -> bool:
    """
    Attempts a custom sort by removing and appending elements.
    Returns True if the custom-sorted list equals the actual sorted list.
    (Logic based on the provided snippet.)
    """
    original = nums[:]
    target = sorted(nums)
    arr = []
    i = 0
    # Use a copy for processing.
    temp = nums[:]
    while i < len(temp) - 1:
        if temp[i+1] < temp[i]:
            # Append the element at i+1 and remove it.
            arr.append(temp[i+1])
            del temp[i+1]
        else:
            i += 1
    result = arr + temp
    return result == target


# --- Next Function Block ---


def custom_remove_substring(str1: str, str2: str) -> str:
    """
    (Based on the provided snippet)
    If str2 is in str1, finds the first occurrence indices and removes that part.
    Otherwise returns str1.
    Note: If str2 is empty, returns str1.
    """
    if not str2:
        return str1
    idx = str1.find(str2)
    if idx != -1:
        return str1[:idx] + str1[idx+len(str2):]
    return str1


# --- Next Function Block ---


def sum_of_triangle_row_mins(triangle: list) -> int:
    """
    Given a triangle (list of lists), returns the sum of the minimum value in each row.
    """
    total = 0
    for row in triangle:
        total += min(row)
    return total


# --- Next Function Block ---


def remove_digit_and_record_indices(number: str, digit: str) -> (str, list):
    """
    Removes occurrences of digit from number and records the indices (of digit in original).
    Returns a tuple of (modified string, list of indices where digit was found).
    """
    indices = []
    result = ""
    for idx, ch in enumerate(number):
        if ch == digit:
            indices.append(idx)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---


def check_frequency_uniqueness(arr: list) -> bool:
    """
    Returns True if the sorted list of frequencies of elements equals the sorted unique frequencies.
    (Based on the provided snippet.)
    """
    freq = {}
    for num in arr:
        freq[num] = freq.get(num, 0) + 1
    freq_vals = sorted(freq.values())
    unique_vals = sorted(set(freq_vals))
    return freq_vals == unique_vals


# --- Next Function Block ---


def sum_of_divisible_elements(n: int) -> int:
    """
    For n = 7 (example), sums numbers from 1 to n and returns the difference between sum of numbers
    not divisible by a given condition and those that are divisible.
    (Based on the snippet where numbers divisible by m are summed separately.)
    This version uses m = 3 as in the snippet.
    """
    sum_non = 0
    sum_div = 0
    for i in range(1, n + 1):
        if i % 3 == 0:
            sum_div += i
        else:
            sum_non += i
    return sum_non - sum_div


# --- Next Function Block ---


def first_duplicate_in_list(nums: list):
    """
    Returns the first duplicate element in nums. If none found, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---


def rotate_array_right(nums: list, k: int) -> list:
    """
    Rotates the list nums to the right by k positions.
    """
    n = len(nums)
    k %= n
    return nums[-k:] + nums[:-k]


# --- Next Function Block ---


def sum_of_subarrays_with_odd_length(arr: list) -> int:
    """
    Sums all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---


def reformat_ip(address: str) -> str:
    """
    Reformats an IP address by inserting "[.]" between segments.
    Example: "1.1.1.1" -> "1[.]1[.]1[.]1"
    """
    parts = address.split(".")
    return "[.]".join(parts)


# --- Next Function Block ---


def count_jewels_in_stones(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are in jewels.
    """
    count = 0
    for ch in stones:
        if ch in jewels:
            count += 1
    return count


# --- Next Function Block ---


def interpret_command(command: str) -> str:
    """
    Interprets the command string:
      - "G" remains "G"
      - "()" is replaced by "o"
      - "(al)" is replaced by "al"
    Example: "G()(al)" -> "Goal"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---


def excel_columns(n: int) -> list:
    """
    Returns a list of the first n Excel column labels starting from 'A'.
    """
    return [chr(ord('A') + i) for i in range(n)]


# --- Next Function Block ---


def reformat_text(text: str) -> str:
    """
    Trims extra spaces and redistributes spaces evenly between words.
    (Simple approach: assumes extra spaces are those beyond single spaces.)
    """
    words = text.strip().split()
    return " ".join(words)


# --- Next Function Block ---




# patterns.py

# 1. Given a number, sort its digits and compute the sum of the integer
#    formed by concatenating the smallest and largest digit with the remaining two in order.
def sorted_digits_sum(num: int) -> int:
    """
    Converts num to its digit list, sorts the digits, then returns:
      int(sorted[0] + sorted[3]) + int(sorted[1] + sorted[2])
    Example: 2932 -> digits sorted = ['2','2','3','9'] → int('2'+'9') + int('2'+'3') = 29 + 23 = 52.
    """
    s = str(num)
    arr = list(s)
    arr.sort()
    # Concatenate first and last digit; then second and third.
    return int(arr[0] + arr[3]) + int(arr[1] + arr[2])


# --- Next Function Block ---



# 2. Alternating digit sum: add digits at even indices, subtract at odd.
def alternating_digit_sum(n: int) -> int:
    """
    Converts n to a string and alternately adds and subtracts digits.
    Example: 111 -> (1 - 1 + 1) = 1.
    """
    s = str(n)
    total = 0
    for i in range(len(s)):
        if i % 2 == 0:
            total += int(s[i])
        else:
            total -= int(s[i])
    return total


# --- Next Function Block ---



# 3. Extract all digits from a list of numbers.
def extract_digits(nums: list) -> list:
    """
    For each number in nums, extracts its digits and returns a flat list of all digits.
    Example: [13,25] -> [1, 3, 2, 5]
    """
    result = []
    for num in nums:
        for ch in str(num):
            result.append(int(ch))
    return result


# --- Next Function Block ---



# 4. Count numbers (1 to num) whose digit sum is even.
def count_even_digit_sum(num: int) -> int:
    """
    For every number from 1 to num, computes the sum of digits (printing each sum),
    and counts how many have an even digit sum.
    """
    count = 0
    for i in range(1, num + 1):
        s = str(i)
        digit_sum = sum(int(ch) for ch in s)
        # Uncomment the next line to print each sum:
        # print(digit_sum)
        if digit_sum % 2 == 0:
            count += 1
    return count


# --- Next Function Block ---



# 5. Letter-sum transformation.
def letter_sum_transformation(s: str, k: int) -> int:
    """
    Maps each letter in s to a number (a->1, b->2, ..., z->26) by concatenation.
    Then, for k iterations, sums all digits of the resulting string and reassigns.
    Finally, returns the final integer.
    Example: s="iiii", k=2.
    """
    mapping = {
        "a": "1", "b": "2", "c": "3", "d": "4", "e": "5",
        "f": "6", "g": "7", "h": "8", "i": "9", "j": "10",
        "k": "11", "l": "12", "m": "13", "n": "14", "o": "15",
        "p": "16", "q": "17", "r": "18", "s": "19", "t": "20",
        "u": "21", "v": "22", "w": "23", "x": "24", "y": "25", "z": "26"
    }
    res = ""
    for ch in s:
        res += mapping[ch]
    for _ in range(k):
        ssum = sum(int(ch) for ch in res)
        res = str(ssum)
    return int(res)


# --- Next Function Block ---



# 6. For a list of strings, for each pair compute a boolean array indicating for each letter in the first
#    string whether it is absent in the second; then find the maximum length of such an array that contains True.
def common_prefix_discrepancy(strs: list) -> (int, list):
    """
    For each pair (i, j) (i < j) in strs, builds an array with True where a character of strs[i]
    is not in strs[j], False otherwise. Then returns the maximum length among those arrays
    that contain at least one True, along with the list of arrays.
    (The logic is based on the provided snippet and may be interpreted.)
    """
    arrays = []
    max_len = -1
    for i in range(len(strs) - 1):
        for j in range(i + 1, len(strs)):
            arr = []
            for ch in strs[i]:
                if ch in strs[j]:
                    arr.append(False)
                else:
                    arr.append(True)
            arrays.append(arr)
            if True in arr and len(arr) > max_len:
                max_len = len(arr)
    return max_len, arrays


# --- Next Function Block ---



# 7. Compute a cost using total, cost1 and cost2.
def compute_cost(total: int, cost1: int, cost2: int) -> int:
    """
    Given total money and two costs, ensures cost1 is smaller than cost2,
    then simulates a purchase process and returns a computed value.
    (Logic is based on the provided snippet.)
    """
    if cost2 > cost1:
        # Swap cost1 and cost2 if needed.
        cost1, cost2 = cost2, cost1
    prd = 0
    for i in range(total // cost1):
        ttl = total - cost1 * i
        count = 1
        while ttl > 0:
            count += 1
            ttl -= cost2
        if ttl == 0:
            prd += count
    return prd + 1


# --- Next Function Block ---



# 8. Decode a string of the form "a1c1e1" into letters by shifting the previous letter.
def decode_string(s: str) -> str:
    """
    For each character in s, if it's a letter, output it.
    If it's a digit, take the previous letter's index in the alphabet and shift by that digit.
    Example: "a1c1e1" becomes "abcdef" (depending on dictionary).
    """
    alpha = "abcdefghijklmnopqrstuvwxyz"
    res = ""
    for i in range(len(s)):
        if s[i].isalpha():
            res += s[i]
        else:
            # s[i] is digit; shift previous letter.
            prev = s[i-1]
            ind = alpha.index(prev) + int(s[i])
            res += alpha[ind % 26]
    return res


# --- Next Function Block ---



# 9. Find the first index of target in nums, starting at index start.
def find_index(nums: list, target: int, start: int) -> int:
    """
    Returns the first index of target in nums, starting from start.
    If not found, returns -1.
    """
    for i in range(start, len(nums)):
        if nums[i] == target:
            return i
    return -1


# --- Next Function Block ---



# 10. Return substring of a numeric string up to and including the last odd digit (scanning from right).
def last_odd_substring(num: str) -> str:
    """
    Returns the substring of num up to (and including) the last odd digit when scanning from right.
    """
    for i in reversed(range(len(num))):
        if int(num[i]) % 2 == 1:
            return num[:i+1]
    return ""


# --- Next Function Block ---



# 11. Return the maximum digit that appears at least 3 times in num, repeated three times.
def triple_max_frequent_digit(num: str) -> str:
    """
    Finds all digits that appear at least 3 times in num.
    Returns the maximum such digit repeated three times.
    """
    freq = {}
    candidates = []
    for ch in num:
        freq[ch] = freq.get(ch, 0) + 1
        if freq[ch] >= 3 and int(ch) not in candidates:
            candidates.append(int(ch))
    if candidates:
        return str(max(candidates)) * 3
    return ""


# --- Next Function Block ---



# 12. Alternate approach: Check for each digit if its triple exists in num and choose the maximum.
def triple_max_digit_condition(num: str) -> str:
    """
    Checks each digit in num; if digit repeated three times is a substring,
    and the digit is larger than the current candidate, update candidate.
    Returns the candidate digit repeated three times.
    """
    grt = -1
    for ch in num:
        if (ch * 3) in num and int(ch) > grt:
            grt = int(ch)
    return str(grt) * 3 if grt > -1 else ""


# --- Next Function Block ---



# 13. Count keys in a dictionary.
def dict_key_count(d: dict) -> int:
    """
    Returns the number of keys in dictionary d.
    """
    return len(d)


# --- Next Function Block ---



# 14. Check if both left and right values appear in any of the given ranges.
def check_range(ranges: list, left: int, right: int) -> bool:
    """
    Checks if left and right exist in any range (list of two numbers) from ranges.
    Returns True if both found; otherwise False.
    """
    isLeft = False
    isRight = False
    for r in ranges:
        if left in r or isLeft:
            isLeft = True
            if right in r:
                isRight = True
    return isLeft and isRight


# --- Next Function Block ---



# 15. Simulate a lock. Given a starting lock (e.g. ["0","0","0","0"]) and a target lock as a string,
#     increment digits until lock equals target; count the moves.
def open_lock(target: str) -> (list, int):
    """
    Starting from ["0", "0", "0", "0"], increments individual digits (left-to-right)
    until the lock matches target. Returns the final lock state (as a list of strings) and the move count.
    """
    lock = ["0", "0", "0", "0"]
    target_list = list(target)
    count = 0
    i = 0
    while lock != target_list and i < len(lock):
        if lock[i] != target_list[i]:
            # Increment digit by 1 (as string)
            lock[i] = str(int(lock[i]) + 1)
            count += 1
        else:
            i += 1
    return lock, count


# --- Next Function Block ---



# 16. Count Pythagorean triplets (brute force) for numbers 1 to num.
def count_pythagorean_triplets(num: int) -> int:
    """
    Counts the number of Pythagorean triplets (idx, jdx, kdx) with 1 <= idx, jdx, kdx <= num.
    """
    count = 0
    for a in range(1, num+1):
        for b in range(1, num+1):
            if a == b:
                continue
            for c in range(max(a, b) + 1, num+1):
                if a * a + b * b == c * c:
                    count += 1
                    # Uncomment to print the triplet:
                    # print(a, b, c)
    return count


# --- Next Function Block ---



# 17. Count Pythagorean triplets (variant with three loops, skipping i == j).
def count_pythagorean_triplets_variant(num: int) -> int:
    """
    Another variant to count Pythagorean triplets using three nested loops.
    """
    count = 0
    for k in range(1, num+1):
        for i in range(1, k):
            for j in range(1, k):
                if i == j:
                    continue
                if i * i + j * j == k * k:
                    count += 1
    return count


# --- Next Function Block ---



# 18. Count numbers that have at least one non-identical partner.
def count_non_identical_partners(nums: list) -> int:
    """
    For each pair of distinct numbers in nums, collects the unique numbers that appear in such pairs.
    Returns the count of unique numbers that appear in a pair with a different number.
    """
    arr = []
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            if nums[i] != nums[j]:
                if nums[i] not in arr:
                    arr.append(nums[i])
                if nums[j] not in arr:
                    arr.append(nums[j])
    return len(arr)


# --- Next Function Block ---



# 19. Check if all characters in a string have the same frequency.
def all_equal_frequency(s: str) -> bool:
    """
    Returns True if every character in s occurs the same number of times; otherwise False.
    """
    freq = {ch: s.count(ch) for ch in s}
    first = next(iter(freq.values()))
    for count in freq.values():
        if count != first:
            return False
    return True


# --- Next Function Block ---



# 20. Count word frequencies in a sentence.
def count_word_frequencies(text: str) -> dict:
    """
    Returns a dictionary with word frequencies from text.
    """
    words = text.split()
    freq = {}
    for word in words:
        freq[word] = freq.get(word, 0) + 1
    return freq


# --- Next Function Block ---



# 21. Compute differences in groups: for sorted nums in descending order,
#     for each index i (up to len(nums)-k), for j in i+1 to i+1+k, record the difference.
def differences_in_groups(nums: list, k: int) -> list:
    """
    Sorts nums in reverse order and, for each index i up to len(nums)-k, computes differences with the next k numbers.
    Returns the list of differences.
    """
    result = []
    nums.sort(reverse=True)
    for i in range(len(nums) - k):
        for j in range(i+1, i+1+k):
            result.append(nums[i] - nums[j])
    return result


# --- Next Function Block ---



# 22. Reverse substring up to a given character.
def reverse_up_to_char(word: str, ch: str) -> str:
    """
    Finds the first occurrence of ch in word, reverses the substring up to and including that character,
    then concatenates the remainder.
    """
    ind = word.index(ch)
    return word[:ind+1][::-1] + word[ind+1:]


# --- Next Function Block ---



# 23. Compute maximum differences for each element:
def max_differences(nums: list) -> list:
    """
    For each index in nums, computes the maximum difference (nums[j]-nums[i]) for j > i.
    Returns a list with -1 as the first element and the maximum differences for subsequent indices.
    """
    result = [-1]
    for i in range(len(nums)-1):
        diffs = []
        for j in range(i+1, len(nums)):
            if nums[j] > nums[i]:
                diffs.append(nums[j] - nums[i])
        if diffs:
            result.append(max(diffs))
    return result


# --- Next Function Block ---



# 24. Find maximum gap (j - i) such that colors[i] != colors[j].
def max_index_gap_different(colors: list) -> int:
    """
    Returns the maximum index gap between two elements in colors that are different.
    """
    max_gap = -1
    n = len(colors)
    for i in range(n-1):
        for j in range(i+1, n):
            if colors[i] != colors[j] and (j - i) > max_gap:
                max_gap = j - i
    return max_gap


# --- Next Function Block ---



# 25. Shifting letters: using shifts list to transform s.
def shifting_letters(s: str, shifts: list) -> str:
    """
    For each index i in s, sums shifts from i to end, adds the index of s[i] in the alphabet,
    takes modulo 26, and returns the corresponding letter. Builds the final string.
    """
    alphabet = [chr(i) for i in range(ord('a'), ord('z')+1)]
    res = ""
    for i in range(len(s)):
        total = sum(shifts[i:]) + alphabet.index(s[i])
        total %= 26
        res += alphabet[total]
    return res


# --- Next Function Block ---



# 26. Reshape a 1D list into an m x n matrix.
def reshape_matrix(original: list, m: int, n: int) -> list:
    """
    Reshapes the list 'original' into a matrix with m rows and n columns.
    Assumes len(original) == m * n.
    """
    matrix = []
    k = 0
    for i in range(m):
        row = []
        for j in range(n):
            row.append(original[k])
            k += 1
        matrix.append(row)
    return matrix


# --- Next Function Block ---



# 27. Merge two lists of pairs (ambiguous logic from snippet).
def merge_pair_lists(nums1: list, nums2: list) -> list:
    """
    Given two lists of pairs, for each corresponding pair, if their first elements are equal,
    add their second elements; otherwise, collect the pair from the second list.
    Then, insert these collected pairs into the longer list based on the first element.
    (Logic is ambiguous; this is one interpretation.)
    """
    longest = nums1 if len(nums1) >= len(nums2) else nums2
    shortest = nums2 if longest is nums1 else nums1
    extra = []
    for i in range(len(shortest)):
        pair_long = longest[i]
        pair_short = shortest[i]
        if pair_long[0] == pair_short[0]:
            pair_long[1] += pair_short[1]
        else:
            extra.append(pair_short)
    # Insert extra pairs into longest based on first element (index = first element - 1)
    for pair in extra:
        ind = pair[0] - 1
        longest.insert(ind, pair)
    return longest


# --- Next Function Block ---



# 28. Print every 5th element’s first two numbers from an array.
def print_every_fifth(arr: list) -> None:
    """
    Iterates over arr with a step of 5 and prints arr[i] and arr[i+1] if available.
    """
    for i in range(0, len(arr), 5):
        if i + 1 < len(arr):
            print(arr[i])
            print(arr[i+1])


# --- Next Function Block ---



# 29. Intersection among three lists.
def intersect_three_lists(nums1: list, nums2: list, nums3: list) -> list:
    """
    Returns the list of unique elements that appear in at least two of the three lists.
    """
    set1 = set(nums1)
    set2 = set(nums2)
    set3 = set(nums3)
    # Intersection among any two:
    inter = (set1 & set2) | (set1 & set3) | (set2 & set3)
    return list(inter)


# --- Next Function Block ---



# 30. Check if all characters in a string occur with equal frequency.
def all_equal_frequency(s: str) -> bool:
    """
    Returns True if all characters in s have the same frequency; otherwise False.
    """
    freq = {ch: s.count(ch) for ch in s}
    return len(set(freq.values())) == 1


# --- Next Function Block ---



# 31. Count word frequencies.
def word_frequencies(text: str) -> dict:
    """
    Splits text by spaces and returns a dictionary of word frequencies.
    """
    words = text.split()
    freq = {}
    for word in words:
        freq[word] = freq.get(word, 0) + 1
    return freq


# --- Next Function Block ---




def most_frequent_prefix(strs: list) -> str:
    """
    Attempts to compute the prefix of the first string that appears most frequently among the strings.
    (The logic is ambiguous; here we simply return the longest common prefix.)
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# --- Next Function Block ---



# 74. Find all common prefixes from the first string that appear in every string.
def all_common_prefixes(strs: list) -> list:
    """
    Returns a list of all prefixes of the first string that are common to all strings in the list.
    """
    if not strs:
        return []
    common = []
    base = strs[0]
    for i in range(1, len(base) + 1):
        prefix = base[:i]
        if all(s.startswith(prefix) for s in strs):
            common.append(prefix)
    return common


# --- Next Function Block ---



# 75. For each number in nums, compute the sum of absolute differences with all numbers.
def sum_abs_differences(nums: list) -> list:
    """
    Returns a list where for each element in nums, the value is the sum of absolute differences
    between that element and every element in nums.
    """
    result = []
    for i in nums:
        total = sum(abs(i - j) for j in nums)
        result.append(total)
    return result


# --- Next Function Block ---




# anagrams.py
def are_anagrams(s: str, t: str) -> bool:
    """
    Returns True if strings s and t have the same character frequencies.
    """
    if len(s) != len(t):
        return False

    sdict = {}
    tdict = {}

    for i in range(len(s)):
        scount = 1
        tcount = 1
        for j in range(len(s)):
            if i != j:
                if s[i] == s[j]:
                    scount += 1
                if t[i] == t[j]:
                    tcount += 1
        sdict[s[i]] = scount
        tdict[t[i]] = tcount

    return sdict == tdict


# --- Next Function Block ---


# dominoes.py
def count_domino_pairs(dominoes: list) -> int:
    """
    Counts the number of equivalent domino pairs.
    Dominoes are considered equivalent if their sorted values are equal.
    """
    domino_count = {}
    count = 0
    for domino in dominoes:
        # Sort to get a consistent representation
        sorted_domino = tuple(sorted(domino))
        if sorted_domino in domino_count:
            count += domino_count[sorted_domino]
            domino_count[sorted_domino] += 1
        else:
            domino_count[sorted_domino] = 1
    return count


# --- Next Function Block ---


# compare_sorted_numbers.py
def compare_sorted_lists(nums: list):
    """
    Returns a tuple (sorted_set, sorted_nums) if the set and list differ,
    otherwise returns False.
    """
    sorted_set = sorted(set(nums))
    nums_sorted = sorted(nums)
    if sorted_set == nums_sorted:
        return False
    else:
        return sorted_set, nums_sorted


# --- Next Function Block ---


# pascals_triangle.py
def generate_pascals_triangle(n: int) -> list:
    """
    Generates Pascal's triangle with n rows.
    """
    triangle = []
    for i in range(n):
        row = [1]
        if i > 0:
            last_row = triangle[-1]
            for j in range(1, i):
                row.append(last_row[j-1] + last_row[j])
            row.append(1)
        triangle.append(row)
    return triangle


# --- Next Function Block ---


# day_of_year.py
def day_of_year(date_str: str) -> int:
    """
    Given a date string in 'YYYY-MM-DD' format, returns its day-of-year.
    """
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    year, month, day = map(int, date_str.split("-"))
    day_count = sum(days_in_month[:month-1]) + day
    # Check for leap year: divisible by 4 and (not divisible by 100 or divisible by 400)
    if (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)) and month > 2:
        day_count += 1
    return day_count


# --- Next Function Block ---


# majority_element.py
def majority_element(nums: list):
    """
    Returns the element that occurs most frequently in nums.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    max_count = 0
    majority = None
    for num, count in freq.items():
        if count > max_count:
            max_count = count
            majority = num
    return majority


# --- Next Function Block ---


# tribonacci.py
def tribonacci(n: int) -> int:
    """
    Returns the (n+1)th Tribonacci number.
    Starting with trib[0]=0, trib[1]=0, trib[2]=1.
    """
    trib = [0, 0, 1]
    for i in range(2, n + 1):
        trib.append(trib[i-2] + trib[i-1] + trib[i])
    return trib[n+1]


# --- Next Function Block ---


# factorial_division.py
def compute_factorial_divided(n: int) -> int:
    """
    Computes (2*n)! divided by 2^n.
    """
    num = n * 2
    factorial = 1
    for i in range(num, 0, -1):
        factorial *= i
    return factorial // (2 ** n)


# --- Next Function Block ---


# min_frequency_element.py
def min_frequency_element(nums: list):
    """
    Returns the element with the minimum frequency in nums.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    min_count = float('inf')
    element = None
    for num, count in freq.items():
        if count < min_count:
            min_count = count
            element = num
    return element


# --- Next Function Block ---


# search_insert.py
def search_insert(nums: list, target: int):
    """
    Returns a tuple (position, new_list) where position is the index of target in the sorted list.
    If target is not in nums, it is inserted into the correct sorted position.
    """
    if target in nums:
        return nums.index(target), nums
    for i, num in enumerate(nums):
        if target < num:
            nums.insert(i, target)
            return i, nums
    nums.append(target)
    return len(nums) - 1, nums


# --- Next Function Block ---


# str_str.py
def find_substring(haystack: str, needle: str) -> int:
    """
    Returns the index of the first occurrence of needle in haystack, or -1 if not found.
    """
    return haystack.find(needle)


# --- Next Function Block ---




# patterns.py

def reverse_vowels(s: str) -> str:
    """
    Reverses only the vowels in the string.
    Example: "hello" -> "holle"
    """
    vowels = ['a','e','i','o','u','A','E','I','O','U']
    s_list = list(s)
    # Collect vowels in order.
    collected = [ch for ch in s_list if ch in vowels]
    # Reverse the collected vowels.
    collected = collected[::-1]
    idx = 0
    # Replace vowels in s_list with reversed ones.
    for i in range(len(s_list)):
        if s_list[i] in vowels:
            s_list[i] = collected[idx]
            idx += 1
    return "".join(s_list)


# --- Next Function Block ---



def sort_vowels_in_string(s: str) -> str:
    """
    Extracts vowels from s, sorts them (by ascii), then replaces vowels in order.
    Example: "lEetcOde" -> vowels sorted: ['E','O','e','o'] and then reinserted.
    """
    vowels = ['a','e','i','o','u','A','E','I','O','U']
    s_list = list(s)
    # Collect ascii codes of vowels.
    vowel_codes = [ord(ch) for ch in s_list if ch in vowels]
    vowel_codes.sort()
    sorted_vowels = "".join(chr(code) for code in vowel_codes)
    idx = 0
    res = ""
    for ch in s_list:
        if ch in vowels:
            res += sorted_vowels[idx]
            idx += 1
        else:
            res += ch
    return res


# --- Next Function Block ---



def unique_chars(s: str) -> str:
    """
    Returns a string made of unique characters in s (order arbitrary).
    Example: "pwwkew" -> a string with unique letters.
    """
    return "".join(set(s))


# --- Next Function Block ---



def reduce_value(n: float) -> float:
    """
    Divides n by 2 repeatedly until n <= 2.
    """
    while n > 2:
        n /= 2
    return n


# --- Next Function Block ---



def move_zeros_nested(nums: list) -> list:
    """
    Moves zeros in a list to the end using nested loops.
    Example: [0,0,1,0,3,12] becomes a list with non-zeros first.
    """
    nums = nums[:]  # copy to avoid mutation
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            if nums[i] == 0 and nums[j] != 0:
                nums[i], nums[j] = nums[j], 0
    return nums


# --- Next Function Block ---



def move_zeros_remove(nums: list) -> list:
    """
    Moves zeros to the end by removing and appending.
    Example: [0,1,0,3,12] becomes [1,3,12,0,0].
    """
    nums = nums[:]  # copy
    for i in nums[:]:
        if i == 0:
            nums.remove(i)
            nums.append(0)
    return nums


# --- Next Function Block ---



def combine_adjacent_equal(nums: list) -> list:
    """
    Combines two equal adjacent numbers by doubling the first and zeroing the second.
    Then moves zeros to the end.
    Example: [1,2,2,1,1,0] --> after combination and shifting zeros.
    """
    nums = nums[:]  # copy
    for i in range(len(nums)-1):
        if nums[i] == nums[i+1]:
            nums[i] *= 2
            nums[i+1] = 0
    # Remove zeros and append them at the end.
    result = [num for num in nums if num != 0]
    result.extend([0] * (len(nums) - len(result)))
    return result


# --- Next Function Block ---



def int_to_roman(num: int) -> str:
    """
    Converts an integer to a Roman numeral string.
    """
    mapping = {1000:'M', 500:'D', 100:'C', 50:'L', 10:'X', 5:'V', 1:'I'}
    out = ""
    n = num
    while n > 0:
        if n >= 1000:
            n -= 1000
            out += mapping[1000]
        elif n >= 900:
            n -= 900
            out += mapping[100] + mapping[1000]
        elif n >= 500:
            n -= 500
            out += mapping[500]
        elif n >= 400:
            n -= 400
            out += mapping[100] + mapping[500]
        elif n >= 100:
            n -= 100
            out += mapping[100]
        elif n >= 90:
            n -= 90
            out += mapping[10] + mapping[100]
        elif n >= 50:
            n -= 50
            out += mapping[50]
        elif n >= 40:
            n -= 40
            out += mapping[10] + mapping[50]
        elif n >= 10:
            n -= 10
            out += mapping[10]
        elif n >= 9:
            n -= 9
            out += mapping[1] + mapping[10]
        elif n >= 5:
            n -= 5
            out += mapping[5]
        elif n >= 4:
            n -= 4
            out += mapping[1] + mapping[5]
        else:
            n -= 1
            out += mapping[1]
    return out


# --- Next Function Block ---



def multiply_str_numbers(num1: str, num2: str) -> int:
    """
    Converts two string numbers to integers and returns their product.
    """
    return int(num1) * int(num2)


# --- Next Function Block ---



def min_diff_pair(arr: list) -> list:
    """
    Given a sorted array, finds and returns the pair of numbers with the minimum difference.
    """
    arr = sorted(arr)
    diffs = []
    pairs = []
    for i in range(len(arr)-1):
        diff = arr[i+1] - arr[i]
        diffs.append(diff)
        pairs.append([arr[i], arr[i+1]])
    min_diff = min(diffs) if diffs else None
    for pair in pairs:
        if pair[1] - pair[0] == min_diff:
            return pair
    return []


# --- Next Function Block ---



def insert_zeros_after_even(nums: list) -> list:
    """
    Inserts two zeros immediately after every even number in the list.
    """
    i = 0
    nums = nums[:]  # copy
    while i < len(nums):
        if nums[i] % 2 == 0:
            nums.insert(i+1, 0)
            nums.insert(i+2, 0)
            i += 3
        else:
            i += 1
    return nums


# --- Next Function Block ---



def remove_two_after_condition(arr: list) -> list:
    """
    If an element in arr is divisible by 5 and there's a next element, remove the next two elements.
    (Note: This logic is based on the given code and may remove fewer than two if not available.)
    """
    arr = arr[:]  # copy
    i = 0
    while i < len(arr) - 1:
        if arr[i] % 5 == 0:
            # Remove next two elements if possible.
            if i+1 < len(arr):
                arr.pop(i+1)
            if i+1 < len(arr):
                arr.pop(i+1)
        i += 1
    return arr


# --- Next Function Block ---



def check_coordinate_difference(coordinates: list) -> bool:
    """
    Given a list of [x,y] coordinates, attempts to check if the differences between consecutive coordinates are consistent.
    (The original logic is ambiguous; this function mimics the provided approach.)
    """
    if not coordinates:
        return True
    diff = coordinates[0][0] - coordinates[0][1]
    diffx = []
    diffy = []
    h = 0
    out = True
    for i in range(len(coordinates)):
        k = coordinates[i]
        if i < len(coordinates) - 1:
            l = coordinates[i+1]
        for j in range(len(k) - 1):
            if diff:
                if k[0] - k[1] == diff:
                    if i < len(coordinates) - 1:
                        diffx.append(l[0] - k[0])
                        diffy.append(l[1] - k[1])
                        if h > 0 and diffx[h-1] == diffx[h] and diffy[h-1] == diffy[h]:
                            h += 1
                        elif diff != 0 and diffx[h] % diff == 0 and diffy[h] % diff == 0:
                            h += 1
                        else:
                            out = False
                            break
                else:
                    out = False
                    break
            else:
                diff = k[0] - k[1]
    return out


# --- Next Function Block ---



def max_profit_difference(arr: list) -> int:
    """
    Given a list of prices (or similar), finds the pair with the minimum difference and returns the difference between sell and buy.
    If the difference is negative, returns 0.
    (Logic based on the provided snippet.)
    """
    diff_map = {}
    for i in range(len(arr)-1):
        minval = arr[0]  # initial min value difference (this logic is ambiguous)
        for j in range(i+1, len(arr)):
            if arr[i] - arr[j] < minval:
                minval = arr[i] - arr[j]
                buyval = arr[i]
                sellval = arr[j]
        diff_map[minval] = [buyval, sellval]
    key = min(diff_map) if diff_map else 0
    val = diff_map.get(key, [0, 0])
    res = val[1] - val[0]
    if res <= 0:
        res = 0
    return res


# --- Next Function Block ---



def find_min_in_list(arr: list) -> int:
    """
    Returns the minimum value in the list.
    """
    if not arr:
        return None
    min_val = arr[0]
    for i in arr:
        if i < min_val:
            min_val = i
    return min_val


# --- Next Function Block ---



def print_star_pattern():
    """
    Prints a pattern:
    For each i from 1 to 3:
      - Print a line with '*' (with newline)
      - Then print i blocks of a square pattern where each block is a row of i stars repeated 'size' times.
      'size' doubles for each i.
    """
    size = 2
    for i in range(1, 4):
        # Print i lines with "*"
        for j in range(i):
            print("*")
        # Print square blocks
        for k in range(i):
            for l in range(size):
                print("*", end=" ")
            print()  # new line after each block row
        size *= 2


# --- Next Function Block ---





# patterns.py

def symmetric_differences(arr: list) -> list:
    """
    Given an array, computes absolute differences between elements
    from the start and end moving inward.
    Example:
      Input: [7,3,5,2,10,6,8,1,4,9]
      Output: list of differences for first half of array with corresponding symmetric elements.
    """
    size = len(arr)
    diff = []
    i, n = 0, size - 1
    for _ in range(size // 2):
        # If indices cross, break (though loop is already half-length)
        if i == n:
            break
        diff.append(abs(arr[i] - arr[n]))
        i += 1
        n -= 1
    return diff


# --- Next Function Block ---



def product_minus_sum(n: int) -> int:
    """
    Converts an integer to string, computes the product of its digits,
    the sum of its digits, and returns (product - sum).
    Example: n=234 -> (2*3*4) - (2+3+4) = 24 - 9 = 15
    """
    s = str(n)
    prod = 1
    total = 0
    for ch in s:
        digit = int(ch)
        total += digit
        prod *= digit
    return prod - total


# --- Next Function Block ---



def sum_of_multiples(n: int) -> int:
    """
    Sums all numbers in the range [1, n) that are divisible by 3, 5, or 7.
    Example: n=7 sums numbers in 1...6 meeting the condition.
    """
    total = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0 or i % 7 == 0:
            total += i
    return total


# --- Next Function Block ---



def nine_minus_one(n: int) -> int:
    """
    For a given integer n, creates a number with the same number of digits all '9's
    and a number with the same number of digits all '1's, then returns their difference.
    Example: n=555 -> "999" - "111" = 888.
    """
    s = str(n)
    large = int("9" * len(s))
    small = int("1" * len(s))
    return large - small


# --- Next Function Block ---



def product_of_list(nums: list, verbose: bool = False) -> int:
    """
    Multiplies the numbers in the list (iterating in reverse order).
    Optionally prints each number.
    """
    product = 1
    for num in nums[::-1]:
        if verbose:
            print(num)
        product *= num
    return product


# --- Next Function Block ---



def longest_common_prefix(strs: list) -> str:
    """
    Returns the longest common prefix among the list of strings.
    If there is none, returns an empty string.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        # Shorten the prefix until s starts with it
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def max_right(arr: list) -> list:
    """
    Given an array, returns a new list where each element at index i is
    replaced by the maximum element to its right; the last element is -1.
    Example: [7,3,5,2,10] -> [10,10,10,10,-1]
    """
    size = len(arr)
    if size == 0:
        return []
    result = [None] * size
    result[-1] = -1
    max_so_far = arr[-1]
    for i in range(size - 2, -1, -1):
        if arr[i] > max_so_far:
            max_so_far = arr[i]
        result[i] = max_so_far
    return result


# --- Next Function Block ---



def generate_random_array(n: int) -> tuple:
    """
    Generates an array of n-1 distinct random integers between -n and n (excluding 0),
    then appends -sum(array) if not already present, or adjusts if it is.
    Returns a tuple: (array, count, -count), where count is the sum of the initial array.
    """
    import random
    array = []
    count = 0
    while len(array) < n - 1:
        val = random.randint(-n, n)
        if val not in array and val != 0:
            array.append(val)
            count += val
    if -count not in array:
        array.append(-count)
    else:
        idx = array.index(-count)
        array[idx] = 0
        array.append(-count + (-count))
    return array, count, -count


# --- Next Function Block ---



def modify_number(num: int) -> int:
    """
    Given a number, replaces the first digit that is less than 9 with 9.
    Then, in a while loop, if a digit (starting from the right) equals 6,
    adds 3 times its positional value to the original number and stops.
    Returns the modified number.
    """
    s = str(num)
    ret = ""
    ins = True
    for ch in s:
        digit = int(ch)
        if digit < 9 and ins:
            ret += "9"
            ins = False
        else:
            ret += ch
    modified = int(ret)
    
    # Process digits from right side
    temp = num
    count = 0
    while temp > 1:
        if temp % 10 == 6:
            modified += 3 * (10 ** count)
            break
        count += 1
        temp //= 10
    return modified


# --- Next Function Block ---



def pascal_row(row_index: int) -> list:
    """
    Returns the row_index-th row of Pascal's Triangle.
    Example: row_index=0 returns [1], row_index=1 returns [1,1], etc.
    """
    triangle = []
    for i in range(row_index + 1):
        row = [1]
        if i > 0:
            prev = triangle[-1]
            for j in range(1, i):
                row.append(prev[j-1] + prev[j])
            row.append(1)
        triangle.append(row)
    return triangle[row_index]


# --- Next Function Block ---



def min_max_game(nums: list) -> int:
    """
    Given a list of numbers, repeatedly perform the following:
      - Partition the list into pairs.
      - For each pair, if it's the turn for 'min', choose the minimum; otherwise, choose the maximum.
      - Continue until one number remains.
    Returns the final number.
    """
    turn = True  # True means take min, False means take max.
    while len(nums) > 1:
        new_nums = []
        for i in range(0, len(nums) - 1, 2):
            if turn:
                new_nums.append(min(nums[i], nums[i+1]))
            else:
                new_nums.append(max(nums[i], nums[i+1]))
            turn = not turn
        if len(nums) % 2 == 1:
            new_nums.append(nums[-1])
        nums = new_nums
    return nums[0]


# --- Next Function Block ---



def chunk_string(s: str, k: int) -> list:
    """
    Splits the string s into chunks of length k.
    The final chunk may be shorter if s is not divisible by k.
    """
    return [s[i:i+k] for i in range(0, len(s), k)]


# --- Next Function Block ---



def min_max_game_progression(nums: list) -> list:
    """
    Implements the Min Max Game (LeetCode #2293) and returns all intermediate lists.
    """
    result = [nums]
    flag = True
    while len(result[-1]) > 1:
        current = result[-1]
        new_list = []
        i = 0
        while i < len(current) - 1:
            if flag:
                new_list.append(min(current[i], current[i+1]))
            else:
                new_list.append(max(current[i], current[i+1]))
            flag = not flag
            i += 2
        result.append(new_list)
    return result


# --- Next Function Block ---



def most_frequent(nums: list):
    """
    Returns the most frequent element in the list.
    """
    freq = {}
    max_count = 0
    max_elem = None
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
        if freq[num] > max_count:
            max_count = freq[num]
            max_elem = num
    return max_elem


# --- Next Function Block ---



def compute_ranks(arr: list) -> list:
    """
    Computes the rank for each element in the original array.
    Rank is defined as:
       - Unique elements are sorted.
       - The rank is 1 for the smallest element, 2 for the next, etc.
    Returns a list of ranks corresponding to the original array.
    """
    sorted_unique = sorted(set(arr))
    rank_dict = {num: rank+1 for rank, num in enumerate(sorted_unique)}
    return [rank_dict[num] for num in arr]


# --- Next Function Block ---



def print_symmetric_pairs(s: str) -> None:
    """
    Prints pairs of characters from the string: first with last, second with second-last, etc.
    """
    size = len(s)
    for i in range(size // 2):
        print(s[i], s[size - 1 - i])


# --- Next Function Block ---



def max_area(height: list) -> int:
    """
    Given a list of heights, returns the maximum area formed by two indices,
    defined as min(height[i], height[j]) * (j - i). (O(n^2) brute force approach.)
    """
    max_area_val = 0
    size = len(height)
    for i in range(size - 1):
        for j in range(i + 1, size):
            area = min(height[i], height[j]) * (j - i)
            if area > max_area_val:
                max_area_val = area
    return max_area_val


# --- Next Function Block ---




# patterns.py

# 1. Happy Number Check (using sum of squares of digits)
def is_happy(n: int, max_iter: int = 100) -> bool:
    """
    Determines if a number is "happy". A number is happy if repeatedly replacing
    it with the sum of the squares of its digits eventually leads to 1.
    """
    for _ in range(max_iter):
        s = str(n)
        total = sum(int(ch) ** 2 for ch in s)
        n = total
        if n == 1:
            return True
    return False


# --- Next Function Block ---


# 2. k Least Ones Rows in a Binary Matrix
def k_least_ones_rows(mat: list, k: int) -> list:
    """
    Given a binary matrix, counts the number of 1's in each row and returns
    the indices of the k rows with the fewest 1's.
    """
    row_counts = {i: sum(row) for i, row in enumerate(mat)}
    sorted_rows = sorted(row_counts.items(), key=lambda x: x[1])
    return [i for i, _ in sorted_rows[:k]]


# --- Next Function Block ---


# 3. Check if s is a Subsequence of t
def is_subsequence(s: str, t: str) -> bool:
    """
    Returns True if s is a subsequence of t.
    """
    pos = 0
    for char in s:
        pos = t.find(char, pos)
        if pos == -1:
            return False
        pos += 1
    return True


# --- Next Function Block ---


# 4. Digit Root (Repeated sum of digits until single digit)
def digit_root(n: int) -> int:
    """
    Repeatedly sums the digits of n until a single digit is obtained.
    """
    while n >= 10:
        n = sum(int(d) for d in str(n))
    return n


# --- Next Function Block ---


# 5. Count Numbers Smaller Than Current
def count_smaller_numbers(nums: list) -> list:
    """
    For each number in nums, counts how many numbers in nums are smaller.
    """
    result = []
    for i in range(len(nums)):
        count = sum(1 for j in range(len(nums)) if nums[i] > nums[j])
        result.append(count)
    return result


# --- Next Function Block ---


# 6. Intersection of Two Lists (unique common elements)
def intersection(nums1: list, nums2: list) -> list:
    """
    Returns a list of unique elements common to both nums1 and nums2.
    """
    return list(set(nums1).intersection(set(nums2)))


# --- Next Function Block ---


# 7. Palindrome Check
def is_palindrome(s: str) -> bool:
    """
    Returns True if s is a palindrome.
    """
    return s == s[::-1]


# --- Next Function Block ---


# 8. Interleave Two Strings
def interleave_strings(word1: str, word2: str) -> str:
    """
    Interleaves characters of word1 and word2. If one word is longer,
    appends the remainder at the end.
    """
    result = []
    max_len = max(len(word1), len(word2))
    for i in range(max_len):
        if i < len(word1):
            result.append(word1[i])
        if i < len(word2):
            result.append(word2[i])
    return "".join(result)


# --- Next Function Block ---


# 9. Maximum Sum with Reversed Numbers
def max_sum_with_reversed(nums: list) -> int:
    """
    For each number in nums that has more than one digit, reverse its digits.
    If the reversed number is also in nums, track the maximum sum of the original
    and reversed numbers.
    """
    max_sum = -1
    for num in nums:
        s = str(num)
        if len(s) > 1:
            rev = int(s[::-1])
            if rev in nums:
                max_sum = max(max_sum, num + rev)
    return max_sum


# --- Next Function Block ---


# 10. Alternate Rearrangement of Characters
def alternate_rearrange(s: str) -> str:
    """
    Rearranges characters from s by alternating from a sorted list of unique characters,
    decrementing their frequency until the result's length equals the original.
    (This mimics a complex custom ordering from the provided snippet.)
    """
    freq = {}
    for ch in s:
        freq[ch] = freq.get(ch, 0) + 1
    unique_chars = sorted(set(s))
    result = ""
    i = 0
    reverse = False
    const = False
    while len(result) < len(s) and unique_chars:
        # If the current character is exhausted, remove it.
        if freq[unique_chars[i]] <= 0:
            unique_chars.pop(i)
            if not unique_chars:
                break
            i = len(unique_chars)-1 if reverse else 0
            continue
        result += unique_chars[i]
        freq[unique_chars[i]] -= 1
        # Toggle direction at boundaries.
        if i == 0:
            reverse = False
        elif i == len(unique_chars) - 1:
            reverse = True
        const = True
        if len(unique_chars) <= 1:
            i = 0
        elif reverse:
            i -= 1
        else:
            i += 1
    return result


# --- Next Function Block ---


# 11. Count Pairs with Sum Less Than Target
def count_pairs_with_sum_less_than(nums: list, target: int) -> int:
    """
    Counts the number of unique pairs (i, j) with i < j such that the sum is less than target.
    """
    count = 0
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            if nums[i] + nums[j] < target:
                count += 1
    return count


# --- Next Function Block ---


# 12. Count Pairs with Sum in [lower, upper]
def count_pairs_in_range(nums: list, lower: int, upper: int) -> int:
    """
    Counts the number of unique pairs (i, j) with i < j such that the sum is between lower and upper (inclusive).
    """
    count = 0
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            s = nums[i] + nums[j]
            if lower <= s <= upper:
                count += 1
    return count


# --- Next Function Block ---


# 13. Check First Letters of Words Against a String
def check_first_letters(words: list, s: str) -> bool:
    """
    Checks if the first letter of each word in words matches the corresponding character in s.
    Returns False if lengths differ.
    """
    if len(words) != len(s):
        return False
    for i in range(len(words)):
        if words[i][0] != s[i]:
            return False
    return True


# --- Next Function Block ---


# 14. Count Unique Numbers in Intervals
def count_unique_numbers_in_intervals(intervals: list) -> int:
    """
    Given a list of intervals [start, end], counts the number of unique integers in all intervals.
    """
    unique_nums = set()
    for start, end in intervals:
        unique_nums.update(range(start, end + 1))
    return len(unique_nums)


# --- Next Function Block ---


# 15. Return Length of List
def list_length(lst: list) -> int:
    """
    Returns the length of lst.
    """
    return len(lst)


# --- Next Function Block ---


# 16. Create Target Array in Given Order
def create_target_array(nums: list, index: list) -> list:
    """
    Given two lists, nums and index, inserts each element from nums into a target list at the corresponding index.
    """
    target = []
    for num, idx in zip(nums, index):
        target.insert(idx, num)
    return target


# --- Next Function Block ---


# 17. Common Divisors of Two Numbers
def common_divisors(a: int, b: int) -> list:
    """
    Returns a list of common divisors of a and b.
    """
    c = a if a < b else b
    divisors = []
    for i in range(1, c + 1):
        if a % i == 0 and b % i == 0:
            divisors.append(i)
    return divisors


# --- Next Function Block ---


# 18. ID with Maximum Gap in Logs
def id_of_max_gap(logs: list) -> int:
    """
    Given logs as [id, time] pairs, returns the id corresponding to the maximum gap between times.
    Assumes logs are ordered by time.
    """
    kdiff = 0
    selected_id = 0
    pos = 0
    for log in logs:
        current_id, time = log
        gap = time - pos
        if gap > kdiff:
            kdiff = gap
            selected_id = current_id
        pos = time
    return selected_id


# --- Next Function Block ---


# 19. Print Negative Pairs
def print_negative_pairs(nums: list) -> None:
    """
    For each number in nums, if its negative exists in nums, prints the negative value with a tag.
    """
    nums_sorted = sorted(nums, reverse=True)
    for num in nums_sorted:
        if -num in nums:
            print(-num, "9")


# --- Next Function Block ---


# 20. Power Calculation
def power(x: float, n: int) -> float:
    """
    Returns x raised to the power n.
    """
    return x ** n


# --- Next Function Block ---


# 21. Range Count
def range_count(low: int, high: int) -> int:
    """
    Returns the difference between high and low.
    """
    return high - low


# --- Next Function Block ---


# 22. Average of Salaries
def average_salary(salaries: list) -> float:
    """
    Returns the average of the salaries in the list.
    """
    return sum(salaries) / len(salaries) if salaries else 0


# --- Next Function Block ---


# 23. Rotate Array Right by k
def rotate_right(nums: list, k: int) -> list:
    """
    Rotates the list nums to the right by k positions.
    """
    n = len(nums)
    k = k % n  # Handle cases where k >= n
    return nums[-k:] + nums[:-k]


# --- Next Function Block ---


# 24. Element Equal to Its Frequency
def element_equal_to_frequency(arr: list) -> int:
    """
    Returns the first element whose value equals its frequency in the array.
    If none exists, returns -1.
    """
    freq = {}
    for num in arr:
        freq[num] = freq.get(num, 0) + 1
    for num in arr:
        if num == freq[num]:
            return num
    return -1


# --- Next Function Block ---


# 25. Longest Repeating Character Substring Length
def longest_repeating_substring_length(s: str) -> int:
    """
    Returns the length of the longest substring of s consisting of the same character.
    """
    if not s:
        return 0
    max_len = 1
    current_len = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_len += 1
        else:
            max_len = max(max_len, current_len)
            current_len = 1
    return max(max_len, current_len)


# --- Next Function Block ---


# 26. Get Dictionary Keys
def get_dict_keys(d: dict) -> list:
    """
    Returns a list of keys in dictionary d.
    """
    return list(d.keys())


# --- Next Function Block ---


# 27. Demonstrate Abstract Base Classes
from abc import ABC, abstractmethod
class A(ABC):
    @abstractmethod
    def printf(self):
        pass

class B(A):
    def printf(self):
        print("Hi from B")
    def Scan(self):
        print("Hey")

def test_inheritance():
    """
    Demonstrates inheritance using abstract base classes.
    """
    obj = B()
    obj.printf()
    obj.Scan()


# --- Next Function Block ---


# 28. Custom Fibonacci Variant (starting with [1,2])
def custom_fib(n: int) -> int:
    """
    Returns the nth element in a Fibonacci-like sequence starting with 1 and 2.
    """
    if n == 1:
        return 1
    if n == 2:
        return 2
    seq = [1, 2]
    for i in range(2, n):
        seq.append(seq[-1] + seq[-2])
    return seq[-1]


# --- Next Function Block ---


# 29. Vehicle Class with Destructor
class Vehicle:
    def __init__(self):
        print("Vehicle created.")
    def __del__(self):
        print("Destructor called, vehicle deleted.")
    def display(self):
        print("Hello")

def test_vehicle_class():
    """
    Creates a Vehicle instance, calls display, then deletes it.
    """
    car = Vehicle()
    car.display()
    del car


# --- Next Function Block ---


# 30. Most Frequent Element in a List
def most_frequent_element(nums: list) -> int:
    """
    Returns the element with the highest frequency in nums.
    """
    freq = {}
    max_count = 0
    max_elem = None
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
        if freq[num] > max_count:
            max_count = freq[num]
            max_elem = num
    return max_elem


# --- Next Function Block ---


# 31. Print Duplicates in a List
def print_duplicates(nums: list) -> None:
    """
    Prints elements that appear more than once in the list.
    """
    seen = set()
    duplicates = set()
    for num in nums:
        if num in seen:
            duplicates.add(num)
        else:
            seen.add(num)
    for dup in duplicates:
        print(dup)


# --- Next Function Block ---


# 32. First Duplicate Element (from set comprehension)
def first_duplicate(nums: list):
    """
    Returns the first element that appears more than once in nums.
    If none, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---


# 33. Capitalize First Letter of a String
def capitalize_first_letter(s: str) -> str:
    """
    Capitalizes the first letter of the string s.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---


# 34. Interleave Halves of an Array
def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list nums and an integer n, interleaves the first n elements with the next n elements.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---


# 35. Extract Number from String
def extract_number(s: str) -> int:
    """
    Splits the string s by spaces and returns the last integer found.
    If none found, returns 0.
    """
    num = 0
    for token in s.split():
        try:
            num = int(token)
        except ValueError:
            continue
    return num


# --- Next Function Block ---


# 36. Longest Common Prefix (Brute Force)
def longest_common_prefix_brute(strs: list) -> str:
    """
    Finds the longest common prefix among a list of strings using brute force.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# --- Next Function Block ---


# 37. Remove Duplicates In-place (Sorted Array Variant)
def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---


# 38. Normalize Email Addresses
def normalize_email(email: str) -> str:
    """
    Normalizes an email address by removing dots from the local name and ignoring everything after a '+'.
    """
    local, domain = email.split('@')
    local = local.split('+')[0].replace('.', '')
    return local + '@' + domain


# --- Next Function Block ---


def normalize_emails(emails: list) -> list:
    """
    Normalizes a list of emails.
    """
    return [normalize_email(email) for email in emails]


# --- Next Function Block ---


# 39. Adjust Prices (Subtract first smaller element)
def adjust_prices(prices: list) -> list:
    """
    For each price in the list, if a subsequent price is smaller,
    subtract that price from the current and break.
    """
    adjusted = prices[:]  # make a copy
    for i in range(len(adjusted)-1):
        for j in range(i+1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] = adjusted[i] - adjusted[j]
                break
    return adjusted


# --- Next Function Block ---


# 40. Sum Diagonals of a Matrix
def sum_diagonals(mat: list) -> int:
    """
    Sums the elements on both the main diagonal and the secondary diagonal of a square matrix.
    If the matrix has an odd center, it is counted only once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i]  # primary diagonal
        total += mat[i][n - 1 - i]  # secondary diagonal
    # If n is odd, subtract the center value (counted twice)
    if n % 2 == 1:
        total -= mat[n//2][n//2]
    return total


# --- Next Function Block ---




# patterns.py

def is_diagonal_matrix(grid: list) -> bool:
    """
    Returns True if grid is a square matrix with nonzero entries only on the main diagonal,
    and zeros off the diagonal.
    """
    n = len(grid)
    for i in range(n):
        for j in range(len(grid[i])):
            if i == j:
                if grid[i][j] == 0:
                    return False
            else:
                if grid[i][j] != 0:
                    return False
    return True


# --- Next Function Block ---



def xor_of_sequence(n: int, start: int = 3, step: int = 2) -> int:
    """
    Generates a sequence of n numbers, starting from 'start' and increasing by 'step',
    and returns their bitwise XOR.
    """
    seq = []
    xor_val = 0
    i = start
    while len(seq) < n:
        seq.append(i)
        xor_val ^= i
        i += step
    return xor_val


# --- Next Function Block ---



def count_elements_geq(arr: list, target) -> int:
    """
    Counts the number of elements in arr that are greater than or equal to target.
    """
    count = 0
    for elem in arr:
        if elem >= target:
            count += 1
    return count


# --- Next Function Block ---



def max_account_value(accounts: list) -> int:
    """
    Given a list of accounts (each account is a list of numbers), returns the maximum total (row sum).
    """
    max_val = 0
    for acc in accounts:
        total = sum(acc)
        if total > max_val:
            max_val = total
    return max_val


# --- Next Function Block ---



def count_equal_pairs(nums: list) -> int:
    """
    Counts the number of pairs (i, j) with i < j such that nums[i] == nums[j].
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if nums[i] == nums[j]:
                count += 1
    return count


# --- Next Function Block ---



def duplicate_list(nums: list) -> list:
    """
    Returns a new list by appending a copy of nums to itself.
    """
    return nums + nums


# --- Next Function Block ---



def final_value_after_operations(operations: list) -> int:
    """
    Given a list of operations (strings "++X" or "X++"), returns the final value of x.
    """
    x = 0
    for op in operations:
        if op in ["++X", "X++"]:
            x += 1
        else:
            x -= 1
    return x


# --- Next Function Block ---



def kids_with_greatest_candies(candies: list, extraCandies: int) -> list:
    """
    Returns a list of booleans indicating whether each kid can have the greatest number of candies
    after receiving extraCandies.
    """
    max_candies = max(candies)
    result = []
    for c in candies:
        result.append(c + extraCandies >= max_candies)
    return result


# --- Next Function Block ---



def running_sum(nums: list) -> list:
    """
    Returns a list where each element at index i is the sum of nums[0:i+1].
    """
    total = 0
    result = []
    for num in nums:
        total += num
        result.append(total)
    return result


# --- Next Function Block ---



def sentence_with_most_words(sentences: list) -> list:
    """
    Returns the list of words of the sentence that has the maximum word count.
    """
    max_words = []
    for sentence in sentences:
        words = sentence.split()
        if len(words) > len(max_words):
            max_words = words
    return max_words


# --- Next Function Block ---



def prefix_difference(nums: list) -> list:
    """
    Computes two prefix sum arrays:
      - left prefix sum from the start,
      - right prefix sum from the end,
    then returns a list of absolute differences between the left prefix at index i
    and the corresponding right prefix from the opposite end.
    """
    n = len(nums)
    left = [0] * n
    right = [0] * n
    s_left = 0
    s_right = 0
    for i in range(n):
        left[i] = s_left
        s_left += nums[i]
        right[i] = s_right
        s_right += nums[n - 1 - i]
    diff = []
    for i in range(n):
        diff.append(abs(left[i] - right[n - 1 - i]))
    return diff


# --- Next Function Block ---



def print_custom_pattern(n: int) -> None:
    """
    Prints a custom pattern based on a grid of size (n*n).
    (Note: The pattern logic is derived from the given code and may be adjusted as needed.)
    """
    total = n * n
    for i in range(total):
        for j in range(total):
            # This condition is based on the provided snippet; adjust as needed.
            if (i == 0 and j == total // 2) or \
               (i > 0 and (total / 2) - 2 < j < (total / 2) + 1) or \
               (i > (total / 2) - 2 and 1 < j < 5) or \
               (i > (total / 2) - 2 and 5 < j < 9) or \
               (i > (total / 2) - 2 and total - 6 < j < total - 2) or \
               (i > (total / 2) - 2 and total - 10 < j < total - 6) or \
               (i >= total // 2) or \
               (i == 12 and 0 < j < total - 1):
                print("*", end=" ")
            else:
                print("  ", end=" ")
        print()


# --- Next Function Block ---



def convert_date(date: str) -> str:
    """
    Converts a date from format "20th Oct 2052" to "2052-10-20".
    Assumes day part may contain ordinal suffixes.
    """
    month_map = {
        "Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04",
        "May": "05", "Jun": "06", "Jul": "07", "Aug": "08",
        "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"
    }
    parts = date.split()
    day_part = parts[0]
    # Remove non-digit characters
    day = "".join(filter(str.isdigit, day_part))
    if len(day) == 1:
        day = "0" + day
    month = month_map[parts[1]]
    year = parts[2]
    return f"{year}-{month}-{day}"


# --- Next Function Block ---



def count_odds(low: int, high: int) -> int:
    """
    Counts the number of odd numbers in the inclusive range [low, high].
    """
    count = 0
    for i in range(low, high + 1):
        if i % 2 != 0:
            count += 1
    return count


# --- Next Function Block ---



def rearrange_string(s: str, indices: list) -> str:
    """
    Rearranges characters in s according to indices.
    """
    mapping = {index: char for index, char in zip(indices, s)}
    sorted_mapping = dict(sorted(mapping.items()))
    result = "".join(sorted_mapping[i] for i in sorted_mapping)
    return result


# --- Next Function Block ---



def repeat_alternate(nums: list) -> list:
    """
    For even-indexed elements in nums, repeats the element at index i+1 a number of times equal to nums[i].
    Example: For nums = [1,2,3,4], returns [2] repeated 1 time and [4] repeated 3 times => [2,4,4,4].
    """
    result = []
    for i in range(0, len(nums), 2):
        if i + 1 < len(nums):
            result.extend([nums[i+1]] * nums[i])
    return result


# --- Next Function Block ---



def first_k_words(s: str, k: int) -> str:
    """
    Returns the first k words from the string s.
    """
    words = s.split()
    return " ".join(words[:k])


# --- Next Function Block ---



def compare_word_lists(word1: list, word2: list) -> bool:
    """
    Concatenates the elements of both lists (word by word) and compares the resulting strings.
    Returns True if they are equal.
    """
    stg1 = "".join(word1)
    stg2 = "".join(word2)
    return stg1 == stg2


# --- Next Function Block ---



def sum_minus_digit_sum(nums: list) -> int:
    """
    For a list of numbers, returns the difference between the sum of the numbers and
    the sum of all their digits.
    """
    total = sum(nums)
    digit_sum = 0
    for num in nums:
        for ch in str(num):
            digit_sum += int(ch)
    return total - digit_sum


# --- Next Function Block ---



def count_pairs_with_difference(nums: list, k: int) -> int:
    """
    Counts the number of pairs (i, j) with i < j such that the absolute difference is k.
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if abs(nums[i] - nums[j]) == k:
                count += 1
    return count


# --- Next Function Block ---



def count_special_pairs(nums: list, k: int) -> int:
    """
    Counts the number of pairs (i, j) with i < j such that nums[i] == nums[j]
    and (i * j) % k == 0.
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if nums[i] == nums[j] and (i * j) % k == 0:
                count += 1
    return count


# --- Next Function Block ---



def format_number_with_dots(n: int) -> str:
    """
    Formats a number with dots as thousand separators.
    Example: 1234567 -> "1.234.567"
    """
    s = str(n)
    result = ""
    count = 0
    # Process digits from right to left.
    for ch in s[::-1]:
        if count == 3:
            result = "." + result
            count = 0
        result = ch + result
        count += 1
    return result


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the count of words that consist solely of characters in allowed.
    """
    count = 0
    for word in words:
        valid = True
        for ch in word:
            if ch not in allowed:
                valid = False
                break
        if valid:
            count += 1
    return count


# --- Next Function Block ---



def sum_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Inserts "[.]" between each segment of an IP address.
    Example: "1.1.1.1" -> "1[.]1[.]1[.]1"
    """
    parts = address.split(".")
    return "[.]".join(parts)


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Counts how many characters in stones are also in jewels.
    """
    count = 0
    for ch in stones:
        if ch in jewels:
            count += 1
    return count


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string based on the following rules:
    "G" -> "G"
    "()" -> "o"
    "(al)" -> "al"
    Example: "G()(al)" -> "Goal"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims extra spaces and redistributes spaces evenly between words.
    (A simple approach; may not cover all edge cases.)
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    # Minimum spaces between words:
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            # Distribute extra spaces to the left
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Brute-force approach to the container with most water problem.
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters that appear exactly once in s.
    If all characters are unique, returns -1.
    """
    freq = {}
    for ch in s:
        freq[ch] = freq.get(ch, 0) + 1
    unique_chars = [ch for ch, count in freq.items() if count == 1]
    if len(unique_chars) == len(s):
        return -1
    return len(unique_chars)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For characters that repeat in s, returns the maximum gap (distance - 1)
    between two occurrences. If none repeat, returns -1.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element found in nums.
    If no duplicate exists, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Capitalizes the first letter of the string.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list nums and an integer n, interleaves the first n elements with the next n elements.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Splits the string by spaces and returns the last integer found (if any).
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among the list of strings.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes email addresses by removing dots in the local part (before '+')
    and ignoring any characters after '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price, subtracts the first subsequent smaller price (if found) and stops.
    """
    adjusted = prices[:]  # copy list
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the primary and secondary diagonal of a square matrix.
    For an odd-length matrix, the center element is counted only once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---





def count_elements_based_on_min_freq(nums: list) -> int:
    """
    Sorts the list and builds a frequency dictionary.
    Finds the number (key) with the lowest frequency and then counts how many elements in the sorted list are 
    greater than or equal to that number.
    """
    nums_sorted = sorted(nums)
    freq = {}
    for num in nums_sorted:
        freq[num] = freq.get(num, 0) + 1
    sorted_freq = sorted(freq.items(), key=lambda x: x[1])
    min_elem, _ = sorted_freq[0]
    total = sum(1 for num in nums_sorted if num >= min_elem)
    return total


# --- Next Function Block ---



def print_pattern_1(n: int) -> None:
    """
    Prints a pattern based on a condition:
    For each row i (1-indexed) and each column j (0-indexed) in a grid of width n, prints a star (*) or space.
    The condition is:
      - if (j < i and i <= 3) or (i > 3 and j <= n - i): print a space
      - else: print a star.
    """
    for i in range(1, n + 1):
        for j in range(n):
            if (j < i and i <= 3) or (i > 3 and j <= n - i):
                print(" ", end="  ")
            else:
                print("*", end="  ")
        print()


# --- Next Function Block ---



def print_pattern_2(n: int) -> None:
    """
    Prints a pattern on an n*n grid.
    For each cell (i, j) where 0 <= i, j < n*n, prints a star if j < 13 - i*i or j > 11 + i*i; otherwise prints spaces.
    (The condition is taken from the snippet; adjust as needed.)
    """
    total = n * n
    for i in range(total):
        for j in range(total):
            if j < 13 - i * i or j > 11 + i * i:
                print("*", end=" ")
            else:
                print("  ", end="")
        print()


# --- Next Function Block ---



def reconstruct_from_pieces(arr: list, pieces: list) -> (bool, list):
    """
    Tries to reconstruct the array by selecting unique pieces from 'pieces' that appear in 'arr'.
    Flattens the collected pieces and compares the result with arr.
    Returns a tuple (is_equal, reconstructed_array).
    """
    collected = []
    used = []
    for piece in pieces:
        if piece not in used and any(num in arr for num in piece):
            used.append(piece)
            collected.extend(piece)
    return (collected == arr, collected)


# --- Next Function Block ---



def is_arithmetic_progression(arr: list) -> bool:
    """
    Checks if the sorted array forms an arithmetic progression.
    """
    arr = sorted(arr)
    if len(arr) < 2:
        return True
    diff = arr[1] - arr[0]
    for i in range(1, len(arr) - 1):
        if arr[i + 1] - arr[i] != diff:
            return False
    return True


# --- Next Function Block ---



def check_progressions(*arrays) -> list:
    """
    For each array provided, returns True if it forms an arithmetic progression (when sorted), otherwise False.
    """
    results = []
    for arr in arrays:
        results.append(is_arithmetic_progression(arr))
    return results


# --- Next Function Block ---



def count_word_occurrences(sequence: str, word: str) -> int:
    """
    Returns the number of non-overlapping occurrences of word in sequence.
    """
    return sequence.count(word)


# --- Next Function Block ---



def count_word_occurrences_replace(sequence: str, word: str) -> int:
    """
    Uses string replacement to calculate the number of times word appears in sequence.
    """
    reduced = sequence.replace(word, "")
    return (len(sequence) - len(reduced)) // len(word)


# --- Next Function Block ---



def compute_subtractions(n: int) -> int:
    """
    Repeatedly subtracts floor(i/2) from i until i <= 1, summing all subtractions.
    """
    count = 0
    i = n
    while i > 1:
        sub = i // 2
        i = i - sub
        count += sub
    return count


# --- Next Function Block ---



def convert_zigzag(s: str, numRows: int) -> str:
    """
    Attempts to create a zigzag conversion of s for numRows.
    (Note: This implementation follows the provided snippet's structure and may differ from the standard solution.)
    """
    if numRows == 1 or numRows >= len(s):
        return s
    result = ""
    i = 0
    diff = numRows
    while len(result) < len(s):
        if i >= len(s):
            i -= len(s)
            if i % 2 == 0:
                diff = 2
                i = 1
            else:
                diff = numRows
        result += s[i]
        i += diff
    return result


# --- Next Function Block ---



def equal_vowel_halves(s: str) -> bool:
    """
    Splits string s into two halves and returns True if both halves have the same count of vowels.
    """
    vowels = set('aeiouAEIOU')
    half = len(s) // 2
    first_half = s[:half]
    second_half = s[half:]
    return sum(1 for ch in first_half if ch in vowels) == sum(1 for ch in second_half if ch in vowels)


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Given a list of vote strings, returns the vote with the highest frequency.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each i from 0 to len(s)-1, creates a pattern of 'R' repeated i times followed by 'L' repeated i times.
    Counts the total occurrences of these patterns in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    Given a list of items (each item is a list) and a ruleKey ("type", "color", or other),
    selects the element at the corresponding position (0 for "type", 1 for "color", 2 otherwise)
    and counts how many items have ruleValue at that position.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints the grid row by row.
    """
    for row in grid:
        for elem in row:
            print(elem, end=" ")
        print()


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of numbers that appear only once in the list.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times, adding (count+pos) to the sum.
    Resets count to 0 and increments pos when count reaches 7.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Returns a new list where each element is replaced by the element at the index equal to its value.
    """
    result = []
    for i in range(len(nums)):
        result.append(nums[nums[i]])
    return result


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Computes the difference between the sum of numbers in [1, n] not divisible by m and the sum of numbers divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (for i from 1 to 31) that exists in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers: 2, 4, 6, ... up to limit*2.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor of the minimum and maximum of the list.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts to reorder a list based on a nested loop strategy and checks if the
    resulting list equals the sorted version of the original list.
    (Logic follows the provided snippet; behavior may be non-standard.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 in str1 and returns the result.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx + len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Returns the sum of the minimum value of each row in a triangle (list of lists).
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of 'digit' from 'number' and returns a tuple with the resulting string and 
    a list of indices where the digit was found.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if all elements in nums have unique frequencies.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum count between occurrences of '1' and '0' in s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Determines if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Compares the string s against two alternating patterns ("0101..." and "1010...")
    and returns the minimum number of mismatches.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Iterates over the string s and when consecutive duplicate characters are found,
    flips the second one ("0" becomes "1" and vice versa) and counts the flips.
    Returns the modified string and the count of flips.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i + 1]:
            count += 1
            s_list[i + 1] = "1" if s_list[i + 1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the vote (string) with the highest frequency from the list.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each possible i, builds a pattern with i 'R's followed by i 'L's,
    and counts how many times each such pattern appears in s.
    Returns the total count.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    For each item in items (a list of lists), checks the element at a position determined by ruleKey 
    ("type" → index 0, "color" → index 1, otherwise index 2) and counts items that equal ruleValue.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints each element of a 2D grid.
    """
    for row in grid:
        for val in row:
            print(val, end=" ")
        print()


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of numbers that appear exactly once in the list.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times while updating two counters (count and pos) and returns the sum of (count+pos) over the iterations.
    Resets count to 0 and increments pos when count reaches 7.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Creates a new list where each element is replaced by the element at the index equal to its value.
    """
    return [nums[nums[i]] for i in range(len(nums))]


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Sums numbers from 1 to n that are not divisible by m and subtracts the sum of numbers that are divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (for i in range(1, 32)) that exists in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers from 2 to 2*limit.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor of the minimum and maximum values in the list.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts a reordering of the list based on the provided snippet.
    Returns True if the concatenation of the modified sublists equals the sorted original list.
    (Note: The original logic is unclear.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 in str1 and returns the modified string.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx+len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Sums the minimum element of each row in a triangle.
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of a digit from a number (given as a string).
    Returns the resulting string and a list of indices where removals occurred.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if all numbers in nums have unique frequencies.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum between the count of '1's and '0's in the string s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Returns True if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Computes the number of mismatches between s and two alternating patterns ("0101..." and "1010...").
    Returns the smaller mismatch count.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Flips the second of any two consecutive identical characters ("0" becomes "1", "1" becomes "0").
    Returns the resulting string and the count of flips.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i + 1]:
            count += 1
            s_list[i + 1] = "1" if s_list[i + 1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the vote (string) with the highest frequency.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each possible repetition count i, builds a pattern of i 'R's followed by i 'L's,
    and sums up how many times these patterns appear in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    For a list of items (each item is a list) and a ruleKey ("type", "color", or other),
    selects the element at index 0 for "type", index 1 for "color", and index 2 otherwise,
    then counts how many items have that element equal to ruleValue.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints the elements of a 2D grid.
    """
    for row in grid:
        print(" ".join(str(x) for x in row))


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of the numbers that appear exactly once in the list.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times, updating a counter and position.
    Adds (count + pos) on each iteration; resets count after 7 iterations and increments pos.
    Returns the total sum.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Constructs a new list where each element at index i is replaced by nums[nums[i]].
    """
    return [nums[nums[i]] for i in range(len(nums))]


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Returns the difference between the sum of numbers 1 to n that are not divisible by m and the sum of those divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (for i in 1..31) found in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers from 2 to 2*limit.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor (GCD) of the minimum and maximum of nums.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts a reordering (as in the provided snippet) and returns True if the concatenation
    of modified segments equals the sorted version of the original list.
    (The logic is based on the snippet and may be non-standard.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 in str1 and returns the resulting string.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx + len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Returns the sum of the minimum elements of each row in a triangle (list of lists).
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of the specified digit from the number (as a string).
    Returns a tuple of the new string and a list of indices where the digit was found.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if the frequency of each number in nums is unique.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum count between occurrences of '1' and '0' in the string s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Returns True if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Computes the number of mismatches between s and two alternating patterns ("0101..." and "1010...").
    Returns the smaller mismatch count.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Iterates over the string s and, when two consecutive identical characters are found,
    flips the second character ("0" becomes "1" and vice versa). Returns the modified string and the count of flips.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i + 1]:
            count += 1
            s_list[i + 1] = "1" if s_list[i + 1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the candidate (vote) with the highest number of votes.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each possible repetition count i, builds a pattern of 'R'*i + 'L'*i,
    and returns the total number of occurrences of such patterns in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    Counts how many items in a list of lists have the value ruleValue at a specific index:
      - 0 for ruleKey "type"
      - 1 for ruleKey "color"
      - 2 otherwise.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of numbers in the list that appear exactly once.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times, updating counters 'count' and 'pos'. Adds (count+pos) to the sum,
    resets count to 0 and increments pos after 7 iterations. Returns the final sum.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Creates a new list by mapping each index i to the element at index nums[i].
    """
    return [nums[nums[i]] for i in range(len(nums))]


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Computes the difference between the sum of numbers 1 to n that are not divisible by m
    and the sum of numbers that are divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (i * n for some i in 1..31) that is present in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers from 2 to 2*limit.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor (GCD) of the minimum and maximum values in nums.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts a reordering based on the provided logic and returns True if the concatenation of 
    modified segments equals the sorted original list.
    (The logic is directly derived from the snippet and might be non-standard.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 in str1 and returns the result.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx + len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Returns the sum of the minimum elements from each row of a triangle (list of lists).
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of the given digit from the string 'number'.
    Returns a tuple with the new string and the list of indices where the digit was found.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if each number in nums has a unique frequency.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum count between the number of '1's and '0's in s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Returns True if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Compares s against two alternating patterns ("0101..." and "1010...") and returns the minimum mismatch count.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Flips the second character in any pair of consecutive identical characters ("0" <-> "1")
    and returns the modified string along with the count of flips.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i + 1]:
            count += 1
            s_list[i + 1] = "1" if s_list[i + 1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the candidate with the highest vote count.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each possible i (0 <= i < len(s)), builds a pattern of i 'R's followed by i 'L's and sums
    the occurrences of these patterns in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    Counts how many items (each a list) have ruleValue at a position determined by ruleKey:
      - 0 for "type"
      - 1 for "color"
      - 2 otherwise.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints a 2D grid.
    """
    for row in grid:
        print(" ".join(str(x) for x in row))


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Returns the sum of numbers in nums that appear exactly once.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
                break
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def custom_sum(n: int) -> int:
    """
    Iterates n times, updating two counters (count and pos), adding (count+pos) each time.
    Resets count after 7 iterations and increments pos. Returns the total sum.
    """
    count = 0
    pos = 1
    total = 0
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_based_mapping(nums: list) -> list:
    """
    Returns a new list where each element is replaced by the element at index equal to its value.
    """
    return [nums[nums[i]] for i in range(len(nums))]


# --- Next Function Block ---



def sum_difference(n: int, m: int) -> int:
    """
    Computes the difference between the sum of numbers from 1 to n that are not divisible by m 
    and the sum of numbers that are divisible by m.
    """
    s1 = sum(i for i in range(1, n + 1) if i % m != 0)
    s2 = sum(i for i in range(1, n + 1) if i % m == 0)
    return s1 - s2


# --- Next Function Block ---



def first_multiple_in_array(n: int, arr: list) -> int:
    """
    Returns the first multiple of n (for i in 1..31) that is present in arr.
    """
    for i in range(1, 32):
        if i * n in arr:
            return i * n
    return None


# --- Next Function Block ---



def generate_even_numbers(limit: int) -> list:
    """
    Returns a list of even numbers from 2 to 2*limit.
    """
    return [i * 2 for i in range(1, limit + 1)]


# --- Next Function Block ---



def gcd_low_high(nums: list) -> int:
    """
    Returns the greatest common divisor of the minimum and maximum values in nums.
    """
    low = min(nums)
    high = max(nums)
    for i in range(low, 0, -1):
        if high % i == 0 and low % i == 0:
            return i
    return 1


# --- Next Function Block ---



def has_exactly_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    """
    count = sum(1 for i in range(1, n + 1) if n % i == 0)
    return count == 3


# --- Next Function Block ---



def check_reordering(nums: list) -> bool:
    """
    Attempts a reordering based on a nested deletion loop and returns True if the concatenation 
    of the removed elements and the remaining list equals the sorted original list.
    (Logic is directly based on the snippet and may be non-standard.)
    """
    original_sorted = sorted(nums)
    arr = []
    i = 0
    nums_copy = nums[:]
    while i < len(nums_copy) - 1:
        if nums_copy[i + 1] < nums_copy[i]:
            j = i + 1
            while j < len(nums_copy):
                arr.append(nums_copy[j])
                del nums_copy[j]
        i += 1
    return (arr + nums_copy) == original_sorted


# --- Next Function Block ---



def remove_substring(str1: str, str2: str) -> str:
    """
    Removes the first occurrence of str2 from str1 and returns the resulting string.
    """
    idx = str1.find(str2)
    if idx == -1:
        return str1
    return str1[:idx] + str1[idx+len(str2):]


# --- Next Function Block ---



def sum_of_triangle_mins(triangle: list) -> int:
    """
    Returns the sum of the minimum element from each row of a triangle.
    """
    return sum(min(row) for row in triangle)


# --- Next Function Block ---



def remove_digit(number: str, digit: str) -> (str, list):
    """
    Removes all occurrences of a given digit from the number (as a string).
    Returns a tuple containing the new string and a list of indices where the digit was removed.
    """
    indices = []
    result = ""
    for i, ch in enumerate(number):
        if ch == digit:
            indices.append(i)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---



def are_frequencies_unique(nums: list) -> bool:
    """
    Returns True if all numbers in nums have unique frequencies.
    """
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    freqs = list(freq.values())
    return len(freqs) == len(set(freqs))


# --- Next Function Block ---



def max_digit_count(s: str) -> int:
    """
    Returns the maximum count between occurrences of '1' and '0' in s.
    """
    return max(s.count("1"), s.count("0"))


# --- Next Function Block ---



def can_transform(s1: str, s2: str, max_changes: int = 3) -> bool:
    """
    Returns True if s2 can be transformed into s1 by changing at most max_changes characters.
    """
    if len(s1) != len(s2):
        return False
    changes = 0
    s2_list = list(s2)
    for i in range(len(s1)):
        if s1[i] != s2_list[i]:
            changes += 1
            s2_list[i] = s1[i]
            if changes > max_changes:
                return False
    return "".join(s2_list) == s1


# --- Next Function Block ---



def min_alternating_mismatches(s: str) -> int:
    """
    Computes the mismatch count between s and two alternating patterns ("0101..." and "1010...")
    and returns the minimum of the two counts.
    """
    pattern1 = "".join("0" if i % 2 == 0 else "1" for i in range(len(s)))
    pattern2 = "".join("1" if i % 2 == 0 else "0" for i in range(len(s)))
    mismatches1 = sum(1 for a, b in zip(s, pattern1) if a != b)
    mismatches2 = sum(1 for a, b in zip(s, pattern2) if a != b)
    return min(mismatches1, mismatches2)


# --- Next Function Block ---



def flip_adjacent_duplicates(s: str) -> (str, int):
    """
    Iterates over s and flips the second character of any adjacent duplicate pair
    (switching '0' to '1' and vice versa). Returns the modified string and the flip count.
    """
    s_list = list(s)
    count = 0
    for i in range(len(s_list) - 1):
        if s_list[i] == s_list[i+1]:
            count += 1
            s_list[i+1] = "1" if s_list[i+1] == "0" else "0"
    return "".join(s_list), count


# --- Next Function Block ---



def majority_vote(votes: list) -> str:
    """
    Returns the candidate with the highest vote count from the list.
    """
    counts = {}
    for vote in votes:
        counts[vote] = counts.get(vote, 0) + 1
    return max(counts.items(), key=lambda x: x[1])[0]


# --- Next Function Block ---



def count_rl_patterns(s: str) -> int:
    """
    For each i (from 0 to len(s)-1), creates a pattern of 'R'*i followed by 'L'*i,
    and sums the number of times such patterns occur in s.
    """
    total = 0
    for i in range(len(s)):
        pattern = "R" * i + "L" * i
        if pattern:
            total += s.count(pattern)
    return total


# --- Next Function Block ---



def count_items_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    For a list of items (each a list), returns the count of items where the element at position 
    (0 for "type", 1 for "color", 2 otherwise) equals ruleValue.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def sum_of_prefix_differences(nums: list) -> list:
    """
    Computes two prefix sum arrays (left from the start and right from the end) and returns 
    a list of absolute differences between corresponding elements.
    """
    n = len(nums)
    left = [0] * n
    right = [0] * n
    s_left, s_right = 0, 0
    for i in range(n):
        left[i] = s_left
        s_left += nums[i]
        right[i] = s_right
        s_right += nums[n - 1 - i]
    return [abs(left[i] - right[n - 1 - i]) for i in range(n)]


# --- Next Function Block ---



def print_custom_pattern(n: int) -> None:
    """
    Prints a pattern on an n*n grid.
    The pattern logic follows the snippet condition: if j < 13 - i*i or j > 11 + i*i, print "*"; else print spaces.
    """
    total = n * n
    for i in range(total):
        for j in range(total):
            if j < 13 - i * i or j > 11 + i * i:
                print("*", end=" ")
            else:
                print("  ", end="")
        print()


# --- Next Function Block ---



def convert_date(date: str) -> str:
    """
    Converts a date from a format like "20th Oct 2052" to "2052-10-20".
    Assumes the day part may have ordinal suffixes.
    """
    month_map = {"Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04",
                 "May": "05", "Jun": "06", "Jul": "07", "Aug": "08",
                 "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"}
    parts = date.split()
    day = "".join(filter(str.isdigit, parts[0]))
    if len(day) == 1:
        day = "0" + day
    month = month_map[parts[1]]
    year = parts[2]
    return f"{year}-{month}-{day}"


# --- Next Function Block ---



def count_odds_in_range(low: int, high: int) -> int:
    """
    Returns the count of odd numbers in the inclusive range [low, high].
    """
    return sum(1 for i in range(low, high + 1) if i % 2 != 0)


# --- Next Function Block ---



def rearrange_string(s: str, indices: list) -> str:
    """
    Rearranges the characters in s according to the provided indices.
    """
    mapping = {idx: ch for idx, ch in zip(indices, s)}
    sorted_mapping = dict(sorted(mapping.items()))
    return "".join(sorted_mapping[i] for i in sorted_mapping)


# --- Next Function Block ---



def repeat_alternate(nums: list) -> list:
    """
    For every even-indexed element in nums, repeats the element at index i+1 a number of times equal to nums[i].
    Returns the resulting list.
    Example: for nums = [1,2,3,4], returns [2,4,4,4].
    """
    result = []
    for i in range(0, len(nums), 2):
        if i + 1 < len(nums):
            result.extend([nums[i+1]] * nums[i])
    return result


# --- Next Function Block ---



def first_k_words(s: str, k: int) -> str:
    """
    Returns the first k words from the string s.
    """
    words = s.split()
    return " ".join(words[:k])


# --- Next Function Block ---



def compare_word_lists(word1: list, word2: list) -> bool:
    """
    Concatenates the lists of strings and returns True if the resulting strings are equal.
    """
    return "".join(word1) == "".join(word2)


# --- Next Function Block ---



def sum_minus_digit_sum(nums: list) -> int:
    """
    Returns the difference between the sum of numbers in nums and the sum of all their digits.
    """
    total = sum(nums)
    digit_sum = sum(int(ch) for num in nums for ch in str(num))
    return total - digit_sum


# --- Next Function Block ---



def count_pairs_with_difference(nums: list, k: int) -> int:
    """
    Counts unique pairs (i, j) with i < j in nums such that abs(nums[i] - nums[j]) == k.
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if abs(nums[i] - nums[j]) == k:
                count += 1
    return count


# --- Next Function Block ---



def count_special_pairs(nums: list, k: int) -> int:
    """
    Counts pairs (i, j) with i < j where nums[i] equals nums[j] and (i*j) % k == 0.
    """
    count = 0
    n = len(nums)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if nums[i] == nums[j] and (i * j) % k == 0:
                count += 1
    return count


# --- Next Function Block ---



def format_number_with_dots(n: int) -> str:
    """
    Formats the integer n by inserting dots as thousand separators.
    Example: 1234567 -> "1.234.567"
    """
    s = str(n)
    result = ""
    count = 0
    for ch in s[::-1]:
        if count == 3:
            result = "." + result
            count = 0
        result = ch + result
        count += 1
    return result


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the count of words in the list that contain only characters from allowed.
    """
    count = 0
    for word in words:
        if all(ch in allowed for ch in word):
            count += 1
    return count


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Formats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are also in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string: "G" remains, "()" becomes "o", and "(al)" becomes "al".
    Example: "G()(al)" -> "Goal"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims the text and redistributes spaces evenly between words.
    (A simple implementation that may not cover all edge cases.)
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area for the container with most water problem (brute force approach).
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For characters that repeat in s, returns the maximum gap (distance minus one)
    between two occurrences. If none repeat, returns -1.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps)


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums; if none exist, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Capitalizes the first letter of the string.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list 'nums' of length 2*n, interleaves the first n elements with the next n elements.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Splits s by spaces and returns the last integer found, or 0 if none.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Finds the longest common prefix among the list of strings using a brute-force approach.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes a list of emails by removing dots and ignoring characters after '+' in the local part.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price in the list, finds the first subsequent smaller price and subtracts it from the current price.
    Returns the modified list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the primary and secondary diagonal of a square matrix.
    If the matrix has an odd center, that value is subtracted once (since it was counted twice).
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the count of words in the list that contain only characters from allowed.
    """
    count = 0
    for word in words:
        if all(ch in allowed for ch in word):
            count += 1
    return count


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the number of characters in stones that are present in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string:
      "G" remains "G",
      "()" becomes "o",
      "(al)" becomes "al".
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels (starting from 'A').
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims the text and redistributes spaces evenly between words.
    (A simple approach; edge cases may vary.)
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area that can be formed by two lines in the list 'height'.
    (Brute-force O(n^2) approach.)
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For each character that repeats in s, computes the gap (difference in indices minus one)
    between its first and last occurrence. Returns the maximum such gap; if no repeats, returns -1.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums.
    If there are no duplicates, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Returns s with its first letter capitalized.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first half with the second half.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Returns the last integer found in s when splitting by spaces.
    If no integer is found, returns 0.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among the list of strings using a brute-force approach.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates in-place from a sorted list and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes emails by removing dots from the local part and ignoring everything after a '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price in prices, finds the first subsequent smaller price and subtracts it from the current price.
    Returns the adjusted list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the main and secondary diagonals of a square matrix.
    For odd-sized matrices, the center element is subtracted once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the number of words that consist solely of characters in allowed.
    """
    count = 0
    for word in words:
        if all(ch in allowed for ch in word):
            count += 1
    return count


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing each '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the number of characters in stones that are also in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string:
      - "G" -> "G"
      - "()" -> "o"
      - "(al)" -> "al"
    Example: "G()(al)" -> "Goal"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels (starting from 'A').
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims extra spaces from the text and redistributes spaces evenly between words.
    (Simple implementation.)
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area that can be formed by two indices in height (brute-force approach).
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For characters that repeat in s, returns the maximum gap (index difference minus one)
    between two occurrences. Returns -1 if no character repeats.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums, or None if there is none.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Returns the string s with its first letter capitalized.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first n elements with the last n elements.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Splits s by spaces and returns the last integer found, or 0 if none.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Finds the longest common prefix among the given list of strings.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes emails by removing dots in the local part and ignoring characters after '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price, finds the first subsequent smaller price and subtracts it from the current price.
    Returns the adjusted list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the main and secondary diagonals of a square matrix.
    If the matrix has an odd center, subtracts the center value once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the count of words that consist solely of characters in allowed.
    """
    return sum(1 for word in words if all(ch in allowed for ch in word))


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all odd-length subarrays of arr.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are also in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Interprets the command string:
      - "G" becomes "G"
      - "()" becomes "o"
      - "(al)" becomes "al"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims and redistributes spaces evenly between words in the text.
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum container area using a brute-force approach.
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters that appear exactly once in s.
    If all characters are unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For characters that repeat in s, returns the maximum gap (difference in indices minus one).
    Returns -1 if no character repeats.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums; returns None if there are no duplicates.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Returns the string s with its first letter capitalized.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first half with the second half.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Returns the last integer found in s when splitting by spaces, or 0 if none.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among the given strings using a brute-force method.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates in-place from a sorted list and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes email addresses by removing dots in the local part (before '+')
    and ignoring any characters after '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price in prices, subtracts the first subsequent smaller price (if found) and returns the modified list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of both the primary and secondary diagonals of a square matrix.
    If the matrix has an odd dimension, subtracts the center element once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the number of words that contain only characters found in allowed.
    """
    return sum(1 for word in words if all(ch in allowed for ch in word))


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing each '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the number of characters in stones that are also in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Interprets a command string:
      - "G" remains "G"
      - "()" becomes "o"
      - "(al)" becomes "al"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims the text and evenly redistributes spaces between words.
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area that can be formed between two lines in the list 'height'.
    (Brute-force approach.)
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    Returns the maximum gap (difference in indices minus one) between any two occurrences 
    of the same character in s. Returns -1 if no repeats exist.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element found in nums. Returns None if there is no duplicate.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Returns s with its first character capitalized.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first half with the second half.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Splits s by spaces and returns the last integer found; returns 0 if none is found.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among a list of strings using a brute-force approach.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates in-place from a sorted list and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes a list of emails by removing dots ('.') from the local part and ignoring everything after a '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price, finds the first subsequent smaller price and subtracts it from the current price.
    Returns the adjusted list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the primary and secondary diagonals of a square matrix.
    For odd dimensions, the center element is subtracted once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n//2][n//2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the number of words that consist only of characters in allowed.
    """
    return sum(1 for word in words if all(ch in allowed for ch in word))


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are also present in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string by mapping:
      "G" -> "G"
      "()" -> "o"
      "(al)" -> "al"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims extra spaces from text and evenly redistributes them between words.
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return result


# --- Next Function Block ---



def max_area_container(height: list) -> int:
    """
    Returns the maximum area that can be contained between two lines in the list height.
    (Brute-force approach.)
    """
    max_area = 0
    n = len(height)
    for i in range(n - 1):
        for j in range(i + 1, n):
            area = min(height[i], height[j]) * (j - i)
            max_area = max(max_area, area)
    return max_area


# --- Next Function Block ---



def unique_characters_count(s: str) -> int:
    """
    Returns the count of characters in s that appear exactly once.
    If every character is unique, returns -1.
    """
    freq = Counter(s)
    if len(freq) == len(s):
        return -1
    return sum(1 for count in freq.values() if count == 1)


# --- Next Function Block ---



def max_gap_between_repeats(s: str) -> int:
    """
    For each character that repeats in s, returns the maximum gap (index difference minus one)
    between any two occurrences. If no character repeats, returns -1.
    """
    gaps = [-1]
    for i in range(len(s) - 1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                gaps.append(j - i - 1)
    return max(gaps) if gaps else -1


# --- Next Function Block ---



def first_duplicate(nums: list):
    """
    Returns the first duplicate element in nums, or None if no duplicate exists.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---



def capitalize_first_letter(s: str) -> str:
    """
    Capitalizes the first letter of s.
    """
    if not s:
        return s
    return s[0].upper() + s[1:]


# --- Next Function Block ---



def interleave_halves(nums: list, n: int) -> list:
    """
    Given a list of length 2*n, interleaves the first half with the second half.
    """
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result


# --- Next Function Block ---



def extract_number(s: str) -> int:
    """
    Returns the last integer found in s after splitting by spaces; returns 0 if none.
    """
    for token in s.split()[::-1]:
        try:
            return int(token)
        except ValueError:
            continue
    return 0


# --- Next Function Block ---



def longest_common_prefix_brute(strs: list) -> str:
    """
    Returns the longest common prefix among a list of strings.
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if prefix == "":
                return ""
    return prefix


# --- Next Function Block ---



def remove_duplicates(nums: list) -> int:
    """
    Removes duplicates from a sorted list in-place and returns the new length.
    """
    if not nums:
        return 0
    j = 0
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
    return j + 1


# --- Next Function Block ---



def normalize_emails(emails: list) -> list:
    """
    Normalizes emails by removing '.' from the local part and ignoring characters after '+'.
    """
    def normalize(email: str) -> str:
        local, domain = email.split('@')
        local = local.split('+')[0].replace('.', '')
        return local + '@' + domain
    return [normalize(email) for email in emails]


# --- Next Function Block ---



def adjust_prices(prices: list) -> list:
    """
    For each price in prices, subtracts the first subsequent smaller price (if any) from it.
    Returns the adjusted list.
    """
    adjusted = prices[:]
    for i in range(len(adjusted) - 1):
        for j in range(i + 1, len(adjusted)):
            if adjusted[i] > adjusted[j]:
                adjusted[i] -= adjusted[j]
                break
    return adjusted


# --- Next Function Block ---



def sum_diagonals(mat: list) -> int:
    """
    Returns the sum of the primary and secondary diagonals of a square matrix.
    If the matrix size is odd, the center element is counted only once.
    """
    n = len(mat)
    total = 0
    for i in range(n):
        total += mat[i][i] + mat[i][n - 1 - i]
    if n % 2 == 1:
        total -= mat[n // 2][n // 2]
    return total


# --- Next Function Block ---



def count_allowed_words(allowed: str, words: list) -> int:
    """
    Returns the number of words composed solely of characters in allowed.
    """
    return sum(1 for word in words if all(ch in allowed for ch in word))


# --- Next Function Block ---



def sum_of_odd_length_subarrays(arr: list) -> int:
    """
    Returns the sum of all odd-length subarrays of arr.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---



def format_ip_address(address: str) -> str:
    """
    Reformats an IP address by replacing '.' with '[.]'.
    """
    return "[.]".join(address.split("."))


# --- Next Function Block ---



def count_jewels(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are in jewels.
    """
    return sum(1 for ch in stones if ch in jewels)


# --- Next Function Block ---



def interpret_command(command: str) -> str:
    """
    Decodes a command string by mapping:
      "G" -> "G",
      "()" -> "o",
      "(al)" -> "al".
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---



def print_excel_columns(n: int) -> None:
    """
    Prints the first n Excel column labels starting from 'A'.
    """
    for i in range(n):
        print(chr(ord('A') + i))


# --- Next Function Block ---



def reformat_text(text: str) -> str:
    """
    Trims the text and redistributes spaces evenly between words.
    """
    words = text.strip().split()
    if len(words) <= 1:
        return text.strip()
    total_spaces = text.count(" ")
    base_spaces = total_spaces // (len(words) - 1)
    extra_spaces = total_spaces % (len(words) - 1)
    result = ""
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            spaces = base_spaces + (1 if i < extra_spaces else 0)
            result += " " * spaces
    return re


# --- Next Function Block ---


# patterns.py

def count_elements_geq_lowest_freq(nums: list) -> int:
    """
    Sorts the list, builds a frequency dictionary, then finds the smallest frequency entry.
    Returns the count of numbers in nums that are greater than or equal to the key
    of the lowest-frequency element.
    Example:
      nums = [3,9,7,8,3,8,6,6]
      Sorted nums: [3,3,6,6,7,8,8,9]
      Frequency: {3:2, 6:2, 7:1, 8:2, 9:1}
      Lowest frequency entry: (7,1)
      Count numbers >= 7 → 7,8,8,9 → 4
    """
    nums.sort()
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    # Get the (number, count) pair with the minimum count
    low = sorted(freq.items(), key=lambda x: x[1])[0]
    total = sum(1 for num in nums if num >= low[0])
    return total


# --- Next Function Block ---



def print_pattern_1(n: int) -> None:
    """
    Prints a pattern for n rows.
    (Based on the snippet with two nested loops and conditional spacing.)
    """
    for i in range(1, n + 1):
        for j in range(n):
            # Example condition: for i <= 3, print spaces for j < i; for i > 3, print spaces for j <= n-i.
            if (j < i and i <= 3) or (i > 3 and j <= n - i):
                print(" ", end="  ")
            else:
                print("*", end="  ")
        print("\n", end="")


# --- Next Function Block ---



def print_pattern_2(n: int) -> None:
    """
    Prints a second pattern based on an n*n grid.
    (The conditions are taken from the provided snippet.)
    """
    total = n * n
    for i in range(total):
        for j in range(total):
            # The condition is taken as provided; adjust if needed.
            if j < 13 - i * i or j > 11 + i * i:
                print("*", end=" ")
            else:
                print("  ", end="")
        print("\n", end="")


# --- Next Function Block ---



def convert_date(date: str) -> str:
    """
    Converts a date string like "20th Oct 2052" to the format "2052-10-20".
    """
    month_map = {
        "Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04",
        "May": "05", "Jun": "06", "Jul": "07", "Aug": "08",
        "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"
    }
    parts = date.split(" ")
    # Remove non-digit characters from the day part.
    day = "".join(ch for ch in parts[0] if ch.isdigit())
    if len(day) == 1:
        day = "0" + day
    month = month_map[parts[1]]
    year = parts[2]
    return f"{year}-{month}-{day}"


# --- Next Function Block ---



def count_odds_in_range(low: int, high: int) -> int:
    """
    Counts the number of odd numbers in the inclusive range [low, high].
    """
    count = 0
    for i in range(low, high + 1):
        if i % 2 != 0:
            count += 1
    return count


# --- Next Function Block ---



def reorder_string(s: str, indices: list) -> str:
    """
    Reorders string s based on the list of indices.
    Example:
       s = "codeleet", indices = [4,5,6,7,0,2,1,3] → returns "leetcode"
    """
    mapping = {idx: ch for idx, ch in zip(indices, s)}
    # Sort by index and join the characters.
    result = "".join(mapping[i] for i in sorted(mapping))
    return result


# --- Next Function Block ---



def running_sum(nums: list) -> list:
    """
    Returns a list of the running (cumulative) sum of nums.
    """
    total = 0
    result = []
    for num in nums:
        total += num
        result.append(total)
    return result


# --- Next Function Block ---



def sentence_with_most_words(sentences: list) -> list:
    """
    Splits each sentence into words and returns the word list for the sentence with the most words.
    """
    max_words = []
    for sentence in sentences:
        words = sentence.split()
        if len(words) > len(max_words):
            max_words = words
    return max_words


# --- Next Function Block ---



def prefix_diff(nums: list) -> list:
    """
    Computes two arrays:
      - left prefix sums (excluding current index)
      - right prefix sums (from the end)
    Returns a list of absolute differences between left prefix at index i and the reversed right prefix.
    """
    n = len(nums)
    left = []
    right = []
    s_left = 0
    s_right = 0
    for i in range(n):
        left.append(s_left)
        s_left += nums[i]
        right.append(s_right)
        s_right += nums[n - 1 - i]
    diff = []
    for i in range(n):
        diff.append(abs(left[i] - right[n - 1 - i]))
    return diff


# --- Next Function Block ---



def count_frequency_and_elements(nums: list) -> int:
    """
    Builds a frequency dictionary for nums, then finds the entry with the lowest frequency.
    Counts and prints indices and values for numbers in nums that are greater than or equal to the key
    of that lowest-frequency entry. Returns the total count.
    """
    nums.sort()
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    # Get the (number, count) pair with the minimum frequency.
    low = sorted(freq.items(), key=lambda x: x[1])[0]
    total = 0
    for i, num in enumerate(nums):
        if num >= low[0]:
            total += 1
            print(i, num)
    return total


# --- Next Function Block ---



def validate_pieces(arr: list, pieces: list) -> bool:
    """
    Given an array 'arr' and a list of lists 'pieces', attempts to reassemble arr
    by selecting pieces (each piece is a list of integers) if their elements appear in arr.
    Returns True if the concatenated pieces equal arr; otherwise, False.
    (Logic is based on the snippet and may need adjustment.)
    """
    assembled = []
    used = []
    # For each piece in pieces, if not already used and if its elements appear in arr, add it.
    for piece in pieces:
        if piece not in used and all(x in arr for x in piece):
            assembled.extend(piece)
            used.append(piece)
    return assembled == arr


# --- Next Function Block ---



def is_arithmetic_sequence(arr: list) -> bool:
    """
    Checks if the sorted list arr forms an arithmetic sequence.
    """
    if len(arr) < 2:
        return True
    arr = sorted(arr)
    diff = arr[1] - arr[0]
    for i in range(1, len(arr)):
        if arr[i] - arr[i - 1] != diff:
            return False
    return True


# --- Next Function Block ---



def are_all_arithmetic(lists: list) -> list:
    """
    Given a list of lists (each list of numbers), returns a list of booleans indicating whether
    each individual list is an arithmetic sequence.
    """
    result = []
    for lst in lists:
        result.append(is_arithmetic_sequence(lst))
    return result


# --- Next Function Block ---



def max_occurrences_of_word(sequence: str, word: str) -> int:
    """
    Returns the maximum number of non-overlapping occurrences of 'word' in 'sequence'.
    (Uses both a replace method and the built-in count for verification.)
    """
    count_builtin = sequence.count(word)
    # Alternatively, you might iterate over sequence to count non-overlapping occurrences.
    i, count = 0, 0
    while i <= len(sequence) - len(word):
        if sequence[i:i+len(word)] == word:
            count += 1
            i += len(word)
        else:
            i += 1
    # Return whichever count is higher (they should be equal if word does not overlap)
    return max(count, count_builtin)


# --- Next Function Block ---



def sum_halves(n: int) -> int:
    """
    Given n, repeatedly subtract half (floor division) until i <= 1.
    Returns the sum of all subtracted values.
    """
    count = 0
    while n > 1:
        sub = n // 2
        n = n - sub
        count += sub
    return count


# --- Next Function Block ---



def zigzag_convert(s: str, numRows: int) -> str:
    """
    Converts the string s into a zigzag pattern on numRows and reads line by line.
    (A simplified version of the zigzag conversion problem.)
    """
    if numRows == 1 or numRows >= len(s):
        return s
    rows = [''] * numRows
    cur_row, step = 0, 1
    for char in s:
        rows[cur_row] += char
        if cur_row == 0:
            step = 1
        elif cur_row == numRows - 1:
            step = -1
        cur_row += step
    return "".join(rows)


# --- Next Function Block ---



def equal_half_vowels(s: str) -> bool:
    """
    Checks if the first half and second half of string s have the same number of vowels.
    Assumes s length is even.
    """
    vowels = set("aeiouAEIOU")
    half = len(s) // 2
    first_half = s[:half]
    second_half = s[half:]
    count_first = sum(1 for ch in first_half if ch in vowels)
    count_second = sum(1 for ch in second_half if ch in vowels)
    return count_first == count_second


# --- Next Function Block ---



def election_winner(votes: list) -> str:
    """
    Given a list of votes (strings), returns the candidate with the most votes.
    """
    vote_counts = {}
    for vote in votes:
        vote_counts[vote] = vote_counts.get(vote, 0) + 1
    # Find candidate with maximum votes
    winner = max(vote_counts.items(), key=lambda x: x[1])[0]
    return winner


# --- Next Function Block ---



def count_special_substrings(s: str, r: str = "R", l: str = "L") -> int:
    """
    Constructs substrings of the form r repeated i times concatenated with l repeated i times,
    counts occurrences in s.
    """
    count_total = 0
    for i in range(1, len(s) + 1):
        substr = r * i + l * i
        if substr in s:
            occurrence = s.count(substr)
            print(substr, occurrence)
            count_total += occurrence
    return count_total


# --- Next Function Block ---



def count_by_rule(items: list, ruleKey: str, ruleValue: str) -> int:
    """
    Given a list of item lists and a rule specified by ruleKey ("type", "color", or "name"),
    counts how many items have the ruleValue at the corresponding index.
    Assumes: type → index 0, color → index 1, name → index 2.
    """
    if ruleKey == "type":
        pos = 0
    elif ruleKey == "color":
        pos = 1
    else:
        pos = 2
    count = 0
    for item in items:
        if pos < len(item) and item[pos] == ruleValue:
            count += 1
    return count


# --- Next Function Block ---



def print_grid(grid: list) -> None:
    """
    Prints all elements of a 2D grid.
    """
    for row in grid:
        for elem in row:
            print(elem, end=" ")
        print()


# --- Next Function Block ---



def sum_unique(nums: list) -> int:
    """
    Sums numbers that appear only once in the list.
    """
    total = 0
    for i in range(len(nums)):
        unique = True
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                unique = False
        if unique:
            total += nums[i]
    return total


# --- Next Function Block ---



def sum_with_pattern(n: int) -> int:
    """
    For n iterations, accumulates a sum based on an increasing count and a position that resets every 7 counts.
    """
    total = 0
    count = 0
    pos = 1
    for _ in range(n):
        if count == 7:
            count = 0
            pos += 1
        total += count + pos
        count += 1
    return total


# --- Next Function Block ---



def index_mapping(nums: list) -> list:
    """
    Returns a new list where each element is nums[nums[i]].
    Assumes that all nums[i] are valid indices.
    """
    return [nums[x] for x in nums]


# --- Next Function Block ---



def sum_diff_by_divisibility(n: int, m: int) -> int:
    """
    Sums numbers from 1 to n that are not divisible by m and subtracts the sum of numbers that are divisible by m.
    """
    total_non_div = 0
    total_div = 0
    for i in range(1, n + 1):
        if i % m == 0:
            total_div += i
        else:
            total_non_div += i
    return total_non_div - total_div


# --- Next Function Block ---



def first_multiple_in_list(n: int, arr: list) -> int:
    """
    Returns the first multiple of n that is present in arr.
    """
    i = 1
    while True:
        multiple = i * n
        if multiple in arr:
            return multiple
        i += 1


# --- Next Function Block ---


def first_n_evens(n: int) -> list:
    """
    Returns a list of the first n even numbers.
    """
    return [i * 2 for i in range(1, n + 1)]


# --- Next Function Block ---


def gcd_from_list(nums: list) -> int:
    """
    Returns the greatest common divisor (GCD) of the minimum and maximum elements in nums.
    (Assumes positive numbers.)
    """
    from math import gcd
    low = min(nums)
    high = max(nums)
    return gcd(low, high)


# --- Next Function Block ---


def has_three_divisors(n: int) -> bool:
    """
    Returns True if n has exactly three divisors.
    (This happens if n is a perfect square of a prime.)
    """
    import math
    if n < 4:
        return False
    sqrt_n = math.isqrt(n)
    if sqrt_n * sqrt_n != n:
        return False
    # Check if sqrt_n is prime.
    for i in range(2, int(math.sqrt(sqrt_n)) + 1):
        if sqrt_n % i == 0:
            return False
    return True


# --- Next Function Block ---


def custom_sort_validation(nums: list) -> bool:
    """
    Attempts a custom sort by removing and appending elements.
    Returns True if the custom-sorted list equals the actual sorted list.
    (Logic based on the provided snippet.)
    """
    original = nums[:]
    target = sorted(nums)
    arr = []
    i = 0
    # Use a copy for processing.
    temp = nums[:]
    while i < len(temp) - 1:
        if temp[i+1] < temp[i]:
            # Append the element at i+1 and remove it.
            arr.append(temp[i+1])
            del temp[i+1]
        else:
            i += 1
    result = arr + temp
    return result == target


# --- Next Function Block ---


def custom_remove_substring(str1: str, str2: str) -> str:
    """
    (Based on the provided snippet)
    If str2 is in str1, finds the first occurrence indices and removes that part.
    Otherwise returns str1.
    Note: If str2 is empty, returns str1.
    """
    if not str2:
        return str1
    idx = str1.find(str2)
    if idx != -1:
        return str1[:idx] + str1[idx+len(str2):]
    return str1


# --- Next Function Block ---


def sum_of_triangle_row_mins(triangle: list) -> int:
    """
    Given a triangle (list of lists), returns the sum of the minimum value in each row.
    """
    total = 0
    for row in triangle:
        total += min(row)
    return total


# --- Next Function Block ---


def remove_digit_and_record_indices(number: str, digit: str) -> (str, list):
    """
    Removes occurrences of digit from number and records the indices (of digit in original).
    Returns a tuple of (modified string, list of indices where digit was found).
    """
    indices = []
    result = ""
    for idx, ch in enumerate(number):
        if ch == digit:
            indices.append(idx)
        else:
            result += ch
    return result, indices


# --- Next Function Block ---


def check_frequency_uniqueness(arr: list) -> bool:
    """
    Returns True if the sorted list of frequencies of elements equals the sorted unique frequencies.
    (Based on the provided snippet.)
    """
    freq = {}
    for num in arr:
        freq[num] = freq.get(num, 0) + 1
    freq_vals = sorted(freq.values())
    unique_vals = sorted(set(freq_vals))
    return freq_vals == unique_vals


# --- Next Function Block ---


def sum_of_divisible_elements(n: int) -> int:
    """
    For n = 7 (example), sums numbers from 1 to n and returns the difference between sum of numbers
    not divisible by a given condition and those that are divisible.
    (Based on the snippet where numbers divisible by m are summed separately.)
    This version uses m = 3 as in the snippet.
    """
    sum_non = 0
    sum_div = 0
    for i in range(1, n + 1):
        if i % 3 == 0:
            sum_div += i
        else:
            sum_non += i
    return sum_non - sum_div


# --- Next Function Block ---


def first_duplicate_in_list(nums: list):
    """
    Returns the first duplicate element in nums. If none found, returns None.
    """
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None


# --- Next Function Block ---


def rotate_array_right(nums: list, k: int) -> list:
    """
    Rotates the list nums to the right by k positions.
    """
    n = len(nums)
    k %= n
    return nums[-k:] + nums[:-k]


# --- Next Function Block ---


def sum_of_subarrays_with_odd_length(arr: list) -> int:
    """
    Sums all subarrays of arr that have an odd length.
    """
    total = 0
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            if (j - i + 1) % 2 == 1:
                total += sum(arr[i:j+1])
    return total


# --- Next Function Block ---


def reformat_ip(address: str) -> str:
    """
    Reformats an IP address by inserting "[.]" between segments.
    Example: "1.1.1.1" -> "1[.]1[.]1[.]1"
    """
    parts = address.split(".")
    return "[.]".join(parts)


# --- Next Function Block ---


def count_jewels_in_stones(jewels: str, stones: str) -> int:
    """
    Returns the count of characters in stones that are in jewels.
    """
    count = 0
    for ch in stones:
        if ch in jewels:
            count += 1
    return count


# --- Next Function Block ---


def interpret_command(command: str) -> str:
    """
    Interprets the command string:
      - "G" remains "G"
      - "()" is replaced by "o"
      - "(al)" is replaced by "al"
    Example: "G()(al)" -> "Goal"
    """
    i = 0
    result = ""
    while i < len(command):
        if command[i] == "G":
            result += "G"
            i += 1
        elif command[i:i+2] == "()":
            result += "o"
            i += 2
        elif command[i:i+4] == "(al)":
            result += "al"
            i += 4
        else:
            i += 1
    return result


# --- Next Function Block ---


def excel_columns(n: int) -> list:
    """
    Returns a list of the first n Excel column labels starting from 'A'.
    """
    return [chr(ord('A') + i) for i in range(n)]


# --- Next Function Block ---


def reformat_text(text: str) -> str:
    """
    Trims extra spaces and redistributes spaces evenly between words.
    (Simple approach: assumes extra spaces are those beyond single spaces.)
    """
    words = text.strip().split()
    return " ".join(words)


# --- Next Function Block ---



# 1. Given a number, sort its digits and compute the sum of the integer
#    formed by concatenating the smallest and largest digit with the remaining two in order.
def sorted_digits_sum(num: int) -> int:
    """
    Converts num to its digit list, sorts the digits, then returns:
      int(sorted[0] + sorted[3]) + int(sorted[1] + sorted[2])
    Example: 2932 -> digits sorted = ['2','2','3','9'] → int('2'+'9') + int('2'+'3') = 29 + 23 = 52.
    """
    s = str(num)
    arr = list(s)
    arr.sort()
    # Concatenate first and last digit; then second and third.
    return int(arr[0] + arr[3]) + int(arr[1] + arr[2])


# --- Next Function Block ---



# 2. Alternating digit sum: add digits at even indices, subtract at odd.
def alternating_digit_sum(n: int) -> int:
    """
    Converts n to a string and alternately adds and subtracts digits.
    Example: 111 -> (1 - 1 + 1) = 1.
    """
    s = str(n)
    total = 0
    for i in range(len(s)):
        if i % 2 == 0:
            total += int(s[i])
        else:
            total -= int(s[i])
    return total


# --- Next Function Block ---



# 3. Extract all digits from a list of numbers.
def extract_digits(nums: list) -> list:
    """
    For each number in nums, extracts its digits and returns a flat list of all digits.
    Example: [13,25] -> [1, 3, 2, 5]
    """
    result = []
    for num in nums:
        for ch in str(num):
            result.append(int(ch))
    return result


# --- Next Function Block ---



# 4. Count numbers (1 to num) whose digit sum is even.
def count_even_digit_sum(num: int) -> int:
    """
    For every number from 1 to num, computes the sum of digits (printing each sum),
    and counts how many have an even digit sum.
    """
    count = 0
    for i in range(1, num + 1):
        s = str(i)
        digit_sum = sum(int(ch) for ch in s)
        # Uncomment the next line to print each sum:
        # print(digit_sum)
        if digit_sum % 2 == 0:
            count += 1
    return count


# --- Next Function Block ---



# 5. Letter-sum transformation.
def letter_sum_transformation(s: str, k: int) -> int:
    """
    Maps each letter in s to a number (a->1, b->2, ..., z->26) by concatenation.
    Then, for k iterations, sums all digits of the resulting string and reassigns.
    Finally, returns the final integer.
    Example: s="iiii", k=2.
    """
    mapping = {
        "a": "1", "b": "2", "c": "3", "d": "4", "e": "5",
        "f": "6", "g": "7", "h": "8", "i": "9", "j": "10",
        "k": "11", "l": "12", "m": "13", "n": "14", "o": "15",
        "p": "16", "q": "17", "r": "18", "s": "19", "t": "20",
        "u": "21", "v": "22", "w": "23", "x": "24", "y": "25", "z": "26"
    }
    res = ""
    for ch in s:
        res += mapping[ch]
    for _ in range(k):
        ssum = sum(int(ch) for ch in res)
        res = str(ssum)
    return int(res)


# --- Next Function Block ---



# 6. For a list of strings, for each pair compute a boolean array indicating for each letter in the first
#    string whether it is absent in the second; then find the maximum length of such an array that contains True.
def common_prefix_discrepancy(strs: list) -> (int, list):
    """
    For each pair (i, j) (i < j) in strs, builds an array with True where a character of strs[i]
    is not in strs[j], False otherwise. Then returns the maximum length among those arrays
    that contain at least one True, along with the list of arrays.
    (The logic is based on the provided snippet and may be interpreted.)
    """
    arrays = []
    max_len = -1
    for i in range(len(strs) - 1):
        for j in range(i + 1, len(strs)):
            arr = []
            for ch in strs[i]:
                if ch in strs[j]:
                    arr.append(False)
                else:
                    arr.append(True)
            arrays.append(arr)
            if True in arr and len(arr) > max_len:
                max_len = len(arr)
    return max_len, arrays


# --- Next Function Block ---



# 7. Compute a cost using total, cost1 and cost2.
def compute_cost(total: int, cost1: int, cost2: int) -> int:
    """
    Given total money and two costs, ensures cost1 is smaller than cost2,
    then simulates a purchase process and returns a computed value.
    (Logic is based on the provided snippet.)
    """
    if cost2 > cost1:
        # Swap cost1 and cost2 if needed.
        cost1, cost2 = cost2, cost1
    prd = 0
    for i in range(total // cost1):
        ttl = total - cost1 * i
        count = 1
        while ttl > 0:
            count += 1
            ttl -= cost2
        if ttl == 0:
            prd += count
    return prd + 1


# --- Next Function Block ---



# 8. Decode a string of the form "a1c1e1" into letters by shifting the previous letter.
def decode_string(s: str) -> str:
    """
    For each character in s, if it's a letter, output it.
    If it's a digit, take the previous letter's index in the alphabet and shift by that digit.
    Example: "a1c1e1" becomes "abcdef" (depending on dictionary).
    """
    alpha = "abcdefghijklmnopqrstuvwxyz"
    res = ""
    for i in range(len(s)):
        if s[i].isalpha():
            res += s[i]
        else:
            # s[i] is digit; shift previous letter.
            prev = s[i-1]
            ind = alpha.index(prev) + int(s[i])
            res += alpha[ind % 26]
    return res


# --- Next Function Block ---



# 9. Find the first index of target in nums, starting at index start.
def find_index(nums: list, target: int, start: int) -> int:
    """
    Returns the first index of target in nums, starting from start.
    If not found, returns -1.
    """
    for i in range(start, len(nums)):
        if nums[i] == target:
            return i
    return -1


# --- Next Function Block ---



# 10. Return substring of a numeric string up to and including the last odd digit (scanning from right).
def last_odd_substring(num: str) -> str:
    """
    Returns the substring of num up to (and including) the last odd digit when scanning from right.
    """
    for i in reversed(range(len(num))):
        if int(num[i]) % 2 == 1:
            return num[:i+1]
    return ""


# --- Next Function Block ---



# 11. Return the maximum digit that appears at least 3 times in num, repeated three times.
def triple_max_frequent_digit(num: str) -> str:
    """
    Finds all digits that appear at least 3 times in num.
    Returns the maximum such digit repeated three times.
    """
    freq = {}
    candidates = []
    for ch in num:
        freq[ch] = freq.get(ch, 0) + 1
        if freq[ch] >= 3 and int(ch) not in candidates:
            candidates.append(int(ch))
    if candidates:
        return str(max(candidates)) * 3
    return ""


# --- Next Function Block ---



# 12. Alternate approach: Check for each digit if its triple exists in num and choose the maximum.
def triple_max_digit_condition(num: str) -> str:
    """
    Checks each digit in num; if digit repeated three times is a substring,
    and the digit is larger than the current candidate, update candidate.
    Returns the candidate digit repeated three times.
    """
    grt = -1
    for ch in num:
        if (ch * 3) in num and int(ch) > grt:
            grt = int(ch)
    return str(grt) * 3 if grt > -1 else ""


# --- Next Function Block ---



# 13. Count keys in a dictionary.
def dict_key_count(d: dict) -> int:
    """
    Returns the number of keys in dictionary d.
    """
    return len(d)


# --- Next Function Block ---



# 14. Check if both left and right values appear in any of the given ranges.
def check_range(ranges: list, left: int, right: int) -> bool:
    """
    Checks if left and right exist in any range (list of two numbers) from ranges.
    Returns True if both found; otherwise False.
    """
    isLeft = False
    isRight = False
    for r in ranges:
        if left in r or isLeft:
            isLeft = True
            if right in r:
                isRight = True
    return isLeft and isRight


# --- Next Function Block ---



# 15. Simulate a lock. Given a starting lock (e.g. ["0","0","0","0"]) and a target lock as a string,
#     increment digits until lock equals target; count the moves.
def open_lock(target: str) -> (list, int):
    """
    Starting from ["0", "0", "0", "0"], increments individual digits (left-to-right)
    until the lock matches target. Returns the final lock state (as a list of strings) and the move count.
    """
    lock = ["0", "0", "0", "0"]
    target_list = list(target)
    count = 0
    i = 0
    while lock != target_list and i < len(lock):
        if lock[i] != target_list[i]:
            # Increment digit by 1 (as string)
            lock[i] = str(int(lock[i]) + 1)
            count += 1
        else:
            i += 1
    return lock, count


# --- Next Function Block ---



# 16. Count Pythagorean triplets (brute force) for numbers 1 to num.
def count_pythagorean_triplets(num: int) -> int:
    """
    Counts the number of Pythagorean triplets (idx, jdx, kdx) with 1 <= idx, jdx, kdx <= num.
    """
    count = 0
    for a in range(1, num+1):
        for b in range(1, num+1):
            if a == b:
                continue
            for c in range(max(a, b) + 1, num+1):
                if a * a + b * b == c * c:
                    count += 1
                    # Uncomment to print the triplet:
                    # print(a, b, c)
    return count


# --- Next Function Block ---



# 17. Count Pythagorean triplets (variant with three loops, skipping i == j).
def count_pythagorean_triplets_variant(num: int) -> int:
    """
    Another variant to count Pythagorean triplets using three nested loops.
    """
    count = 0
    for k in range(1, num+1):
        for i in range(1, k):
            for j in range(1, k):
                if i == j:
                    continue
                if i * i + j * j == k * k:
                    count += 1
    return count


# --- Next Function Block ---



# 18. Count numbers that have at least one non-identical partner.
def count_non_identical_partners(nums: list) -> int:
    """
    For each pair of distinct numbers in nums, collects the unique numbers that appear in such pairs.
    Returns the count of unique numbers that appear in a pair with a different number.
    """
    arr = []
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            if nums[i] != nums[j]:
                if nums[i] not in arr:
                    arr.append(nums[i])
                if nums[j] not in arr:
                    arr.append(nums[j])
    return len(arr)


# --- Next Function Block ---



# 19. Check if all characters in a string have the same frequency.
def all_equal_frequency(s: str) -> bool:
    """
    Returns True if every character in s occurs the same number of times; otherwise False.
    """
    freq = {ch: s.count(ch) for ch in s}
    first = next(iter(freq.values()))
    for count in freq.values():
        if count != first:
            return False
    return True


# --- Next Function Block ---



# 20. Count word frequencies in a sentence.
def count_word_frequencies(text: str) -> dict:
    """
    Returns a dictionary with word frequencies from text.
    """
    words = text.split()
    freq = {}
    for word in words:
        freq[word] = freq.get(word, 0) + 1
    return freq


# --- Next Function Block ---



# 21. Compute differences in groups: for sorted nums in descending order,
#     for each index i (up to len(nums)-k), for j in i+1 to i+1+k, record the difference.
def differences_in_groups(nums: list, k: int) -> list:
    """
    Sorts nums in reverse order and, for each index i up to len(nums)-k, computes differences with the next k numbers.
    Returns the list of differences.
    """
    result = []
    nums.sort(reverse=True)
    for i in range(len(nums) - k):
        for j in range(i+1, i+1+k):
            result.append(nums[i] - nums[j])
    return result


# --- Next Function Block ---



# 22. Reverse substring up to a given character.
def reverse_up_to_char(word: str, ch: str) -> str:
    """
    Finds the first occurrence of ch in word, reverses the substring up to and including that character,
    then concatenates the remainder.
    """
    ind = word.index(ch)
    return word[:ind+1][::-1] + word[ind+1:]


# --- Next Function Block ---



# 23. Compute maximum differences for each element:
def max_differences(nums: list) -> list:
    """
    For each index in nums, computes the maximum difference (nums[j]-nums[i]) for j > i.
    Returns a list with -1 as the first element and the maximum differences for subsequent indices.
    """
    result = [-1]
    for i in range(len(nums)-1):
        diffs = []
        for j in range(i+1, len(nums)):
            if nums[j] > nums[i]:
                diffs.append(nums[j] - nums[i])
        if diffs:
            result.append(max(diffs))
    return result


# --- Next Function Block ---



# 24. Find maximum gap (j - i) such that colors[i] != colors[j].
def max_index_gap_different(colors: list) -> int:
    """
    Returns the maximum index gap between two elements in colors that are different.
    """
    max_gap = -1
    n = len(colors)
    for i in range(n-1):
        for j in range(i+1, n):
            if colors[i] != colors[j] and (j - i) > max_gap:
                max_gap = j - i
    return max_gap


# --- Next Function Block ---



# 25. Shifting letters: using shifts list to transform s.
def shifting_letters(s: str, shifts: list) -> str:
    """
    For each index i in s, sums shifts from i to end, adds the index of s[i] in the alphabet,
    takes modulo 26, and returns the corresponding letter. Builds the final string.
    """
    alphabet = [chr(i) for i in range(ord('a'), ord('z')+1)]
    res = ""
    for i in range(len(s)):
        total = sum(shifts[i:]) + alphabet.index(s[i])
        total %= 26
        res += alphabet[total]
    return res


# --- Next Function Block ---



# 26. Reshape a 1D list into an m x n matrix.
def reshape_matrix(original: list, m: int, n: int) -> list:
    """
    Reshapes the list 'original' into a matrix with m rows and n columns.
    Assumes len(original) == m * n.
    """
    matrix = []
    k = 0
    for i in range(m):
        row = []
        for j in range(n):
            row.append(original[k])
            k += 1
        matrix.append(row)
    return matrix


# --- Next Function Block ---



# 27. Merge two lists of pairs (ambiguous logic from snippet).
def merge_pair_lists(nums1: list, nums2: list) -> list:
    """
    Given two lists of pairs, for each corresponding pair, if their first elements are equal,
    add their second elements; otherwise, collect the pair from the second list.
    Then, insert these collected pairs into the longer list based on the first element.
    (Logic is ambiguous; this is one interpretation.)
    """
    longest = nums1 if len(nums1) >= len(nums2) else nums2
    shortest = nums2 if longest is nums1 else nums1
    extra = []
    for i in range(len(shortest)):
        pair_long = longest[i]
        pair_short = shortest[i]
        if pair_long[0] == pair_short[0]:
            pair_long[1] += pair_short[1]
        else:
            extra.append(pair_short)
    # Insert extra pairs into longest based on first element (index = first element - 1)
    for pair in extra:
        ind = pair[0] - 1
        longest.insert(ind, pair)
    return longest


# --- Next Function Block ---



# 28. Print every 5th element’s first two numbers from an array.
def print_every_fifth(arr: list) -> None:
    """
    Iterates over arr with a step of 5 and prints arr[i] and arr[i+1] if available.
    """
    for i in range(0, len(arr), 5):
        if i + 1 < len(arr):
            print(arr[i])
            print(arr[i+1])


# --- Next Function Block ---



# 29. Intersection among three lists.
def intersect_three_lists(nums1: list, nums2: list, nums3: list) -> list:
    """
    Returns the list of unique elements that appear in at least two of the three lists.
    """
    set1 = set(nums1)
    set2 = set(nums2)
    set3 = set(nums3)
    # Intersection among any two:
    inter = (set1 & set2) | (set1 & set3) | (set2 & set3)
    return list(inter)


# --- Next Function Block ---



# 30. Check if all characters in a string occur with equal frequency.
def all_equal_frequency(s: str) -> bool:
    """
    Returns True if all characters in s have the same frequency; otherwise False.
    """
    freq = {ch: s.count(ch) for ch in s}
    return len(set(freq.values())) == 1


# --- Next Function Block ---



# 31. Count word frequencies.
def word_frequencies(text: str) -> dict:
    """
    Splits text by spaces and returns a dictionary of word frequencies.
    """
    words = text.split()
    freq = {}
    for word in words:
        freq[word] = freq.get(word, 0) + 1
    return freq


# --- Next Function Block ---




def most_frequent_prefix(strs: list) -> str:
    """
    Attempts to compute the prefix of the first string that appears most frequently among the strings.
    (The logic is ambiguous; here we simply return the longest common prefix.)
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix


# --- Next Function Block ---



# 74. Find all common prefixes from the first string that appear in every string.
def all_common_prefixes(strs: list) -> list:
    """
    Returns a list of all prefixes of the first string that are common to all strings in the list.
    """
    if not strs:
        return []
    common = []
    base = strs[0]
    for i in range(1, len(base) + 1):
        prefix = base[:i]
        if all(s.startswith(prefix) for s in strs):
            common.append(prefix)
    return common


# --- Next Function Block ---



# 75. For each number in nums, compute the sum of absolute differences with all numbers.
def sum_abs_differences(nums: list) -> list:
    """
    Returns a list where for each element in nums, the value is the sum of absolute differences
    between that element and every element in nums.
    """
    result = []
    for i in nums:
        total = sum(abs(i - j) for j in nums)
        result.append(total)
    return result


# --- Next Function Block ---




# patterns.py

# 1. Compute an arithmetic expression: num + t*2
def add_and_multiply(num: int, t: int) -> int:
    return num + t * 2


# --- Next Function Block ---



# 2. (Placeholder) Process a string and remove paired characters.
# NOTE: The original code was ambiguous. This version simply returns a list of characters.
def process_string(s: str) -> list:
    arr = list(s)
    # If s length is odd, return False (or an empty list)
    if len(s) % 2 == 1:
        return []
    # The original logic attempted removals based on a dictionary,
    # but since it was unclear, we return the sorted list as a placeholder.
    return sorted(arr)


# --- Next Function Block ---



# 3. Validate parentheses using a stack (an alternative to the given complex snippet)
def validate_parentheses(s: str) -> bool:
    mapping = {"(": ")", "[": "]", "{": "}"}
    stack = []
    for char in s:
        if char in mapping:
            stack.append(mapping[char])
        else:
            if not stack or char != stack.pop():
                return False
    return not stack


# --- Next Function Block ---



# 4. Reverse a number's string representation.
def reverse_number(num: int) -> str:
    return str(num)[::-1]


# --- Next Function Block ---



# 5. Simulate stack operations to build an array.
def simulate_stack_ops(n: int, target: list) -> list:
    """
    Simulates "Push" and "Pop" operations to build an array from 1 to n until the array equals target.
    (This logic is taken from the snippet; note that with target == [] the loop never runs.)
    """
    res = []
    arr = []
    i = 1
    k = 0
    while i <= n and arr != target:
        arr.append(i)
        res.append("Push")
        if target and arr[k] != target[k]:
            arr.pop()
            res.append("Pop")
        else:
            k += 1
        i += 1
    return res


# --- Next Function Block ---



# 6. Find a special value in an array based on frequency (ambiguous snippet)
def find_special_value(arr: list, k: int) -> int:
    """
    Iterates over the array and tracks a "great" value based on adjacent comparisons
    and frequency counting. (The original snippet logic is unclear; this is one interpretation.)
    """
    d = {}
    i = 1
    count = 0
    # Use k to decide a target count (if k>1, j starts at 2; else 1)
    j_target = 2 if k > 1 else 1
    while count != j_target and i < len(arr):
        great = arr[i] if arr[i] > arr[i - 1] else arr[i - 1]
        d[great] = d.get(great, 0) + 1
        count = d[great]
        i += 1
    return great


# --- Next Function Block ---



def remaining_chars_after_subtraction(s: str, t: str) -> str:
    """
    Given two strings s and t, reduce the frequency of characters in t based on s and then 
    return a concatenation of characters that remain (i.e. frequency > 0).
    """
    freq = Counter(t)
    for ch in s:
        freq[ch] -= 1
    res = ""
    for ch in freq:
        if freq[ch] > 0:
            res += ch
    return res


# --- Next Function Block ---



# 8. Find the 1-indexed position of the first word in a sentence containing searchWord.
def find_word_index(sentence: str, searchWord: str) -> int:
    words = sentence.split()
    for idx, word in enumerate(words, start=1):
        if searchWord in word:
            return idx
    return -1


# --- Next Function Block ---



# 9. Count how many words in a list are prefixes of a given string.
def count_prefix_matches(words: list, s: str) -> int:
    count = 0
    for word in words:
        if s.startswith(word):
            count += 1
    return count


# --- Next Function Block ---



# 10. Check if concatenating words in order equals a target string.
def check_concatenation(words: list, target: str) -> bool:
    res = ""
    for word in words:
        res += word
        if len(res) >= len(target):
            break
    return res == target


# --- Next Function Block ---



# 11. Find the first missing positive integer from a list.
def first_missing_positive(nums: list) -> int:
    nums_set = set(nums)
    i = 1
    while True:
        if i not in nums_set:
            return i
        i += 1


# --- Next Function Block ---



# 12. Brute-force approach for longest palindromic substring.
def longest_palindromic_substring(s: str) -> str:
    out = ""
    for i in range(len(s)):
        res = ""
        for j in range(i, len(s)):
            res += s[j]
            if res == res[::-1] and len(res) > len(out):
                out = res
    return out


# --- Next Function Block ---



# 13. Split string into chunks of length k; pad the last chunk with fill if necessary.
def split_and_pad(s: str, k: int, fill: str = "x") -> list:
    arr = []
    res = ""
    for ch in s:
        if len(res) >= k:
            arr.append(res)
            res = ch
        else:
            res += ch
    if len(res) < k:
        res += fill * (k - len(res))
    arr.append(res)
    return arr


# --- Next Function Block ---



# 14. Find intervals of repeating characters (length >= threshold).
def find_repeating_intervals(s: str, threshold: int = 3) -> list:
    intervals = []
    i = 0
    while i < len(s):
        count = 0
        j = i
        while j < len(s) and s[i] == s[j]:
            count += 1
            j += 1
        if count >= threshold:
            intervals.append([i, j - 1])
        i = j
    return intervals


# --- Next Function Block ---



# 15. Get length of a specific line from a list.
def line_length(lines: list, index: int) -> int:
    if index < len(lines):
        return len(lines[index])
    return 0


# --- Next Function Block ---



# 16. Check if two strings have the same character frequencies.
def same_frequency(s: str, t: str) -> bool:
    return Counter(s) == Counter(t)


# --- Next Function Block ---



# 17. Check if there exists a duplicate element within distance k.
def contains_nearby_duplicate(nums: list, k: int) -> bool:
    for i in range(len(nums) - 1):
        for j in range(i + 1, len(nums)):
            if nums[i] == nums[j] and abs(i - j) <= k:
                return True
    return False


# --- Next Function Block ---



# 18. Simplify Unix path.
def simplify_path(path: str) -> str:
    # A simple implementation using a stack.
    parts = path.split('/')
    stack = []
    for part in parts:
        if part == '' or part == '.':
            continue
        elif part == '..':
            if stack:
                stack.pop()
        else:
            stack.append(part)
    return "/" + "/".join(stack)


# --- Next Function Block ---



# 19. Reverse result on encountering a specific character.
def reverse_on_char(s: str, char: str = "i") -> str:
    res = ""
    for ch in s:
        if ch == char:
            res = res[::-1]
        else:
            res += ch
    return res


# --- Next Function Block ---



# 20. Reverse alphabetical characters while keeping non-alphabetic in place.
def reverse_alpha_keep_nonalpha(s: str) -> str:
    alphabets = [ch for ch in s if ch.isalpha()]
    alphabets.reverse()
    res = list(s)
    for idx, ch in enumerate(s):
        if ch.isalpha():
            res[idx] = alphabets.pop(0)
    return "".join(res)


# --- Next Function Block ---



# 21. Split words by a separator and collect non-empty segments.
def split_words_by_separator(words: list, separator: str) -> list:
    result = []
    for word in words:
        segments = word.split(separator)
        for seg in segments:
            if seg:
                result.append(seg)
    return result


# --- Next Function Block ---



# 22. Transform string groups: reverse the first k characters of each group then append the rest.
def transform_string_groups(s: str, k: int) -> str:
    count = 0
    res = ""
    out = ""
    for ch in s:
        res += ch
        count += 1
        if count == k:
            out += res[::-1]
            res = ""
            count = 0
    out += res
    return out


# --- Next Function Block ---



# 23. Sum squares of numbers in list if list length divides index+1.
def sum_condition_square(nums: list) -> int:
    total = 0
    for i in range(len(nums)):
        if len(nums) % (i + 1) == 0:
            total += nums[i] * nums[i]
    return total


# --- Next Function Block ---



# 24. Custom sort of string digits: sort characters, then build string in reversed order for all but last.
def custom_sort_string(s: str) -> str:
    arr = list(s)
    arr.sort()
    res = ""
    for i in reversed(range(len(arr) - 1)):
        res += arr[i]
    res += arr[-1]
    return res


# --- Next Function Block ---



# 25. Check if any pair (i, j) satisfies i^2 + j^2 == c.
def check_sum_of_squares(c: int) -> bool:
    for i in range(0, c + 1):
        for j in range(1, c + 1):
            if i * i + j * j == c:
                return True
    return False


# --- Next Function Block ---



# 26. Sum of absolute differences for each element in nums.
def sum_abs_differences(nums: list) -> list:
    result = []
    for i in nums:
        total = sum(abs(i - j) for j in nums)
        result.append(total)
    return result


# --- Next Function Block ---





# 1. Return indices of words that contain a given substring.
def indices_of_substring_in_words(words, x):
    """
    Returns a list of indices for which the string x is a substring of each word.
    Example:
      words = ["leet", "code"], x = "e"  → returns [0]
    """
    result = []
    for i in range(len(words)):
        if x in words[i]:
            result.append(i)
    return result


# --- Next Function Block ---



# 2. Alternate elements from the sorted list.
def alternate_sorted_elements(nums):
    """
    Given a list of numbers, sorts them and then builds a new list by alternating
    between taking an element from the beginning and from the end.
    """
    nums.sort()
    result = []
    i = 0
    flag = True
    while len(result) < len(nums):
        if flag:
            result.append(nums[i])
        else:
            result.append(nums[-i])
        flag = not flag
        i += 1
    return result


# --- Next Function Block ---



# 3. Sum consecutive numbers starting from max(nums) over k terms.
def sum_from_max(nums, k):
    """
    Returns the sum of k consecutive integers starting from max(nums).
    """
    start = max(nums)
    total = 0
    for i in range(start, start + k):
        total += i
    return total


# --- Next Function Block ---



# 4. Count ones in binary representation of a number.
def count_ones_in_binary(n):
    """
    Returns the count of '1's in the binary representation of n.
    """
    b = bin(n)
    counts = Counter(b)
    return counts['1'] if '1' in counts else 0


# --- Next Function Block ---



# 5. Add two binary strings.
def binary_sum(a, b):
    """
    Returns the binary string representing the sum of binary strings a and b.
    """
    total = int(a, 2) + int(b, 2)
    return bin(total)


# --- Next Function Block ---



# 6. Add an integer k to a list of digits and return the result as a list.
def add_to_digit_list(digits, k):
    """
    Given a list of digits (e.g. [1,2,0,0]) and an integer k,
    forms the number, adds k, and returns the new number as a list of digits.
    """
    num_str = "".join(str(d) for d in digits)
    new_num = int(num_str) + k
    return [int(ch) for ch in str(new_num)]


# --- Next Function Block ---



# 7. Make a palindrome by mirroring the lower of symmetric digits.
def make_palindrome(s):
    """
    Given a string s, for each pair of symmetric characters, change both to the lesser character.
    Example: "egcfe" → "egcge"
    """
    arr = list(s)
    n = len(arr)
    for i in range(n // 2):
        j = n - i - 1
        if arr[i] != arr[j]:
            # Choose the lexicographically smaller character.
            if arr[i] < arr[j]:
                arr[j] = arr[i]
            else:
                arr[i] = arr[j]
    return "".join(arr)


# --- Next Function Block ---



# 8. Remove occurrences of "AB" or "CD" repeatedly and return final length.
def reduce_string(s):
    """
    Repeatedly removes occurrences of "AB" or "CD" from s until neither exists.
    Returns the length of the resulting string.
    """
    while "AB" in s or "CD" in s:
        res = ""
        i = 0
        while i < len(s):
            # Check for "AB" or "CD" pair.
            if i < len(s) - 1 and (s[i] == "A" and s[i+1] == "B" or s[i] == "C" and s[i+1] == "D"):
                i += 2  # skip these two characters
            else:
                res += s[i]
                i += 1
        s = res
    return len(s)


# --- Next Function Block ---



# 9. Process two strings with backspace (#) operations.
def process_backspaces(s, t):
    """
    Processes strings s and t such that every '#' represents a backspace.
    Returns the final processed strings as a tuple.
    """
    def process(s):
        res = []
        for ch in s:
            if ch == "#":
                if res:
                    res.pop()
            else:
                res.append(ch)
        return "".join(res)
    return process(s), process(t)


# --- Next Function Block ---



# 10. Copy a list using comprehension.
def copy_list(arr):
    """
    Returns a copy of the list arr.
    """
    return [x for x in arr]


# --- Next Function Block ---



# 11. Create a dictionary mapping each element in arr to itself.
def map_to_self(arr):
    """
    Returns a dictionary mapping each element in arr to itself.
    """
    return {k: k for k in arr}


# --- Next Function Block ---



# 12. Return sorted dictionary of alphabets to numbers.
def sorted_alphabet_ord():
    """
    Returns a dictionary of uppercase alphabets mapped to numbers (A:1, B:2, ...),
    sorted by their numerical values.
    """
    mapping = {'H': 8, 'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5, 'F': 6, 'G': 7,
               'I': 9, 'J': 10, 'K': 11, 'L': 12, 'M': 13, 'N': 14, 'O': 15,
               'P': 16, 'Q': 17, 'R': 18, 'S': 19, 'T': 20, 'U': 21, 'V': 22,
               'W': 23, 'X': 24, 'Y': 25, 'Z': 26}
    return dict(sorted(mapping.items(), key=lambda item: item[1]))


# --- Next Function Block ---



# 13. Return list of dictionary values.
def dict_values_list(d):
    """
    Given dictionary d, returns a list of its values.
    """
    return [d[x] for x in d]


# --- Next Function Block ---



# 14. Iterate through a list using an iterator.
def iterate_list(arr):
    """
    Iterates through arr using an iterator and returns a list of items.
    """
    it = iter(arr)
    result = []
    for _ in range(len(arr)):
        result.append(next(it))
    return result


# --- Next Function Block ---



# 15. Sum a list using functools.reduce.
def reduce_sum(arr):
    """
    Returns the sum of elements in arr using reduce.
    """
    return functools.reduce(lambda x, y: x + y, arr)


# --- Next Function Block ---



# 16. Decorator that prints a message before a function.
def hey_decorator(func):
    """
    A decorator that prints 'hey' before calling the function.
    """
    def wrapper(*args, **kwargs):
        print("hey")
        return func(*args, **kwargs)
    return wrapper


# --- Next Function Block ---


@hey_decorator
def hello():
    """
    Example function to be decorated.
    """
    print("hello")


# --- Next Function Block ---



# 17. Sort a list in reverse and extend it.
def sort_and_extend(arr, extension):
    """
    Sorts arr in reverse, extends it with extension, and returns the new list.
    """
    arr.sort(reverse=True)
    arr.extend(extension)
    return arr


# --- Next Function Block ---


def binary_of_number(n):
    """
    Returns the binary representation of n.
    """
    return bin(n)


# --- Next Function Block ---



# 18. Test abstract class behavior.
from abc import ABC, abstractmethod
class Main(ABC):
    @abstractmethod
    def sum(self):
        pass

class Sum(Main):
    @staticmethod
    def sum(length, width):
        print(length + width)

def test_sum_class():
    """
    Calls the Sum.sum method.
    """
    Sum.sum(1, 2)


# --- Next Function Block ---



# 19. Generator that yields the square of a number.
def generator_square(x):
    yield x * x


# --- Next Function Block ---


def print_squares(arr):
    """
    For each element in arr, prints its square using a generator.
    """
    for x in arr:
        for square in generator_square(x):
            print(square)


# --- Next Function Block ---



# 20. Use reduce to sum a list.
def reduce_sum_example(arr):
    return functools.reduce(lambda x, y: x + y, arr)


# --- Next Function Block ---



# 21. Check if string s is equal to a concatenation of a's followed by b's.
def check_ordered_chars(s):
    """
    Returns True if s equals all its 'a's followed by all its 'b's.
    """
    a_part = "a" * s.count("a")
    b_part = "b" * s.count("b")
    return s == a_part + b_part


# --- Next Function Block ---



# 22. Extract sorted numbers from a sentence.
def extract_sorted_numbers(s):
    """
    Extracts integers from the string s and returns them sorted.
    """
    numbers = []
    for token in s.split():
        try:
            numbers.append(int(token))
        except ValueError:
            continue
    return sorted(set(numbers))


# --- Next Function Block ---



# 23. Reverse each word in a sentence, sort the reversed words, and reconstruct a new string.
def sort_by_reversed_words(s):
    """
    Given a string with words that contain numbers, reverse each word,
    sort the reversed words, then reverse them back and drop the last character.
    (This implementation is one interpretation of the snippet.)
    """
    words = s.split()
    reversed_words = [word[::-1] for word in words]
    reversed_words.sort()
    result = []
    for word in reversed_words:
        # Remove the last character from each reversed word (except last, per snippet)
        result.append(word[::-1][:-1])
    return " ".join(result)


# --- Next Function Block ---



# 24. Compute product of a list.
def product_of_list(nums):
    product = 1
    for num in nums:
        product *= num
    return product


# --- Next Function Block ---



# 25. Check if a sentence contains all lowercase letters.
def contains_all_lowercase(sentence):
    """
    Returns True if sentence contains every letter in lowercase English alphabet.
    """
    for letter in string.ascii_lowercase:
        if letter not in sentence:
            return False
    return True


# --- Next Function Block ---



# 26. *********************
# Additional functions for many other snippets can be defined similarly.
# Due to the extensive number of snippets provided, only a representative sample is shown here.
#
# For example:
#
# - Converting a list of numbers to a target array.
# - Reversing a string.
# - Processing backspace characters in a string.
# - Calculating the sum of subarrays.
#
# You can follow the same pattern: create a function with a descriptive name,
# encapsulate the snippet's logic, and return or print the result.



# --- Snippet 1 ---
def indices_of_substring(words: list, x: str) -> list:
    """
    Returns a list of indices for which the string x is a substring of each word.
    Example:
      words = ["leet", "code"], x = "e" → [0]
    """
    result = []
    for i in range(len(words)):
        if x in words[i]:
            result.append(i)
    return result


# --- Next Function Block ---



# --- Snippet 2 ---
def alternate_sorted_elements(nums: list) -> list:
    """
    Sorts the list and then builds a new list by alternating between
    taking an element from the start and from the end.
    (Note: The original snippet logic is ambiguous; this is one interpretation.)
    """
    nums.sort()
    result = []
    i = 0
    flag = True
    while len(result) < len(nums):
        if flag:
            result.append(nums[i])
        else:
            result.append(nums[-i])
        flag = not flag
        i += 1
    return result


# --- Next Function Block ---



# --- Snippet 3 ---
def sum_from_max(nums: list, k: int) -> int:
    """
    Sums k consecutive integers starting from the maximum element in nums.
    """
    start = max(nums)
    total = 0
    for i in range(start, start + k):
        total += i
    return total


# --- Next Function Block ---



# --- Snippet 4 ---
def count_ones_in_binary(n: int) -> int:
    """
    Returns the count of '1's in the binary representation of n.
    """
    b = bin(n)
    counts = Counter(b)
    return counts['1'] if '1' in counts else 0


# --- Next Function Block ---



# --- Snippet 5 ---
def binary_sum(a: str, b: str) -> str:
    """
    Returns the binary string representing the sum of binary strings a and b.
    """
    total = int(a, 2) + int(b, 2)
    return bin(total)


# --- Next Function Block ---



# --- Snippet 6 ---
def add_to_digit_list(digits: list, k: int) -> list:
    """
    Given a list of digits (e.g. [1,2,0,0]) and an integer k,
    forms the number, adds k, and returns the result as a list of digits.
    """
    num_str = "".join(str(d) for d in digits)
    new_num = int(num_str) + k
    return [int(ch) for ch in str(new_num)]


# --- Next Function Block ---



# --- Snippet 7 ---
def make_palindrome_by_min(s: str) -> str:
    """
    For each pair of symmetric characters in s, change both to the lesser (lexicographically).
    Example: "egcfe" → "egcge"
    """
    arr = list(s)
    n = len(arr)
    for i in range(n // 2):
        j = n - 1 - i
        if arr[i] != arr[j]:
            if arr[i] < arr[j]:
                arr[j] = arr[i]
            else:
                arr[i] = arr[j]
    return "".join(arr)


# --- Next Function Block ---



# --- Snippet 8 ---
def process_prev_words(words: list) -> list:
    """
    Processes a list of words where the word "prev" indicates removal.
    For each occurrence of "prev", removes that element and (if possible) its previous element,
    then collects the removed values into a result list.
    Returns the collected list.
    (Logic based on provided snippet; behavior is ambiguous.)
    """
    result = []
    i = 0
    # Work on a copy to avoid index issues.
    words = words[:]  
    while i < len(words):
        if words[i] == "prev":
            if i > 0:
                result.append(int(words[i - 1]))
                del words[i - 1]
                i -= 1
            else:
                result.append(-1)
            del words[i]
            # Do not increment i since list has shrunk.
        else:
            try:
                words[i] = int(words[i])
            except ValueError:
                pass
            i += 1
    return result


# --- Next Function Block ---



# --- Snippet 9 ---
def max_ones_row(mat: list) -> tuple:
    """
    Given a binary matrix, returns a tuple (index, count) for the row with the most 1's.
    """
    max_count = -1
    index = -1
    for i, row in enumerate(mat):
        cnt = row.count(1)
        if cnt > max_count:
            max_count = cnt
            index = i
    return index, max_count


# --- Next Function Block ---



# --- Snippet 10 ---
def process_prev_words_variant(words: list) -> list:
    """
    A variant that, when encountering "prev", removes that word and
    if possible, removes and returns the integer of the previous element.
    Returns the collected list.
    """
    result = []
    i = 0
    words = words[:]  # copy
    while i < len(words):
        if words[i] == "prev":
            if i > 0:
                result.append(int(words[i - 1]))
                del words[i - 1]
                i -= 1
            else:
                result.append(-1)
            del words[i]
            i = max(i - 1, 0)
        else:
            try:
                words[i] = int(words[i])
            except ValueError:
                pass
            i += 1
    return result


# --- Next Function Block ---



# --- Snippet 11 ---
def calculate_remaining_amt(amt: int, purchaseAmount: int) -> int:
    """
    Given a total amt and a purchase amount, subtracts 10 times the integer division of purchaseAmount by 10,
    and if the remainder is at least 5, subtracts an additional 10.
    Returns the remaining amount.
    """
    val = purchaseAmount // 10
    dec = purchaseAmount % 10
    amt -= 10 * val
    if dec >= 5:
        amt -= 10
    return amt


# --- Next Function Block ---



# --- Snippet 12 ---
# (This snippet is ambiguous because it uses indices from the list values; skipping or revising.)
# We skip a function for the snippet with nested loops using nums and index lookup based on list values.


# --- Snippet 13 ---
def sort_by_height(names: list, heights: list) -> (list, list):
    """
    Sorts names and heights in descending order by height.
    Returns the sorted names and heights.
    """
    combined = list(zip(heights, names))
    combined.sort(reverse=True, key=lambda x: x[0])
    sorted_heights, sorted_names = zip(*combined)
    return list(sorted_names), list(sorted_heights)


# --- Next Function Block ---



# --- Snippet 14 ---
def sort_by_frequency(nums: list) -> list:
    """
    Returns a new list of numbers sorted by frequency (ascending) using the frequency dictionary,
    with each number repeated according to its frequency.
    """
    freq = Counter(nums)
    sorted_items = sorted(freq.items(), key=lambda x: x[1])
    result = []
    for num, count in sorted_items:
        result.extend([num] * count)
    return result


# --- Next Function Block ---



# --- Snippet 15 ---
def remove_duplicate_pairs(nums: list) -> (int, list):
    """
    Removes one pair of duplicates from the list each time it is found (modifying the list in-place)
    and counts the removals. Returns a tuple (count, remaining list).
    Note: This in-place removal logic is tricky and may be nonoptimal.
    """
    count = 0
    i = 0
    while i < len(nums) - 1:
        j = i + 1
        found = False
        while j < len(nums):
            if nums[i] == nums[j]:
                del nums[j]
                del nums[i]
                count += 1
                found = True
                break
            else:
                j += 1
        if not found:
            i += 1
    return count, nums


# --- Next Function Block ---



# --- Snippet 16 ---
def next_value_after_key(nums: list, key: int) -> int:
    """
    Iterates over nums; when an element equals key, collects the following element into a frequency dictionary.
    Returns the key from that dictionary with the highest frequency (or the only key if one exists).
    """
    freq = {}
    for i in range(len(nums) - 1):
        if nums[i] == key:
            next_val = nums[i + 1]
            freq[next_val] = freq.get(next_val, 0) + 1
    # Return the value with maximum frequency; if tied, the one encountered last in reversed sorted order.
    if freq:
        sorted_freq = dict(sorted(freq.items(), key=lambda item: item[1], reverse=True))
        return next(iter(sorted_freq))
    return None


# --- Next Function Block ---



# --- Snippet 17 ---
def sum_lengths_of_valid_words(words: list, chars: str) -> int:
    """
    For each word in words, if every character is in chars, adds its length to a sum.
    Returns the total sum.
    """
    total = 0
    for word in words:
        if all(ch in chars for ch in word):
            total += len(word)
    return total


# --- Next Function Block ---



# --- Snippet 18 ---
def max_full_substrings(s: str, target: str) -> int:
    """
    Given s and target, returns the maximum number of times target can be removed from s.
    Essentially, it finds how many complete copies of target exist in s based on character frequency.
    """
    freq_s = Counter(s)
    freq_target = Counter(target)
    counts = []
    for char in freq_target:
        if char not in freq_s:
            return 0
        counts.append(freq_s[char] // freq_target[char])
    return min(counts) if counts else 0


# --- Next Function Block ---



# --- Snippet 19 ---
def grid_distance(points: list) -> int:
    """
    Given a list of points (each a [x, y] list), computes the total steps required to move from
    one point to the next, moving one unit at a time (adjusting x and y separately) until reaching the next point.
    """
    total_steps = 0
    for i in range(len(points) - 1):
        current = points[i]
        target = points[i + 1]
        x, y = current
        while [x, y] != target:
            if x < target[0]:
                x += 1
            elif x > target[0]:
                x -= 1
            if y < target[1]:
                y += 1
            elif y > target[1]:
                y -= 1
            total_steps += 1
    return total_steps


# --- Next Function Block ---



# --- Snippet 20 ---
def compare_letters_to_target(letters: list, target: str) -> list:
    """
    Sorts letters and returns a list of booleans indicating if each letter is greater than target.
    """
    letters.sort()
    return [letter > target for letter in letters]


# --- Next Function Block ---



# --- Snippet 21 ---
def mapped_values(arr: list, func) -> list:
    """
    Returns the result of applying func to each element of arr using map.
    """
    return list(map(func, arr))


# --- Next Function Block ---



# --- Snippet 22 ---
def reverse_each_word(sentence: str) -> str:
    """
    Reverses each word in the sentence individually and returns the resulting sentence.
    """
    words = sentence.split()
    return " ".join(word[::-1] for word in words)


# --- Next Function Block ---



# --- Snippet 23 ---
def common_characters(words: list) -> list:
    """
    Returns a list of characters that are common to all strings in words, 
    repeated min frequency across all strings.
    (Standard approach: use intersection of Counters.)
    """
    if not words:
        return []
    common_counter = Counter(words[0])
    for word in words[1:]:
        common_counter &= Counter(word)
    # Expand the common characters according to their minimum frequency.
    result = []
    for ch, cnt in common_counter.items():
        result.extend([ch] * cnt)
    return result


# --- Next Function Block ---



# --- Snippet 24 ---
def contains_nearby_duplicate_k(nums: list, k: int) -> bool:
    """
    Returns True if there exists two distinct indices i and j such that nums[i] == nums[j] and abs(i - j) <= k.
    """
    for i in range(len(nums) - 1):
        for j in range(i + 1, len(nums)):
            if nums[i] == nums[j] and abs(i - j) <= k:
                return True
    return False


# --- Next Function Block ---





# 1. Multiset intersection: returns the intersection of two lists (each element appears min(count1, count2) times)
def multiset_intersection(nums1: list, nums2: list) -> list:
    c1 = Counter(nums1)
    c2 = Counter(nums2)
    result = []
    for x in c1:
        result.extend([x] * min(c1[x], c2.get(x, 0)))
    return result


# --- Next Function Block ---


# 2. Common elements in all rows of a matrix
def common_elements(matrix: list) -> list:
    if not matrix:
        return []
    result = []
    for x in matrix[0]:
        if all(x in row for row in matrix) and x not in result:
            result.append(x)
    return result


# --- Next Function Block ---


# 3. Remove all common elements from both lists
def remove_common_elements(nums1: list, nums2: list) -> (list, list):
    common = set(nums1) & set(nums2)
    for x in common:
        while x in nums1:
            nums1.remove(x)
        while x in nums2:
            nums2.remove(x)
    return nums1, nums2


# --- Next Function Block ---


# 4. Count peaks and valleys after removing consecutive duplicates
def count_peaks_valleys(nums: list) -> int:
    if not nums:
        return 0
    dedup = [nums[0]]
    for x in nums[1:]:
        if x != dedup[-1]:
            dedup.append(x)
    count = 0
    for i in range(1, len(dedup)-1):
        if dedup[i] > dedup[i-1] and dedup[i] > dedup[i+1]:
            count += 1
        elif dedup[i] < dedup[i-1] and dedup[i] < dedup[i+1]:
            count += 1
    return count


# --- Next Function Block ---


# 5. Return the minimal subset (from largest values) whose sum is greater than the sum of the rest
def min_subset_exceeding_rest(nums: list) -> list:
    nums.sort(reverse=True)
    total = sum(nums)
    subset_sum = 0
    k = 0
    while subset_sum <= total - subset_sum:
        subset_sum += nums[k]
        k += 1
    return nums[:k]


# --- Next Function Block ---


# 6. Total bottles problem: given numBottles and numExchange, return total bottles drank.
def total_bottles(numBottles: int, numExchange: int) -> int:
    total = numBottles
    bottles = numBottles
    while bottles >= numExchange:
        new = bottles // numExchange
        total += new
        bottles = bottles % numExchange + new
    return total


# --- Next Function Block ---


# 7. Reverse words order in a sentence.
def reverse_words(sentence: str) -> str:
    words = sentence.split()
    return " ".join(words[::-1])


# --- Next Function Block ---


# 8. Given two lists, interleave them (flattened).
def interleave_lists(list1: list, list2: list) -> list:
    result = []
    for a, b in zip(list1, list2):
        result.extend([a, b])
    return result


# --- Next Function Block ---


# 9. Min Max Game: reduce list by alternately taking min and max until one number remains.
def min_max_game(nums: list) -> int:
    turn = True  # True: choose min; False: choose max.
    while len(nums) > 1:
        new_nums = []
        for i in range(0, len(nums) - 1, 2):
            if turn:
                new_nums.append(min(nums[i], nums[i+1]))
            else:
                new_nums.append(max(nums[i], nums[i+1]))
            turn = not turn
        if len(nums) % 2 == 1:
            new_nums.append(nums[-1])
        nums = new_nums
    return nums[0]


# --- Next Function Block ---


# 10. Interleave even and odd numbers from a list.
def interleave_even_odd(nums: list) -> list:
    even = [x for x in nums if x % 2 == 0]
    odd = [x for x in nums if x % 2 != 0]
    result = []
    for i in range(max(len(even), len(odd))):
        if i < len(even):
            result.append(even[i])
        if i < len(odd):
            result.append(odd[i])
    return result


# --- Next Function Block ---


# 11. Elimination game: repeatedly remove alternate elements and reverse until one remains.
def elimination_game(n: int) -> int:
    # Using a known algorithm for the elimination game problem.
    # For demonstration, we simulate a simple elimination: remove every other element, then reverse.
    arr = list(range(1, n+1))
    reverse = False
    while len(arr) > 1:
        if not reverse:
            arr = arr[1::2]
        else:
            arr = arr[::2]
        arr.reverse()
        reverse = not reverse
    return arr[0]


# --- Next Function Block ---


# 12. Summary ranges: given a sorted list, return summary ranges.
def summary_ranges(nums: list) -> list:
    ranges = []
    i = 0
    n = len(nums)
    while i < n:
        start = nums[i]
        while i + 1 < n and nums[i+1] == nums[i] + 1:
            i += 1
        end = nums[i]
        if start == end:
            ranges.append(str(start))
        else:
            ranges.append(f"{start}->{end}")
        i += 1
    return ranges


# --- Next Function Block ---


# 13. Count operations to reduce num to 0.
def number_of_operations(num: int) -> int:
    count = 0
    while num:
        if num % 2 == 0:
            num //= 2
        else:
            num -= 1
        count += 1
    return count


# --- Next Function Block ---


# 14. Minimum operations to reach target from 1 with doubling allowed.
def min_operations_to_target(target: int, maxDoubles: int) -> int:
    i = 1
    count = 0
    while i < target:
        if maxDoubles > 0 and i * 2 <= target:
            i *= 2
            maxDoubles -= 1
        else:
            i += 1
        count += 1
    return count


# --- Next Function Block ---


# 15. Sort string by frequency (descending) and reconstruct.
def sort_string_by_frequency(s: str) -> str:
    freq = Counter(s)
    sorted_items = sorted(freq.items(), key=lambda item: item[1], reverse=True)
    result = ""
    for ch, cnt in sorted_items:
        result += ch * cnt
    return result


# --- Next Function Block ---


# 16. k most frequent elements.
def k_most_frequent(nums: list, k: int) -> list:
    freq = Counter(nums)
    sorted_items = sorted(freq.items(), key=lambda item: item[1], reverse=True)
    return [item[0] for item in sorted_items[:k]]


# --- Next Function Block ---


# 17. First unique character's index.
def first_unique_char(s: str) -> int:
    freq = Counter(s)
    for ch in s:
        if freq[ch] == 1:
            return s.index(ch)
    return -1


# --- Next Function Block ---


# 18. Find first duplicate index and return dictionary of seen letters.
def first_duplicate_index(s: str) -> (int, dict):
    seen = {}
    for i, ch in enumerate(s):
        if ch in seen:
            return i, seen
        seen[ch] = 1
    return -1, seen


# --- Next Function Block ---


# 19. Return indices where element doesn't equal its 1-indexed value.
def indices_not_matching(nums: list) -> list:
    result = []
    for i in range(len(nums)):
        if i + 1 != nums[i]:
            result.append(i)
    result.append(len(nums) - 1)
    return result


# --- Next Function Block ---


# 20. Reduce all numbers to zero by subtracting the minimum nonzero repeatedly.
def min_operations_to_zero(nums: list) -> int:
    operations = 0
    while any(x != 0 for x in nums):
        nonzeros = [x for x in nums if x != 0]
        sub = min(nonzeros) if nonzeros else 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[i] -= sub
        operations += 1
    return operations


# --- Next Function Block ---


# 21. Find XOR sequence given a mapping.
def find_xor_sequence(pref: list, mapping: dict) -> list:
    xor_val = 0
    result = []
    for val in pref:
        j = mapping[len(str(xor_val))]
        while xor_val ^ j != val:
            j += 1
        xor_val ^= j
        result.append(j)
    return result


# --- Next Function Block ---


# 22. Count operations to reduce a number to zero (if even divide by 2, if odd subtract 1).
# (Same as function number_of_operations.)

# 23. Minimum operations to reach a target from 1, with doubling allowed.
# (Same as min_operations_to_target.)

# 24. (Repeated snippet) – already covered.

# 25. Intersection of two lists, multiset style.
# (Same as function multiset_intersection; see function 1.)

# 26. Concatenate two lists by zipping them.
def interleave_lists_zip(arr1: list, arr2: list) -> list:
    result = []
    for a, b in zip(arr1, arr2):
        result.extend([a, b])
    return result


# --- Next Function Block ---


# 27. Use reduce to sum a list.
def reduce_sum(arr: list) -> int:
    return functools.reduce(lambda x, y: x + y, arr)


# --- Next Function Block ---


# 28. Reverse words order in a sentence.
# (Same as function reverse_words.)

# 29. Count frequency of elements in a list (returns dictionary).
def frequency_dict(arr: list) -> dict:
    return dict(Counter(arr))


# --- Next Function Block ---


# 30. Demonstrate a simple iterator over a list.
def iterate_with_iterator(arr: list) -> list:
    it = iter(arr)
    result = []
    for _ in range(len(arr)):
        result.append(next(it))
    return result


# --- Next Function Block ---




# 1. Remove duplicates (and 0) from a list, then repeatedly subtract the smallest element until the list is empty.
def count_subtraction_operations(nums: list) -> int:
    """
    Given a list of numbers, first remove duplicates and remove 0 if present.
    Then, in each operation, subtract the minimum value from all numbers,
    deleting any that become less than 1. Returns the count of operations performed.
    """
    # Remove duplicates and remove 0 if present.
    nums = list(set(nums))
    if 0 in nums:
        nums.remove(0)
    count = 0
    while len(nums) != 0:
        sub = min(nums)
        i = 0
        while i < len(nums):
            nums[i] -= sub
            if nums[i] < 1:
                del nums[i]
                # After deletion, stay at the same index.
                continue
            i += 1
        count += 1
    return count


# --- Next Function Block ---



# 2. Repeatedly remove the first occurrence of a substring from a string.
def remove_substring_repeatedly(s: str, part: str) -> str:
    """
    Repeatedly removes the first occurrence of 'part' from 's'
    until 'part' is no longer present. Returns the final string.
    """
    while part in s:
        i = 0
        while i < len(s):
            if s[i:i+len(part)] == part:
                s = s[:i] + s[i+len(part):]
                break
            i += 1
    return s


# --- Next Function Block ---



# 3. Get a range of numbers as a list.
def get_range(n: int) -> list:
    """
    Returns a list of numbers from 0 to n-1.
    """
    return list(range(n))


# --- Next Function Block ---



# 4. Count the number of differing bits between two numbers (given as padded binary strings).
def bit_difference_count(start: int, goal: int, pad_length: int = 30) -> int:
    """
    Converts start and goal into binary strings padded to pad_length,
    then counts the number of bit positions where they differ.
    """
    bin_start = list(str(0) * (pad_length - len(bin(start)[2:])) + str(bin(start)[2:])
                   )
    bin_goal = list(str(0) * (pad_length - len(bin(goal)[2:])) + str(bin(goal)[2:])
                  )
    count = 0
    i = pad_length - 1
    while i >= 0:
        if bin_goal[i] != bin_start[i]:
            # "Fix" the start bit (not needed for count, but mimicking snippet)
            bin_start[i] = bin_goal[i]
            count += 1
        i -= 1
    return count


# --- Next Function Block ---



# 5. Check self-describing number property.
def check_self_describing(num: str) -> bool:
    """
    For each digit position i in num, checks whether the count of digit str(i)
    equals int(num[i]). Returns True if the property holds for all positions.
    Prints any indices that do not match.
    """
    isTrue = True
    for i in range(len(num)):
        if num.count(str(i)) != int(num[i]):
            print(f"Mismatch at index {i}: count({str(i)}) = {num.count(str(i))} != {num[i]}")
            isTrue = False
    return isTrue


# --- Next Function Block ---



# 6. Return all self-dividing numbers between left and right (inclusive).
def self_dividing_numbers(left: int, right: int) -> list:
    """
    Returns a list of self-dividing numbers in the range [left, right].
    A self-dividing number has no zero digits and each digit divides the number.
    """
    result = []
    for num in range(left, right + 1):
        s = str(num)
        flag = True
        for ch in s:
            digit = int(ch)
            if digit == 0 or num % digit != 0:
                flag = False
                break
        if flag:
            result.append(num)
    return result


# --- Next Function Block ---



# 7. Count, for a number, how many of its digits divide the number.
def count_divisible_digits(num: int) -> int:
    """
    Returns the count of digits in num that evenly divide num.
    """
    s = str(num)
    count = 0
    for ch in s:
        digit = int(ch)
        if digit != 0 and num % digit == 0:
            count += 1
    return count


# --- Next Function Block ---



# 8. Elimination game: for a given n, create a list of odd numbers, then
#    repeatedly remove every other element and reverse until one remains.
def elimination_game_odds(n: int) -> int:
    """
    Returns the last remaining element after repeatedly eliminating every
    other element from the reversed list of odd numbers from 1 to n.
    """
    arr = list(range(1, n + 1, 2))
    arr = arr[::-1]
    while len(arr) > 1:
        i = 0
        new_arr = []
        while i < len(arr):
            # Delete every other element: take one, skip one.
            new_arr.append(arr[i])
            i += 2
        arr = new_arr[::-1]
    return arr[0] if arr else None


# --- Next Function Block ---



# 9. Given a binary matrix, return the column indices where the count of 1's is odd.
def odd_columns(mat: list) -> list:
    """
    Returns a list of column indices for which the sum of 1's in that column is odd.
    """
    if not mat:
        return []
    cols = len(mat[0])
    result = []
    for j in range(cols):
        col_sum = sum(mat[i][j] for i in range(len(mat)))
        if col_sum % 2 == 1:
            result.append(j)
    return result


# --- Next Function Block ---



# 10. Swap the first two numbers in a list using arithmetic operations.
def swap_first_two(nums: list) -> list:
    """
    Swaps the first two numbers in nums without using a temporary variable.
    """
    if len(nums) < 2:
        return nums
    i, j = 0, 1
    nums[j] = nums[i] + nums[j]
    nums[i] = nums[j] - nums[i]
    nums[j] = nums[j] - nums[i]
    return nums


# --- Next Function Block ---






class Node:
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next

class LinkedList:
    def __init__(self):
        self.head = None

    def insert_at_begining(self, data):
        node = Node(data, self.head)
        self.head =  node

    def print(self):
        if self.head == None:
            print("Linked List is empty")
            return
        current = self.head
        while current.next:
            print(current.data)
            current = current.next


class Node:
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next

class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def add_node(self, data):
        node = Node(data)
        if self.head == None:
            self.head = node
            self.tail = self.head
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = node
            self.tail = current.next
    
    def insert_at_begining(self, data):
        node = Node(data)
        if self.head == None:
            self.head = node
        else:
            current = self.head
            self.head = node
            self.head.next = current

    def insert_at_end(self, data):
        node = Node(data)
        current = self.tail
        self.tail = node
        current.next = self.tail

    def insert(self, data, target):
        node = Node(data)
        current = self.head
        while current.data != target:
            current = current.next
        new_node = node
        new_node.next = current.next
        current.next = new_node

    def delete(self, target):
        current = self.head
        while current.data != target:
            previus = current
            current = current.next
        previus.next = current.next
        
    
    def print(self):
        current = self.head
        while current:
            print(current.data)
            current = current.next





# patterns.py


# ---------------------------
# Snippet 1:
# Find the row and column indices of all 1's in a matrix.
def find_ones_indices(mat: list):
    """
    Given a 2D matrix mat, returns a tuple (arri, arrj) where:
      - arri is the list of row indices of each 1,
      - arrj is the list of corresponding column indices.
    Example:
      mat = [
         [0,0,0,0,0,1,0,0],
         [0,0,0,0,1,0,0,1],
         [0,0,0,0,1,0,0,0],
         [1,0,0,0,1,0,0,0],
         [0,0,1,1,0,0,0,0]
      ]
      returns ( [0,1,1,2,3,3,4,4], [5,4,7,4,0,4,2,3] )
    """
    arri = []
    arrj = []
    for i in range(len(mat)):
        for j in range(len(mat[i])):
            if mat[i][j] == 1:
                arri.append(i)
                arrj.append(j)
    return arri, arrj


# --- Next Function Block ---



# ---------------------------
# Snippet 2:
# Count numbers between low and high (inclusive) that are "lucky" – having an even number of digits
# and the sum of the first half equals the sum of the second half.
def count_lucky_numbers(low: int, high: int) -> int:
    """
    For each number between low and high (inclusive) with an even number of digits,
    splits the number into two halves (as strings), sums the digits in each half, and
    counts the number of numbers where the two sums are equal.
    Returns the count.
    """
    count = 0
    for num in range(low, high + 1):
        s = str(num)
        if len(s) % 2 == 0:
            half = len(s) // 2
            first_half = s[:half]
            second_half = s[half:]
            sum_first = sum(int(ch) for ch in first_half)
            sum_second = sum(int(ch) for ch in second_half)
            if sum_first == sum_second:
                count += 1
    return count


# --- Next Function Block ---



# ---------------------------
# Snippet 3:
# Find an index of a target value in an array using two methods:
# (a) Linear search, and (b) a binary search–like approach.
def linear_search_index(array: list, target) -> int:
    """
    Performs a linear search in array for target and returns the index if found;
    otherwise returns -1.
    """
    for i, val in enumerate(array):
        if val == target:
            return i
    return -1


# --- Next Function Block ---


def binary_search_value(array: list, target) -> int:
    """
    Assumes array is sorted in ascending order.
    Uses a binary search–like approach (by slicing the array) to find target.
    Returns the target value if found, else raises ValueError.
    Note: This implementation modifies the array slice at each iteration.
    """
    arr = array[:]  # copy the array
    while len(arr) > 1:
        i = (len(arr) // 2) - 1  # use (mid-1) as in the snippet
        if arr[i] == target:
            return arr[i]
        elif arr[i] < target:
            arr = arr[i:]  # take the right half (including arr[i])
        else:
            arr = arr[:i+1]  # take the left half (include arr[i])
    # When the loop exits, if the remaining element equals target, return it.
    if arr and arr[0] == target:
        return arr[0]
    raise ValueError("Target not found in array")


# --- Next Function Block ---





class Node:
    def __init__(self, data=None, next=None, prev=None):
        self.data = data
        self.next = next
        self.prev = prev

class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
    
    def append(self, data):
        node = Node(data)
        if self.head == None:
            self.head = node
            self.tail = self.head
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = node
            current.next.prev = current
            self.tail = current.next

    def print(self):
        if self.head == None:
            print("Linked List is empty")
            return
        current = self.head
        while current:
            print(current.data)
            current = current.next
    
    def reversal(self):
        if self.tail==None:
            print("Linked List is empty")
            return
        current = self.tail
        while current:
            print(current.data)
            current = current.prev
        

# patterns.py
import string

# 1. Create a dictionary mapping each letter (both lowercase and uppercase) 
#    to an increasing integer starting at 0.
def letter_to_index_dict() -> dict:
    mapping = {}
    j = 0
    for ch in string.ascii_letters:
        mapping[ch] = j
        j += 1
    return mapping


# --- Next Function Block ---


# 2. Recursive factorial function.
def factorial(n: int) -> int:
    """
    Returns the factorial of n (n!).
    If n < 1, returns 1.
    """
    if n < 1:
        return 1
    return n * factorial(n - 1)


# --- Next Function Block ---


# 3. Maximum Units on a Truck.
def max_units_on_truck(boxTypes: list, truckSize: int) -> int:
    """
    Given a list of boxTypes where each element is a list [number_of_boxes, units_per_box]
    and an integer truckSize (maximum number of boxes the truck can carry),
    returns the maximum number of units that can be loaded onto the truck.
    """
    # Sort boxTypes by units per box in descending order.
    sorted_boxes = sorted(boxTypes, key=lambda item: item[1], reverse=True)
    total_units = 0
    for num_boxes, units in sorted_boxes:
        if truckSize <= 0:
            break
        # Take as many boxes as possible, up to the truckSize remaining.
        boxes_to_take = min(num_boxes, truckSize)
        total_units += boxes_to_take * units
        truckSize -= boxes_to_take
    return total_units


# --- Next Function Block ---


# 4. (Placeholder) An empty list creation snippet (if needed).
def empty_list() -> list:
    return []


# --- Next Function Block ---




class Node:
    def __init__(self, data=None, next=None, prev=None):
        self.data = data
        self.next = next
        self.prev = prev
    
class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def append(self, data):
        node = Node(data)
        if self.head == None:
            self.head = node
            self.tail = self.head
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = node
            current.next.prev = current
            self.tail = current.next
    
    def print(self):
        if self.head == None:
            print("Linked List is empty")
            return
        current = self.head
        while current:
            print(current.data)
            current = current.next
    
    def reversal(self):
        if self.tail == None:
            print("Linked List is empty")
            return
        current = self.tail
        while current:
            print(current.data)
            current = current.prev

    def insert_at_begining(self, data):
        node = Node(data)
        if self.head == None:
            self.head = node
        else:
            current = self.head
            self.head = node
            self.head.next = current
    
    def insert_at_end(self, data):
        node = Node(data)
        if self.tail == None:
            self.tail = node
        else:
            current = self.tail
            self.tail = node
            current.next = self.tail

    def insert_after(self, data, target):
        node = Node(data)
        if self.head == None:
            self.head = node
            self.tail = self.head
        else:
            current = self.head
            while current:
                if current.data == target:
                    node.next = current.next
                    current.next = node
                    return
                current = current.next
            current = self.tail
            self.tail = node
            current.next = self.tail

    def insert_before(self, data, target):
        node = Node(data)
        if self.head == None:
            self.head = node
            self.tail = self.head
        else:
            current = self.head
            while current:
                if current.next.data == target:
                    node.next = current.next
                    current.next = node
                    return
                if current.next == self.tail:
                    new_node = current
                current = current.next
            node.next = self.tail
            new_node.next = node

    def delete(self, target):
        if self.head:
            current = self.head
            if current.data == target:
                self.head = current.next
                return
            while current:
                if current.next.data == target:
                    current.next = current.next.next
                    return
                current = current.next

    def remove_duplicate(self):
        current = self.head
        while current.next != None:
            if current.data == current.next.data:
                current.next = current.next.next
            else:
                current = current.next
        



# patterns.py

def find_ones_indices(mat: list) -> (list, list, int, int):
    """
    Given a 2D matrix mat, this function finds all indices (i, j) where the value is 1.
    It returns a tuple:
      (list_of_row_indices, list_of_column_indices, unique_row_count, unique_column_count)
    
    The first loop collects the row indices (arri) and column indices (arrj) for each 1.
    The second loop (using .count) is used to count how many rows and columns appear exactly once.
    """
    arri = []
    arrj = []
    # Collect indices where mat[i][j] == 1.
    i = 0
    while i < len(mat):
        j = 0
        while j < len(mat[i]):
            if mat[i][j] == 1:
                arri.append(i)
                arrj.append(j)
            j += 1
        i += 1
    # Count how many indices in arri and arrj are unique (appear exactly once)
    unique_row_count = sum(1 for x in arri if arri.count(x) == 1)
    unique_col_count = sum(1 for x in arrj if arrj.count(x) == 1)
    return arri, arrj, unique_row_count, unique_col_count


# --- Next Function Block ---



def count_lucky_numbers(low: int, high: int) -> int:
    """
    For each number in the inclusive range [low, high] that has an even number of digits,
    splits it into two equal halves and sums the digits in each half.
    If the two sums are equal, counts the number as "lucky."
    
    Returns the total count of lucky numbers.
    """
    count = 0
    for num in range(low, high + 1):
        s = str(num)
        if len(s) % 2 == 0:
            half = len(s) // 2
            first_half = s[:half]
            second_half = s[half:]
            sum_first = sum(int(ch) for ch in first_half)
            sum_second = sum(int(ch) for ch in second_half)
            if sum_first == sum_second:
                count += 1
    return count


# --- Next Function Block ---



def linear_and_binary_search(array: list, target) -> (int, int):
    """
    Performs two searches for target in array:
      1. A linear search that returns the first index where target is found.
      2. A simulated binary search approach:
         - Repeatedly takes the middle element of the current array slice until target is found.
         - Returns the value found (if found) from the reduced array.
    
    Note: The binary search simulation assumes the array is sorted.
    
    Returns a tuple (linear_index, binary_search_value).
    """
    # Linear search
    linear_index = -1
    i = 0
    while i < len(array):
        if array[i] == target:
            linear_index = i
            break
        i += 1

    # Binary search simulation: iteratively reduce the array slice.
    temp_arr = array[:]  # make a copy
    while len(temp_arr) > 1 and target not in temp_arr:
        mid_index = (len(temp_arr) // 2) - 1
        # Adjust mid_index if negative.
        if mid_index < 0:
            mid_index = 0
        # Check if the middle element equals target.
        if temp_arr[mid_index] == target:
            break
        # Otherwise, decide to slice left or right.
        if temp_arr[mid_index] < target:
            temp_arr = temp_arr[mid_index:]
        else:
            temp_arr = temp_arr[:mid_index + 1]
    # If target is in temp_arr, pick it; otherwise, take the middle.
    binary_value = target if target in temp_arr else temp_arr[len(temp_arr)//2]
    return linear_index, binary_value


# --- Next Function Block ---





    

class Node:
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next

class Stack:
    def __init__(self):
        self.head = None
    
    def append(self, data):
        node = Node(data)
        if self.head == None:
            self.head = node
        else:
            current = self.head
            self.head = node
            self.head.next = current
    
    def print(self):
        current = self.head
        while current:
            print(current.data)
            current = current.next
    
    def pop(self):
        self.head = self.head.next
    
    def push(self, data):
        node = Node(data)
        current = self.head
        self.head = node
        self.head.next = current

    def dequeue(self):
        current = self.head
        while current.next.next:
            current = current.next
        current.next = None

    def enqueue(self, data):
        node = Node(data)
        current = self.head
        while current.next:
            current = current.next
        current.next = node


# sorting_snippets.py

import functools

# 1. Even/Odd index digit-sum from sorted digits of a number.
def sum_even_odd_sorted_digits(num: int) -> int:
    """
    Converts the number into a list of its digits (as strings), sorts them in increasing order,
    then forms two numbers:
      - One by concatenating digits at even indices,
      - The other by concatenating digits at odd indices.
    Returns the sum of these two numbers.
    
    Example:
      num = 4325
      Sorted digits: ['2', '3', '4', '5']
      Even-indexed (indices 0,2): "2" + "4" = "24"
      Odd-indexed (indices 1,3): "3" + "5" = "35"
      Returns 24 + 35 = 59.
    """
    digits = list(str(num))
    digits.sort()
    even_str = ""
    odd_str = ""
    i = 0
    while i < len(digits):
        if i % 2 == 0:
            even_str += digits[i]
        else:
            odd_str += digits[i]
        i += 1
    return int(even_str) + int(odd_str)


# --- Next Function Block ---



# 2. Check if there is a partition in the sorted list so that the sum of one part equals the sum of the other.
def can_partition_equal_sum(nums: list) -> bool:
    """
    Given a list of numbers, sorts it and then checks each possible partition index i such that
    the sum of the numbers before i equals the sum of the numbers after i.
    Returns True if such a partition exists; otherwise False.
    
    Example:
      nums = [1, 5, 11, 5]
      Sorted: [1, 5, 5, 11]
      Partition between indices 2 and 3: sum([1,5]) == 6 and sum([5,11]) == 16 (not equal)
      (The provided snippet does not find a partition in this example so it would return False.)
    """
    nums.sort()
    total = sum(nums)
    left_sum = 0
    for i in range(len(nums)):
        left_sum += nums[i]
        if left_sum * 2 == total:
            return True
    return False


# --- Next Function Block ---



# 3. Dummy loop function (simply loops from 1 to n).
def loop_through_range(n: int) -> list:
    """
    Loops from 1 to n (inclusive) and returns a list of these numbers.
    (Original snippet only increments i; this function returns the list.)
    """
    result = []
    i = 1
    while i <= n:
        result.append(i)
        i += 1
    return result


# --- Next Function Block ---



# 4. Compute sum based on counts: subtract from numOnes, numZeros, numNegOnes for k iterations.
def compute_sum_from_counts(numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:
    """
    For k iterations, if there are any ones, add 1 to the sum and decrease numOnes.
    Otherwise, if zeros remain, just decrease numZeros (add nothing),
    and if negative ones remain, subtract 1 and decrease numNegOnes.
    Returns the computed sum.
    
    Example:
      numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2.
      Iteration 1: ones available → sum becomes 1, numOnes becomes 2.
      Iteration 2: ones available → sum becomes 2, numOnes becomes 1.
      Returns 2.
    """
    total = 0
    i = 0
    while i < k:
        if numOnes > 0:
            total += 1
            numOnes -= 1
        elif numZeros > 0:
            numZeros -= 1
        elif numNegOnes > 0:
            total -= 1
            numNegOnes -= 1
        i += 1
    return total


# --- Next Function Block ---



# 5. Find the maximum even length of a contiguous block pattern.
def max_contiguous_even_block_length(s: str) -> int:
    """
    Given a string s, starting from half its length (integer division) and decrementing,
    checks if either pattern "1"*i + "0"*i or "0"*i + "1"*i exists in s.
    If found, prints (or returns) i*2.
    Returns the maximum even length found; if none, returns 0.
    
    Example:
      s = "01000111"
      It checks for patterns like "11"+"00" or "00"+"11".
    """
    max_length = 0
    i = len(s) // 2
    while i > 0:
        pattern1 = "1" * i + "0" * i
        pattern2 = "0" * i + "1" * i
        if pattern1 in s or pattern2 in s:
            max_length = i * 2
            break
        i -= 1
    return max_length


# --- Next Function Block ---



# 6. Bubble sort (using nested while loops).
def bubble_sort(arr: list) -> list:
    """
    Performs bubble sort on the list arr using while loops.
    Returns the sorted list.
    """
    j = 0
    while j < len(arr):
        i = 0
        while i < len(arr) - 1:
            if arr[i] > arr[i+1]:
                arr[i], arr[i+1] = arr[i+1], arr[i]
            i += 1
        j += 1
    return arr


# --- Next Function Block ---



# 7. Insertion sort (using while loops).
def insertion_sort(arr: list) -> list:
    """
    Performs insertion sort on the list arr.
    Returns the sorted list.
    """
    i = 1
    while i < len(arr):
        if arr[i] < arr[i-1]:
            j = i - 1
            # If current element is less than the first element, insert at beginning.
            if arr[i] < arr[0]:
                arr.insert(0, arr[i])
                del arr[i+1]
            else:
                while j >= 0 and arr[i] < arr[j]:
                    j -= 1
                arr.insert(j+1, arr[i])
                del arr[i+1]
        else:
            i += 1
    return arr


# --- Next Function Block ---



# 8. Selection sort (using while loops).
def selection_sort(arr: list) -> list:
    """
    Performs selection sort on the list arr using while loops.
    Returns the sorted list.
    """
    i = 0
    while i < len(arr) - 1:
        j = i + 1
        while j < len(arr):
            if arr[j] < arr[i]:
                arr[i], arr[j] = arr[j], arr[i]
            j += 1
        i += 1
    return arr


# --- Next Function Block ---



# 9. Quick sort (first variant).
def quick_sort(arr: list) -> list:
    """
    Sorts the list arr in place using quick sort (first variant).
    Returns the sorted list.
    """
    def swap(a, i, j):
        a[i], a[j] = a[j], a[i]
    
    def qs(a, start, end):
        if start >= end:
            return
        pivot = start
        left = start + 1
        right = end
        while left <= right:
            if a[left] > a[pivot] and a[right] < a[pivot]:
                swap(a, left, right)
                left += 1
                right -= 1
            if left <= end and a[left] <= a[pivot]:
                left += 1
            if right >= start and a[right] >= a[pivot]:
                right -= 1
        swap(a, pivot, right)
        qs(a, start, right - 1)
        qs(a, right + 1, end)
    
    qs(arr, 0, len(arr) - 1)
    return arr


# --- Next Function Block ---



# 10. Quick sort (second variant).
def quick_sort_variant(nums: list) -> list:
    """
    Sorts the list nums in place using a quick sort variant.
    Returns the sorted list.
    """
    def swap(a, i, j):
        a[i], a[j] = a[j], a[i]
    
    def qs(a, start, end):
        if start >= end:
            return
        pivot = start
        left = start + 1
        right = end
        while left <= right:
            if a[left] > a[pivot] and a[right] < a[pivot]:
                swap(a, left, right)
                left += 1
                right -= 1
            if left <= end and a[left] <= a[pivot]:
                left += 1
            if right >= start and a[right] >= a[pivot]:
                right -= 1
        swap(a, pivot, right)
        qs(a, start, right - 1)
        qs(a, right + 1, end)
    
    qs(nums, 0, len(nums) - 1)
    return nums


# --- Next Function Block ---





# ---------- Miscellaneous Functions ----------

def print_prefix_sublists(nums: list) -> None:
    """
    For each index i in nums, prints all sublists (slices) of nums[0:i].
    """
    for i in range(len(nums)):
        # For the prefix of length i, print each sublist starting at each index within that prefix.
        for j in range(len(nums[:i])):
            print(nums[:i][j:])


# --- Next Function Block ---



def frequency_difference(s: str, t: str) -> int:
    """
    Given two strings s and t, computes the total extra frequency in s over t.
    For each character in s, if t contains it, adds the difference if s has more;
    otherwise, adds the full count from s.
    Returns the total difference.
    """
    count = 0
    sCount = dict(Counter(s))
    tCount = dict(Counter(t))
    for char in sCount:
        if char in tCount:
            if sCount[char] > tCount[char]:
                count += sCount[char] - tCount[char]
        else:
            count += sCount[char]
    return count


# --- Next Function Block ---



def sorted_frequency(word: str) -> dict:
    """
    Returns a dictionary of character frequencies in word,
    sorted by character (alphabetically).
    """
    return dict(sorted(dict(Counter(word)).items(), key=lambda item: item[0]))


# --- Next Function Block ---



def generate_random_list(n: int, low: int, high: int) -> list:
    """
    Generates a list of n random integers between low and high (inclusive).
    """
    return [random.randint(low, high) for _ in range(n)]


# --- Next Function Block ---



# ---------- Sorting Algorithms ----------

def swap(arr: list, i: int, j: int) -> None:
    """
    Swaps the elements at indices i and j in arr.
    """
    arr[i], arr[j] = arr[j], arr[i]


# --- Next Function Block ---



def selection_sort(arr: list) -> list:
    """
    Performs selection sort on a copy of arr and returns the sorted list.
    """
    arr = arr.copy()
    i = 0
    while i < len(arr) - 1:
        j = i + 1
        while j < len(arr):
            if arr[i] > arr[j]:
                swap(arr, i, j)
            j += 1
        i += 1
    return arr


# --- Next Function Block ---



def bubble_sort(arr: list) -> list:
    """
    Performs bubble sort on a copy of arr and returns the sorted list.
    """
    arr = arr.copy()
    i = 0
    while i < len(arr):
        j = 0
        while j < len(arr) - 1:
            if arr[j] > arr[j+1]:
                swap(arr, j, j+1)
            j += 1
        i += 1
    return arr


# --- Next Function Block ---



def insertion_sort(arr: list) -> list:
    """
    Performs insertion sort on a copy of arr and returns the sorted list.
    """
    arr = arr.copy()
    i = 1
    while i < len(arr):
        j = i - 1
        # Shift arr[i] left until it's in the correct position.
        while j >= 0 and arr[j+1] < arr[j]:
            swap(arr, j+1, j)
            j -= 1
        i += 1
    return arr


# --- Next Function Block ---



def quick_sort(arr: list, start: int = None, end: int = None) -> None:
    """
    Performs quick sort in place on arr between indices start and end.
    If start/end are not provided, sorts the entire list.
    """
    if start is None or end is None:
        start, end = 0, len(arr) - 1
    if start >= end:
        return
    pivot = start
    left = start + 1
    right = end
    while left <= right:
        if arr[left] > arr[pivot] and arr[right] < arr[pivot]:
            swap(arr, left, right)
            left += 1
            right -= 1
        if left <= end and arr[left] <= arr[pivot]:
            left += 1
        if right >= start and arr[right] >= arr[pivot]:
            right -= 1
    swap(arr, pivot, right)
    quick_sort(arr, start, right - 1)
    quick_sort(arr, right + 1, end)


# --- Next Function Block ---



def merge(left: list, right: list) -> list:
    """
    Merges two sorted lists (left and right) and returns the merged sorted list.
    """
    merged = []
    i = 0
    j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
    while i < len(left):
        merged.append(left[i])
        i += 1
    while j < len(right):
        merged.append(right[j])
        j += 1
    return merged


# --- Next Function Block ---



def merge_sort(arr: list) -> list:
    """
    Performs merge sort on arr and returns a new sorted list.
    """
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)


# --- Next Function Block ---





# ----- Miscellaneous Functions -----

def print_prefix_sublists(nums: list) -> None:
    """
    For each index i in nums, prints all sublists of nums[0:i].
    For example, if nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4],
    for i=3, it prints all slices of nums[0:3].
    """
    for i in range(len(nums)):
        prefix = nums[:i]
        for j in range(len(prefix)):
            print(prefix[j:])


# --- Next Function Block ---


def get_sorted_frequency(word: str) -> dict:
    """
    Returns a dictionary of character frequencies in word, sorted by the character.
    For example:
        word1 = "cabbba"  --> {'a': 1, 'b': 3, 'c': 1}
        word2 = "abbccc"  --> {'a': 1, 'b': 1, 'c': 3}
    """
    freq = dict(Counter(word))
    # Sort dictionary by keys (alphabetically)
    return dict(sorted(freq.items(), key=lambda item: item[0]))


# --- Next Function Block ---


def generate_random_numbers(n: int, low: int, high: int) -> list:
    """
    Returns a list of n random integers between low and high (inclusive).
    """
    return [random.randint(low, high) for _ in range(n)]


# --- Next Function Block ---


# ----- Sorting Algorithms -----

def selection_sort(arr: list) -> list:
    """
    Performs selection sort on a copy of arr and returns the sorted list.
    """
    arr = arr.copy()
    i = 0
    while i < len(arr) - 1:
        j = i + 1
        while j < len(arr):
            if arr[j] < arr[i]:
                arr[i], arr[j] = arr[j], arr[i]
            j += 1
        i += 1
    return arr


# --- Next Function Block ---


def bubble_sort(arr: list) -> list:
    """
    Performs bubble sort on a copy of arr and returns the sorted list.
    """
    arr = arr.copy()
    i = 0
    while i < len(arr):
        j = 0
        while j < len(arr) - 1:
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
            j += 1
        i += 1
    return arr


# --- Next Function Block ---


def insertion_sort(arr: list) -> list:
    """
    Performs insertion sort on a copy of arr and returns the sorted list.
    """
    arr = arr.copy()
    i = 1
    while i < len(arr):
        if arr[i] < arr[i - 1]:
            j = i - 1
            # If the element is less than the first element, insert at beginning.
            if arr[i] < arr[0]:
                arr.insert(0, arr[i])
                del arr[i + 1]
            else:
                while j >= 0 and arr[i] < arr[j]:
                    j -= 1
                arr.insert(j + 1, arr[i])
                del arr[i + 1]
        else:
            i += 1
        # Optional: print(arr) to see progress.
    return arr


# --- Next Function Block ---


def quick_sort(arr: list, start: int = None, end: int = None) -> None:
    """
    Sorts the list arr in-place using quick sort.
    If start and end are not provided, sorts the entire list.
    """
    if start is None or end is None:
        start, end = 0, len(arr) - 1
    if start >= end:
        return
    pivot = start
    left = start + 1
    right = end
    while left <= right:
        if arr[left] > arr[pivot] and arr[right] < arr[pivot]:
            arr[left], arr[right] = arr[right], arr[left]
            left += 1
            right -= 1
        if left <= end and arr[left] <= arr[pivot]:
            left += 1
        if right >= start and arr[right] >= arr[pivot]:
            right -= 1
    arr[pivot], arr[right] = arr[right], arr[pivot]
    quick_sort(arr, start, right - 1)
    quick_sort(arr, right + 1, end)


# --- Next Function Block ---


def merge(left: list, right: list) -> list:
    """
    Merges two sorted lists and returns a sorted merged list.
    """
    merged = []
    i = 0
    j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
    merged.extend(left[i:])
    merged.extend(right[j:])
    return merged


# --- Next Function Block ---


def merge_sort(arr: list) -> list:
    """
    Performs merge sort on arr and returns a new sorted list.
    """
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)


# --- Next Function Block ---






def print_prefix_sublists(nums: list) -> None:
    """
    For each index i in nums, prints all sublists (slices) of the prefix nums[:i].
    For example, if nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4],
    for each i, prints all slices of nums[0:i].
    """
    i = 0
    while i < len(nums):
        j = 0
        while j < len(nums[:i]):
            # Print the sublist starting at index j of the prefix nums[:i]
            print(nums[:i][j:])
            j += 1
        i += 1


# --- Next Function Block ---


def frequency_difference(s: str, t: str) -> int:
    """
    Computes the total extra frequency in string s compared to string t.
    For each character in s, if t contains that character, adds the difference 
    (sCount - tCount) if s has more; if t does not contain it, adds the full count.
    Returns the total difference.
    
    Example:
      s = "bab", t = "aba" → frequency(s): {'b': 2, 'a': 1}
                           frequency(t): {'a': 2, 'b': 1}
      Difference = (for 'b': 2-1 = 1) + (for 'a': 0 since 1<2) = 1
    """
    sCount = dict(Counter(s))
    tCount = dict(Counter(t))
    total_diff = 0
    for ch in sCount:
        if ch in tCount:
            if sCount[ch] > tCount[ch]:
                total_diff += sCount[ch] - tCount[ch]
        else:
            total_diff += sCount[ch]
    return total_diff


# --- Next Function Block ---


def sorted_frequency(word: str) -> dict:
    """
    Returns a dictionary of character frequencies in the given word,
    sorted by character (alphabetically).
    
    Example:
      word = "cabbba" → {'a': 1, 'b': 3, 'c': 1}
    """
    freq = dict(Counter(word))
    # Sort dictionary by key (character)
    return dict(sorted(freq.items(), key=lambda item: item[0]))


# --- Next Function Block ---


def generate_random_list(n: int, low: int, high: int) -> list:
    """
    Generates a list of n random integers between low and high (inclusive).
    """
    lst = []
    for _ in range(n):
        lst.append(random.randint(low, high))
    return lst


# --- Next Function Block ---


# ----- Sorting Algorithms -----
# Note: All sort functions work on a copy of the list and return the sorted list.

def swap(arr: list, i: int, j: int) -> None:
    """
    Swaps the elements at indices i and j in arr.
    """
    arr[i], arr[j] = arr[j], arr[i]


# --- Next Function Block ---


def selection_sort(arr: list) -> list:
    """
    Performs selection sort on a copy of arr and returns the sorted list.
    """
    arr = arr.copy()
    i = 0
    while i < len(arr) - 1:
        j = i + 1
        while j < len(arr):
            if arr[j] < arr[i]:
                swap(arr, i, j)
            j += 1
        i += 1
    return arr


# --- Next Function Block ---


def bubble_sort(arr: list) -> list:
    """
    Performs bubble sort on a copy of arr and returns the sorted list.
    """
    arr = arr.copy()
    i = 0
    while i < len(arr):
        j = 0
        while j < len(arr) - 1:
            if arr[j] > arr[j+1]:
                swap(arr, j, j+1)
            j += 1
        i += 1
    return arr


# --- Next Function Block ---


def insertion_sort(arr: list) -> list:
    """
    Performs insertion sort on a copy of arr and returns the sorted list.
    """
    arr = arr.copy()
    i = 1
    while i < len(arr):
        if arr[i] < arr[i-1]:
            j = i - 1
            if arr[i] < arr[0]:
                arr.insert(0, arr[i])
                del arr[i+1]
            else:
                while j >= 0 and arr[i] < arr[j]:
                    j -= 1
                arr.insert(j+1, arr[i])
                del arr[i+1]
        else:
            i += 1
        # Uncomment the following line to observe progress:
        # print(arr)
    return arr


# --- Next Function Block ---


def quick_sort(arr: list, start: int = None, end: int = None) -> None:
    """
    Sorts the list arr in place using the quick sort algorithm.
    If start and end are not provided, sorts the entire list.
    """
    if start is None or end is None:
        start, end = 0, len(arr) - 1
    if start >= end:
        return
    pivot = start
    left = start + 1
    right = end
    while left <= right:
        if arr[left] > arr[pivot] and arr[right] < arr[pivot]:
            swap(arr, left, right)
            left += 1
            right -= 1
        if left <= end and arr[left] <= arr[pivot]:
            left += 1
        if right >= start and arr[right] >= arr[pivot]:
            right -= 1
    swap(arr, pivot, right)
    quick_sort(arr, start, right - 1)
    quick_sort(arr, right + 1, end)


# --- Next Function Block ---


def join_sorted(left: list, right: list) -> list:
    """
    Merges two sorted lists (left and right) and returns a new sorted list.
    """
    merged = []
    i = 0
    j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
    merged.extend(left[i:])
    merged.extend(right[j:])
    return merged


# --- Next Function Block ---


def merge_sort(arr: list) -> list:
    """
    Performs merge sort on arr and returns a new sorted list.
    """
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return join_sorted(left, right)


# --- Next Function Block ---




# --- Restaurant Intersection ---
def find_restaurant_with_min_index_sum(list1: list, list2: list) -> str:
    """
    Given two lists of restaurant names, returns the restaurant with the smallest index sum.
    To optimize, iterate over the smaller list.
    
    Example:
      list1 = ["Shogun","Tapioca Express","Burger King","KFC"]
      list2 = ["Piatti","The Grill at Torrey Pines","Hungry Hunter Steakhouse","Shogun"]
      Returns "Shogun" because its index sum (0 + 3) is minimal.
    """
    # Ensure we iterate over the shorter list.
    if len(list1) > len(list2):
        list1, list2 = list2, list1
    res = ""
    min_sum = len(list1) + len(list2)  # upper bound for index sum
    i = 0
    while i < len(list1):
        if list1[i] in list2:
            index_sum = i + list2.index(list1[i])
            if index_sum < min_sum:
                min_sum = index_sum
                res = list1[i]
        i += 1
    return res


# --- Next Function Block ---


# --- Remove k Consecutive Digits ---
def remove_k_consecutive_digits(num: str, k: int) -> str:
    """
    Given a string representing a number and an integer k, remove k consecutive digits
    (for each possible position) and return the smallest resulting number as a string.
    If no removal is possible, returns "0".
    
    Example:
      num = "10", k = 2  → possible removal: remove all digits → result "0"
    """
    arr = []
    i = 0
    # Loop through all starting indices where a k-length substring can be removed.
    while i < len(num) - (k - 1):
        # Remove k consecutive digits: num[:i] + num[i+k:]
        candidate = num[:i] + num[i+k:]
        try:
            arr.append(int(candidate))
        except Exception:
            pass
        i += 1
    return str(min(arr)) if arr else "0"


# --- Next Function Block ---


# --- Remove Increasing Pairs ---
def remove_increasing_pairs(nums: list) -> list:
    """
    Given a list of numbers, iterates through it.
    For each index i, if there exists a later element j such that nums[i] < nums[j],
    deletes both nums[i] and nums[j] (the first such occurrence) and continues.
    Returns the modified list.
    
    Example:
      nums = [2,3,4,4,4]
    """
    i = 0
    # Work on a copy to avoid modifying the original list if needed.
    while i < len(nums) - 1:
        j = i + 1
        while j < len(nums):
            if nums[i] < nums[j]:
                # Remove both elements; adjust index accordingly.
                del nums[j]
                del nums[i]
                i = max(i - 1, 0)
                break
            else:
                j += 1
        i += 1
    return nums


# --- Next Function Block ---


# --- Frequency Difference ---
def frequency_difference(nums: list) -> int:
    """
    Calculates the frequency counts for each number in nums.
    Then, using the sorted frequencies (highest first), sets 'total' equal to the frequency
    of the most frequent element and subtracts the frequencies of the others.
    
    Returns the final computed value.
    """
    freq = dict(sorted(dict(Counter(nums)).items(), key=lambda item: item[1], reverse=True))
    total = None
    for key in freq:
        if total is None:
            total = freq[key]
        else:
            total -= freq[key]
    return total


# --- Next Function Block ---


# --- Remove Triplet With Sum ---
def remove_triplet_with_sum(arr: list) -> list:
    """
    Given a list of integers, first computes total_sum = (sum(arr) // 3).
    Then, it iterates through all pairs (arr[i], arr[j]) and if (total_sum - (arr[i] + arr[j]))
    is present in arr, it prints the triplet and deletes those elements from arr.
    Returns the modified arr.
    
    Note: This function modifies the list in-place.
    """
    total = functools.reduce(lambda x, y: x + y, arr) // 3
    i = 0
    while i < len(arr) - 1:
        j = i + 1
        while j < len(arr):
            candidate = total - (arr[i] + arr[j])
            if candidate in arr:
                # Print the found triplet (optional).
                print(arr[i], arr[j], candidate)
                # Remove the elements.
                del arr[j]
                del arr[i]
                try:
                    arr.remove(candidate)
                except ValueError:
                    pass
                i = max(i - 1, 0)
                break
            else:
                j += 1
        i += 1
    return arr


# --- Next Function Block ---


# --- Max Remaining Money After Purchase ---
def max_remaining_money(prices: list, money: int) -> int:
    """
    Given a list of prices and available money, finds two prices such that their sum is as
    close as possible to money (without exceeding it). Returns the maximum remaining money (money - sum).
    If no pair is found, returns money.
    """
    val = 0
    flag = False
    i = 0
    while i < len(prices) - 1:
        j = i + 1
        while j < len(prices):
            current = prices[i] + prices[j]
            if money - current >= 0 and money - current > val:
                val = money - current
                flag = True
            j += 1
        i += 1
    return val if flag else money


# --- Next Function Block ---


# --- Ordered Match Count ---
def ordered_match_count(text1: str, text2: str) -> int:
    """
    Given two strings text1 and text2, counts how many characters from text1 (in order)
    can be found in text2. When a character is found, moves the starting position of text2 forward.
    
    Example:
      text1 = "ezupkr", text2 = "ubmrapg" → returns the count.
    """
    count = 0
    i = 0
    j = 0
    while i < len(text1) and j < len(text2):
        if text1[i] in text2[j:]:
            count += 1
            j += 1  # move forward in text2
        i += 1
    return count


# --- Next Function Block ---


# --- Binary Ones Counts ---
def binary_ones_counts(n: int) -> list:
    """
    For every integer from 0 to n (inclusive), counts the number of 1's in its binary representation.
    Returns a list of these counts.
    """
    counts = []
    i = 0
    while i <= n:
        binary_rep = bin(i)[2:]
        counts.append(binary_rep.count("1"))
        i += 1
    return counts


# --- Next Function Block ---


# --- XOR Elements ---
def xor_elements(nums: list, k: int) -> list:
    """
    Returns a list where each element is the XOR of the corresponding element in nums with k.
    """
    return [num ^ k for num in nums]


# --- Next Function Block ---


# --- Sum Elements With Index Having k Ones ---
def sum_elements_with_index_ones(nums: list, k: int) -> int:
    """
    Sums elements in nums where the binary representation of the index contains exactly k ones.
    """
    total = 0
    i = 0
    while i < len(nums):
        if bin(i)[2:].count("1") == k:
            total += nums[i]
        i += 1
    return total


# --- Next Function Block ---


# --- Transpose Matrix ---
def transpose_matrix(matrix: list) -> list:
    """
    Given a 2D matrix, returns its transpose.
    The snippet provided builds columns by iterating over indices.
    """
    if not matrix:
        return []
    transposed = []
    # Assume matrix has at least one row.
    num_rows = len(matrix)
    num_cols = len(matrix[0])
    j = 0
    while j < num_cols:
        temp = []
        i = 0
        while i < num_rows:
            temp.append(matrix[i][j])
            i += 1
        transposed.append(temp)
        j += 1
    return transposed


# --- Next Function Block ---


# --- Longest Palindrome Length from Characters ---
def longest_palindrome_length(s: str) -> int:
    """
    Given a string s, computes the length of the longest palindrome that can be built 
    with its letters. (Sum even counts; if any odd count exists, add one.)
    """
    counts = Counter(s)
    length = 0
    odd_found = False
    for count in counts.values():
        if count % 2 == 0:
            length += count
        else:
            length += count - 1
            odd_found = True
    return length + 1 if odd_found else length


# --- Next Function Block ---


# --- Rearrange Digits with Odd Priority ---
def rearrange_digits_with_odd_priority(num: str) -> str:
    """
    Rearranges the digits in num based on frequency:
      - Sorts the digits by their character value (in reverse order).
      - For digits with even frequency, inserts them into the result string (preserving half order).
      - For digits with odd frequency, remembers the one with the largest frequency.
      - Inserts the odd-frequency block into the middle of the result.
    Returns the resulting string.
    
    Note: This function replicates the provided snippet logic.
    """
    freq = dict(Counter(num))
    # Sort keys in reverse order by character.
    sorted_keys = sorted(freq.keys(), reverse=True)
    result = ""
    odd_block = ""
    max_odd = 0
    for key in sorted_keys:
        count = freq[key]
        if count % 2 == 0:
            # Insert even count digits into result.
            # Insert half at the beginning and half at the end.
            mid = len(result) // 2
            result = result[:mid] + key * count + result[mid:]
        else:
            if count > max_odd:
                max_odd = count
                odd_block = key * count
            else:
                mid = len(result) // 2
                result = result[:mid] + key * (count - 1) + result[mid:]
    if odd_block:
        # Insert odd block in the middle.
        mid = len(result) // 2
        result = result[:mid] + odd_block + result[mid:]
    # Convert result to integer then back to string to remove any leading zeros.
    try:
        return str(int(result))
    except Exception:
        return result


# --- Next Function Block ---


# --- Remove Triplet With Sum ---
def remove_triplet_with_sum(arr: list) -> list:
    """
    Computes target = (sum(arr) // 3). Then, iterates over pairs in arr.
    If for any pair (arr[i], arr[j]), the value (target - (arr[i] + arr[j])) is in arr,
    prints the triplet and removes the three numbers from arr.
    Returns the modified list.
    
    Note: This function modifies the list in-place.
    """
    target = functools.reduce(lambda x, y: x + y, arr) // 3
    i = 0
    while i < len(arr) - 1:
        j = i + 1
        while j < len(arr):
            candidate = target - (arr[i] + arr[j])
            if candidate in arr:
                print(arr[i], arr[j], candidate)
                # Remove arr[j] and arr[i] and candidate from arr.
                del arr[j]
                del arr[i]
                try:
                    arr.remove(candidate)
                except ValueError:
                    pass
                i = max(i - 1, 0)
                break
            else:
                j += 1
        i += 1
    return arr


# --- Next Function Block ---


# --- Max Remaining Money After Purchase ---
def max_remaining_money(prices: list, money: int) -> int:
    """
    Finds two prices from prices such that their sum is maximized but does not exceed money.
    Returns money minus the best sum, or money if no valid pair is found.
    """
    val = 0
    flag = False
    i = 0
    while i < len(prices) - 1:
        j = i + 1
        while j < len(prices):
            current_sum = prices[i] + prices[j]
            if money - current_sum >= 0 and money - current_sum > val:
                val = money - current_sum
                flag = True
            j += 1
        i += 1
    return val if flag else money


# --- Next Function Block ---


# --- Ordered Match Count ---
def ordered_match_count(text1: str, text2: str) -> int:
    """
    Counts the number of characters in text1 that appear (in order) in text2.
    For each character in text1, if it exists in the remaining substring of text2,
    increases the count and moves the search index forward.
    """
    count = 0
    i = 0
    j = 0
    while i < len(text1) and j < len(text2):
        if text1[i] in text2[j:]:
            count += 1
            j += 1
        i += 1
    return count


# --- Next Function Block ---


# --- Binary Ones Counts ---
def binary_ones_counts(n: int) -> list:
    """
    For every integer from 0 to n (inclusive), returns the count of '1's in its binary representation.
    """
    counts = []
    i = 0
    while i <= n:
        counts.append(bin(i)[2:].count("1"))
        i += 1
    return counts


# --- Next Function Block ---


# --- XOR Elements ---
def xor_elements(nums: list, k: int) -> list:
    """
    Returns a list where each element is the XOR of the corresponding element in nums with k.
    """
    return [num ^ k for num in nums]


# --- Next Function Block ---


# --- Sum Elements with Index Having k Ones ---
def sum_elements_with_index_ones(nums: list, k: int) -> int:
    """
    Sums elements in nums for which the binary representation of their index contains exactly k ones.
    """
    total = 0
    i = 0
    while i < len(nums):
        if bin(i)[2:].count("1") == k:
            total += nums[i]
        i += 1
    return total


# --- Next Function Block ---


# --- Transpose Matrix ---
def transpose_matrix(matrix: list) -> list:
    """
    Transposes the given 2D matrix.
    """
    if not matrix:
        return []
    num_rows = len(matrix)
    num_cols = len(matrix[0])
    result = []
    j = 0
    while j < num_cols:
        temp = []
        i = 0
        while i < num_rows:
            temp.append(matrix[i][j])
            i += 1
        result.append(temp)
        j += 1
    return result


# --- Next Function Block ---


# --- Longest Palindrome Length from Characters ---
def longest_palindrome_length(s: str) -> int:
    """
    Returns the length of the longest palindrome that can be built with the letters in s.
    """
    counts = Counter(s)
    length = 0
    odd_found = False
    for count in counts.values():
        if count % 2 == 0:
            length += count
        else:
            length += count - 1
            odd_found = True
    return length + 1 if odd_found else length


# --- Next Function Block ---


# --- Rearrange Digits with Odd Priority ---
def rearrange_digits_with_odd_priority(num: str) -> str:
    """
    Rearranges digits of the given string num based on frequency:
    - For even frequency digits, inserts them into the result.
    - For odd frequency digits, selects the one with highest frequency.
    Then inserts the odd-frequency block into the middle of the result.
    Returns the resulting string.
    
    Note: This function directly replicates the provided snippet logic.
    """
    freq = dict(Counter(num))
    # Sort keys in reverse order (by character)
    sorted_keys = sorted(freq.keys(), reverse=True)
    result = ""
    odd_block = ""
    max_odd = 0
    for key in sorted_keys:
        count = freq[key]
        if count % 2 == 0:
            mid = len(result) // 2
            result = result[:mid] + key * count + result[mid:]
        else:
            if count > max_odd:
                max_odd = count
                odd_block = key * count
            else:
                mid = len(result) // 2
                result = result[:mid] + key * (count - 1) + result[mid:]
    if odd_block:
        mid = len(result) // 2
        result = result[:mid] + odd_block + result[mid:]
    try:
        return str(int(result))
    except Exception:
        return result


# --- Next Function Block ---


# --- Remove Triplet with Sum ---
def remove_triplet_with_sum(arr: list) -> list:
    """
    Computes target = (sum(arr) // 3). Then, for every pair in arr,
    if (target - (arr[i] + arr[j])) is present in arr, removes those three elements.
    Returns the modified list.
    
    Note: This function modifies arr in-place.
    """
    target = functools.reduce(lambda x, y: x + y, arr) // 3
    i = 0
    while i < len(arr) - 1:
        j = i + 1
        while j < len(arr):
            candidate = target - (arr[i] + arr[j])
            if candidate in arr:
                print(arr[i], arr[j], candidate)
                del arr[j]
                del arr[i]
                try:
                    arr.remove(candidate)
                except ValueError:
                    pass
                i = max(i - 1, 0)
                break
            else:
                j += 1
        i += 1
    return arr


# --- Next Function Block ---


# --- Max Remaining Money After Purchase ---
def max_remaining_money(prices: list, money: int) -> int:
    """
    Given a list of prices and a total amount of money, finds two prices whose sum is maximized
    without exceeding money. Returns the remaining money (money - sum) if such a pair exists,
    otherwise returns money.
    """
    val = 0
    flag = False
    i = 0
    while i < len(prices) - 1:
        j = i + 1
        while j < len(prices):
            s = prices[i] + prices[j]
            if money - s >= 0 and money - s > val:
                val = money - s
                flag = True
            j += 1
        i += 1
    return val if flag else money


# --- Next Function Block ---


# --- Ordered Match Count ---
def ordered_match_count(text1: str, text2: str) -> int:
    """
    Counts the number of characters in text1 that appear (in order) in text2.
    For each character in text1 found in the remaining part of text2, increments count.
    """
    count = 0
    i = 0
    j = 0
    while i < len(text1) and j < len(text2):
        if text1[i] in text2[j:]:
            count += 1
            j += 1
        i += 1
    return count


# --- Next Function Block ---


# --- Binary Ones Counts ---
def binary_ones_counts(n: int) -> list:
    """
    Returns a list of counts of '1's in the binary representation for each number from 0 to n.
    """
    counts = []
    i = 0
    while i <= n:
        counts.append(bin(i)[2:].count("1"))
        i += 1
    return counts


# --- Next Function Block ---


# --- XOR Elements ---
def xor_elements(nums: list, k: int) -> list:
    """
    Returns a new list where each element is the result of XORing the corresponding element in nums with k.
    """
    return [num ^ k for num in nums]


# --- Next Function Block ---


# --- Sum Elements with Index Having k Ones ---
def sum_elements_with_index_ones(nums: list, k: int) -> int:
    """
    Sums the elements of nums for which the binary representation of the index has exactly k ones.
    """
    total = 0
    i = 0
    while i < len(nums):
        if bin(i)[2:].count("1") == k:
            total += nums[i]
        i += 1
    return total


# --- Next Function Block ---


# --- Transpose Matrix ---
def transpose_matrix(matrix: list) -> list:
    """
    Transposes the given 2D matrix.
    """
    if not matrix:
        return []
    num_rows = len(matrix)
    num_cols = len(matrix[0])
    result = []
    j = 0
    while j < num_cols:
        temp = []
        i = 0
        while i < num_rows:
            temp.append(matrix[i][j])
            i += 1
        result.append(temp)
        j += 1
    return result


# --- Next Function Block ---


# --- Longest Palindrome Length ---
def longest_palindrome_length(s: str) -> int:
    """
    Returns the length of the longest palindrome that can be built with the letters in s.
    """
    counts = Counter(s)
    length = 0
    odd_found = False
    for count in counts.values():
        if count % 2 == 0:
            length += count
        else:
            length += count - 1
            odd_found = True
    return length + 1 if odd_found else length


# --- Next Function Block ---


# --- Rearrange Digits with Odd Priority ---
def rearrange_digits_with_odd_priority(num: str) -> str:
    """
    Rearranges the digits of num based on frequency:
      - Even frequency digits are inserted evenly,
      - The odd-frequency digit with the highest count is inserted in the middle.
    Returns the resulting string.
    
    (This function follows the provided snippet logic.)
    """
    freq = dict(Counter(num))
    sorted_keys = sorted(freq.keys(), reverse=True)
    result = ""
    odd_block = ""
    max_odd = 0
    for key in sorted_keys:
        count_val = freq[key]
        if count_val % 2 == 0:
            mid = len(result) // 2
            result = result[:mid] + key * count_val + result[mid:]
        else:
            if count_val > max_odd:
                max_odd = count_val
                odd_block = key * count_val
            else:
                mid = len(result) // 2
                result = result[:mid] + key * (count_val - 1) + result[mid:]
    if odd_block:
        mid = len(result) // 2
        result = result[:mid] + odd_block + result[mid:]
    try:
        return str(int(result))
    except Exception:
        return result


# --- Next Function Block ---


# --- Remove Triplet With Sum ---
def remove_triplet_with_sum(arr: list) -> list:
    """
    Computes target = (sum(arr) // 3), then iterates over pairs in arr.
    If for any pair (arr[i], arr[j]), (target - (arr[i] + arr[j])) is in arr,
    it prints the triplet and removes those three elements.
    Returns the modified arr.
    
    Note: This function modifies arr in-place.
    """
    target = functools.reduce(lambda x, y: x + y, arr) // 3
    i = 0
    while i < len(arr) - 1:
        j = i + 1
        while j < len(arr):
            candidate = target - (arr[i] + arr[j])
            if candidate in arr:
                print(arr[i], arr[j], candidate)
                del arr[j]
                del arr[i]
                try:
                    arr.remove(candidate)
                except ValueError:
                    pass
                i = max(i - 1, 0)
                break
            else:
                j += 1
        i += 1
    return arr


# --- Next Function Block ---


# --- Max Remaining Money ---
def max_remaining_money(prices: list, money: int) -> int:
    """
    Given a list of prices and a total amount of money, finds two prices such that
    their sum is as close as possible to money (without exceeding it). Returns
    money minus the sum if such a pair is found; otherwise, returns money.
    """
    val = 0
    flag = False
    i = 0
    while i < len(prices) - 1:
        j = i + 1
        while j < len(prices):
            current_sum = prices[i] + prices[j]
            if money - current_sum >= 0 and money - current_sum > val:
                val = money - current_sum
                flag = True
            j += 1
        i += 1
    return val if flag else money


# --- Next Function Block ---


# --- Ordered Match Count ---
def ordered_match_count(text1: str, text2: str) -> int:
    """
    Counts the number of characters in text1 that appear (in order) in text2.
    """
    count = 0
    i = 0
    j = 0
    while i < len(text1) and j < len(text2):
        if text1[i] in text2[j:]:
            count += 1
            j += 1
        i += 1
    return count


# --- Next Function Block ---


# --- Binary Ones Counts ---
def binary_ones_counts(n: int) -> list:
    """
    For every integer from 0 to n (inclusive), returns a list of counts of '1's
    in their binary representations.
    """
    counts = []
    i = 0
    while i <= n:
        counts.append(bin(i)[2:].count("1"))
        i += 1
    return counts


# --- Next Function Block ---


# --- XOR Elements ---
def xor_elements(nums: list, k: int) -> list:
    """
    Returns a list with each element of nums XORed with k.
    """
    return [num ^ k for num in nums]


# --- Next Function Block ---


# --- Sum Elements with Index Having k Ones ---
def sum_elements_with_index_ones(nums: list, k: int) -> int:
    """
    Sums elements in nums whose index has exactly k ones in its binary representation.
    """
    total = 0
    i = 0
    while i < len(nums):
        if bin(i)[2:].count("1") == k:
            total += nums[i]
        i += 1
    return total


# --- Next Function Block ---


# --- Transpose Matrix ---
def transpose_matrix(matrix: list) -> list:
    """
    Transposes the given 2D matrix.
    """
    if not matrix:
        return []
    num_rows = len(matrix)
    num_cols = len(matrix[0])
    result = []
    j = 0
    while j < num_cols:
        temp = []
        i = 0
        while i < num_rows:
            temp.append(matrix[i][j])
            i += 1
        result.append(temp)
        j += 1
    return result


# --- Next Function Block ---


# --- Longest Palindrome Length ---
def longest_palindrome_length(s: str) -> int:
    """
    Returns the length of the longest palindrome that can be built with the letters in s.
    """
    counts = Counter(s)
    length = 0
    odd_found = False
    for count in counts.values():
        if count % 2 == 0:
            length += count
        else:
            length += count - 1
            odd_found = True
    return length + 1 if odd_found else length


# --- Next Function Block ---


# --- Rearrange Digits with Odd Priority ---
def rearrange_digits_with_odd_priority(num: str) -> str:
    """
    Rearranges the digits of num based on frequency:
      - For digits with even frequency, inserts them evenly.
      - For digits with odd frequency, selects the digit with highest count
        and inserts its block into the middle.
    Returns the resulting string.
    (This function replicates the provided snippet logic.)
    """
    freq = dict(Counter(num))
    sorted_keys = sorted(freq.keys(), reverse=True)
    result = ""
    odd_block = ""
    max_odd = 0
    for key in sorted_keys:
        count_val = freq[key]
        if count_val % 2 == 0:
            mid = len(result) // 2
            result = result[:mid] + key * count_val + result[mid:]
        else:
            if count_val > max_odd:
                max_odd = count_val
                odd_block = key * count_val
            else:
                mid = len(result) // 2
                result = result[:mid] + key * (count_val - 1) + result[mid:]
    if odd_block:
        mid = len(result) // 2
        result = result[:mid] + odd_block + result[mid:]
    try:
        return str(int(result))
    except Exception:
        return result


# --- Next Function Block ---


# --- Remove Triplet with Sum ---
def remove_triplet_with_sum(arr: list) -> list:
    """
    Computes target = (sum(arr) // 3), then iterates over pairs in arr.
    If for any pair (arr[i], arr[j]) the value (target - (arr[i] + arr[j])) exists in arr,
    prints the triplet and removes those three elements.
    Returns the modified arr.
    
    Note: This function modifies arr in-place.
    """
    target = functools.reduce(lambda x, y: x + y, arr) // 3
    i = 0
    while i < len(arr) - 1:
        j = i + 1
        while j < len(arr):
            candidate = target - (arr[i] + arr[j])
            if candidate in arr:
                print(arr[i], arr[j], candidate)
                del arr[j]
                del arr[i]
                try:
                    arr.remove(candidate)
                except ValueError:
                    pass
                i = max(i - 1, 0)
                break
            else:
                j += 1
        i += 1
    return arr


# --- Next Function Block ---


# --- Max Remaining Money After Purchase ---
def max_remaining_money(prices: list, money: int) -> int:
    """
    Given a list of prices and a total money amount, finds two prices whose sum is as close as
    possible to money (without exceeding it) and returns the remaining money (money - sum).
    If no pair is found, returns money.
    """
    val = 0
    flag = False
    i = 0
    while i < len(prices) - 1:
        j = i + 1
        while j < len(prices):
            current_sum = prices[i] + prices[j]
            if money - current_sum >= 0 and money - current_sum > val:
                val = money - current_sum
                flag = True
            j += 1
        i += 1
    return val if flag else money


# --- Next Function Block ---


# --- Ordered Match Count ---
def ordered_match_count(text1: str, text2: str) -> int:
    """
    Counts how many characters of text1 appear (in order) in text2.
    """
    count = 0
    i = 0
    j = 0
    while i < len(text1) and j < len(text2):
        if text1[i] in text2[j:]:
            count += 1
            j += 1
        i += 1
    return count


# --- Next Function Block ---


# --- Binary Ones Counts ---
def binary_ones_counts(n: int) -> list:
    """
    Returns a list where for each integer from 0 to n (inclusive) the element is the number
    of ones in its binary representation.
    """
    counts = []
    i = 0
    while i <= n:
        counts.append(bin(i)[2:].count("1"))
        i += 1
    return counts


# --- Next Function Block ---


# --- XOR Elements ---
def xor_elements(nums: list, k: int) -> list:
    """
    Returns a list containing the result of XORing each element of nums with k.
    """
    return [num ^ k for num in nums]


# --- Next Function Block ---


# --- Sum Elements with Index Having k Ones ---
def sum_elements_with_index_ones(nums: list, k: int) -> int:
    """
    Returns the sum of elements in nums for which the binary representation of the index
    contains exactly k ones.
    """
    total = 0
    i = 0
    while i < len(nums):
        if bin(i)[2:].count("1") == k:
            total += nums[i]
        i += 1
    return total


# --- Next Function Block ---


# --- Transpose Matrix ---
def transpose_matrix(matrix: list) -> list:
    """
    Returns the transpose of the given 2D matrix.
    """
    if not matrix:
        return []
    num_rows = len(matrix)
    num_cols = len(matrix[0])
    result = []
    j = 0
    while j < num_cols:
        temp = []
        i = 0
        while i < num_rows:
            temp.append(matrix[i][j])
            i += 1
        result.append(temp)
        j += 1
    return result


# --- Next Function Block ---


# --- Longest Palindrome Length ---
def longest_palindrome_length(s: str) -> int:
    """
    Returns the length of the longest palindrome that can be built using the letters in s.
    """
    counts = Counter(s)
    length = 0
    odd_found = False
    for count in counts.values():
        if count % 2 == 0:
            length += count
        else:
            length += count - 1
            odd_found = True
    return length + 1 if odd_found else length


# --- Next Function Block ---


# --- Rearrange Digits with Odd Priority ---
def rearrange_digits_with_odd_priority(num: str) -> str:
    """
    Rearranges the digits in num based on frequency.
    Even frequency digits are inserted evenly;
    the digit with the highest odd frequency is inserted in the middle.
    Returns the resulting string.
    
    (This function directly replicates the provided snippet logic.)
    """
    freq = dict(Counter(num))
    sorted_keys = sorted(freq.keys(), reverse=True)
    result = ""
    odd_block = ""
    max_odd = 0
    for key in sorted_keys:
        count_val = freq[key]
        if count_val % 2 == 0:
            mid = len(result) // 2
            result = result[:mid] + key * count_val + result[mid:]
        else:
            if count_val > max_odd:
                max_odd = count_val
                odd_block = key * count_val
            else:
                mid = len(result) // 2
                result = result[:mid] + key * (count_val - 1) + result[mid:]
    if odd_block:
        mid = len(result) // 2
        result = result[:mid] + odd_block + result[mid:]
    try:
        return str(int(result))
    except Exception:
        return result


# --- Next Function Block ---


# --- Remove Triplet with Sum ---
def remove_triplet_with_sum(arr: list) -> list:
    """
    Computes target = (sum(arr) // 3). Then, for every pair (arr[i], arr[j]),
    if (target - (arr[i] + arr[j])) exists in arr, prints the triplet and
    removes those three numbers from arr.
    Returns the modified list.
    
    Note: This function modifies the list in-place.
    """
    target = functools.reduce(lambda x, y: x + y, arr) // 3
    i = 0
    while i < len(arr) - 1:
        j = i + 1
        while j < len(arr):
            candidate = target - (arr[i] + arr[j])
            if candidate in arr:
                print(arr[i], arr[j], candidate)
                del arr[j]
                del arr[i]
                try:
                    arr.remove(candidate)
                except ValueError:
                    pass
                i = max(i - 1, 0)
                break
            else:
                j += 1
        i += 1
    return arr


# --- Next Function Block ---


# --- Max Remaining Money After Purchase ---
def max_remaining_money(prices: list, money: int) -> int:
    """
    Given a list of prices and a total amount of money, finds two prices such that
    their sum is as close as possible to money without exceeding it.
    Returns the remaining money (money - sum) if a valid pair is found,
    otherwise returns money.
    """
    val = 0
    flag = False
    i = 0
    while i < len(prices) - 1:
        j = i + 1
        while j < len(prices):
            current_sum = prices[i] + prices[j]
            if money - current_sum >= 0 and money - current_sum > val:
                val = money - current_sum
                flag = True
            j += 1
        i += 1
    return val if flag else money


# --- Next Function Block ---


# --- Ordered Match Count ---
def ordered_match_count(text1: str, text2: str) -> int:
    """
    Returns the count of characters in text1 that appear (in order) in text2.
    """
    count = 0
    i = 0
    j = 0
    while i < len(text1) and j < len(text2):
        if text1[i] in text2[j:]:
            count += 1
            j += 1
        i += 1
    return count


# --- Next Function Block ---


# --- Binary Ones Counts ---
def binary_ones_counts(n: int) -> list:
    """
    Returns a list of counts of '1's in the binary representation for each integer from 0 to n (inclusive).
    """
    counts = []
    i = 0
    while i <= n:
        counts.append(bin(i)[2:].count("1"))
        i += 1
    return counts


# --- Next Function Block ---


# --- XOR Elements ---
def xor_elements(nums: list, k: int) -> list:
    """
    Returns a list where each element is the result of XORing the corresponding element in nums with k.
    """
    return [num ^ k for num in nums]


# --- Next Function Block ---


# --- Sum Elements with Index Having k Ones ---
def sum_elements_with_index_ones(nums: list, k: int) -> int:
    """
    Returns the sum of elements in nums whose index (in binary) contains exactly k ones.
    """
    total = 0
    i = 0
    while i < len(nums):
        if bin(i)[2:].count("1") == k:
            total += nums[i]
        i += 1
    return total


# --- Next Function Block ---


# --- Transpose Matrix ---
def transpose_matrix(matrix: list) -> list:
    """
    Returns the transpose of the given 2D matrix.
    """
    if not matrix:
        return []
    num_rows = len(matrix)
    num_cols = len(matrix[0])
    result = []
    j = 0
    while j < num_cols:
        temp = []
        i = 0
        while i < num_rows:
            temp.append(matrix[i][j])
            i += 1
        result.append(temp)
        j += 1
    return result


# --- Next Function Block ---


# --- Longest Palindrome Length ---
def longest_palindrome_length(s: str) -> int:
    """
    Returns the length of the longest palindrome that can be built with the letters in s.
    """
    counts = Counter(s)
    length = 0
    odd_found = False
    for count in counts.values():
        if count % 2 == 0:
            length += count
        else:
            length += count - 1
            odd_found = True
    return length + 1 if odd_found else length


# --- Next Function Block ---


# --- Rearrange Digits with Odd Priority ---
def rearrange_digits_with_odd_priority(num: str) -> str:
    """
    Rearranges the digits in num based on frequency.
    Even frequency digits are inserted evenly; the odd-frequency digit with the highest count
    is inserted in the middle.
    Returns the resulting string.
    
    (This function replicates the provided snippet logic.)
    """
    freq = dict(Counter(num))
    sorted_keys = sorted(freq.keys(), reverse=True)
    result = ""
    odd_block = ""
    max_odd = 0
    for key in sorted_keys:
        count_val = freq[key]
        if count_val % 2 == 0:
            mid = len(result) // 2
            result = result[:mid] + key * count_val + result[mid:]
        else:
            if count_val > max_odd:
                max_odd = count_val
                odd_block = key * count_val
            else:
                mid = len(result) // 2
                result = result[:mid] + key * (count_val - 1) + result[mid:]
    if odd_block:
        mid = len(result) // 2
        result = result[:mid] + odd_block + result[mid:]
    try:
        return str(int(result))
    except Exception:
        return result


# --- Next Function Block ---


# --- Remove Triplet with Sum ---
def remove_triplet_with_sum(arr: list) -> list:
    """
    Computes target = (sum(arr) // 3), then iterates over pairs (arr[i], arr[j]).
    If (target - (arr[i] + arr[j])) exists in arr, prints the triplet and removes these three elements.
    Returns the modified arr.
    
    Note: This function modifies arr in-place.
    """
    target = functools.reduce(lambda x, y: x + y, arr) // 3
    i = 0
    while i < len(arr) - 1:
        j = i + 1
        while j < len(arr):
            candidate = target - (arr[i] + arr[j])
            if candidate in arr:
                print(arr[i], arr[j], candidate)
                del arr[j]
                del arr[i]
                try:
                    arr.remove(candidate)
                except ValueError:
                    pass
                i = max(i - 1, 0)
                break
            else:
                j += 1
        i += 1
    return arr


# --- Next Function Block ---


# --- Max Remaining Money After Purchase ---
def max_remaining_money(prices: list, money: int) -> int:
    """
    Given a list of prices and total money, finds a pair of prices whose sum is as close
    as possible to money (without exceeding it). Returns the remaining money (money - pair sum)
    if such a pair exists; otherwise, returns money.
    """
    val = 0
    flag = False
    i = 0
    while i < len(prices) - 1:
        j = i + 1
        while j < len(prices):
            current_sum = prices[i] + prices[j]
            if money - current_sum >= 0 and money - current_sum > val:
                val = money - current_sum
                flag = True
            j += 1
        i += 1
    return val if flag else money


# --- Next Function Block ---


# --- Ordered Match Count ---
def ordered_match_count(text1: str, text2: str) -> int:
    """
    Returns the count of characters in text1 that appear (in order) in text2.
    """
    count = 0
    i = 0
    j = 0
    while i < len(text1) and j < len(text2):
        if text1[i] in text2[j:]:
            count += 1
            j += 1
        i += 1
    return count


# --- Next Function Block ---


# --- Binary Ones Counts ---
def binary_ones_counts(n: int) -> list:
    """
    For every integer from 0 to n (inclusive), returns a list with the count of '1's
    in its binary representation.
    """
    counts = []
    i = 0
    while i <= n:
        counts.append(bin(i)[2:].count("1"))
        i += 1
    return counts


# --- Next Function Block ---


# --- XOR Elements ---
def xor_elements(nums: list, k: int) -> list:
    """
    Returns a list where each element of nums is XORed with k.
    """
    return [num ^ k for num in nums]


# --- Next Function Block ---


# --- Sum Elements with Index Having k Ones ---
def sum_elements_with_index_ones(nums: list, k: int) -> int:
    """
    Sums the elements of nums for which the binary representation of their index
    contains exactly k ones.
    """
    total = 0
    i = 0
    while i < len(nums):
        if bin(i)[2:].count("1") == k:
            total += nums[i]
        i += 1
    return total


# --- Next Function Block ---


# --- Transpose Matrix ---
def transpose_matrix(matrix: list) -> list:
    """
    Returns the transpose of a 2D matrix.
    """
    if not matrix:
        return []
    num_rows = len(matrix)
    num_cols = len(matrix[0])
    result = []
    j = 0
    while j < num_cols:
        temp = []
        i = 0
        while i < num_rows:
            temp.append(matrix[i][j])
            i += 1
        result.append(temp)
        j += 1
    return result


# --- Next Function Block ---


# --- Longest Palindrome Length ---
def longest_palindrome_length(s: str) -> int:
    """
    Returns the length of the longest palindrome that can be built with the letters in s.
    """
    counts = Counter(s)
    length = 0
    odd_found = False
    for count in counts.values():
        if count % 2 == 0:
            length += count
        else:
            length += count - 1
            odd_found = True
    return length + 1 if odd_found else length


# --- Next Function Block ---


# --- Rearrange Digits with Odd Priority ---
def rearrange_digits_with_odd_priority(num: str) -> str:
    """
    Rearranges the digits of num based on their frequency:
      - Even frequency digits are inserted evenly.
      - The odd frequency digit with the highest count is inserted in the middle.
    Returns the resulting string.
    
    (This function replicates the provided snippet logic.)
    """
    freq = dict(Counter(num))
    sorted_keys = sorted(freq.keys(), reverse=True)
    result = ""
    odd_block = ""
    max_odd = 0
    for key in sorted_keys:
        count_val = freq[key]
        if count_val % 2 == 0:
            mid = len(result) // 2
            result = result[:mid] + key * count_val + result[mid:]
        else:
            if count_val > max_odd:
                max_odd = count_val
                odd_block = key * count_val
            else:
                mid = len(result) // 2
                result = result[:mid] + key * (count_val - 1) + result[mid:]
    if odd_block:
        mid = len(result) // 2
        result = result[:mid] + odd_block + result[mid:]
    try:
        return str(int(result))
    except Exception:
        return result


# --- Next Function Block ---




# --------------------------
# 1. Restaurant with minimum index sum
def find_restaurant_with_min_index_sum(list1: list, list2: list) -> str:
    """
    Given two lists of restaurant names, returns the restaurant name that appears in both
    with the smallest sum of its indices. If multiple restaurants have the same minimal
    index sum, returns one of them.
    
    Example:
      list1 = ["Shogun","Tapioca Express","Burger King","KFC"]
      list2 = ["Piatti","The Grill at Torrey Pines","Hungry Hunter Steakhouse","Shogun"]
      Returns "Shogun"
    """
    # Ensure list1 is the shorter list.
    if len(list1) > len(list2):
        list1, list2 = list2, list1
    best_sum = len(list1) + len(list2)  # Initialize with maximum possible sum.
    best_restaurant = ""
    for i, rest in enumerate(list1):
        if rest in list2:
            index_sum = i + list2.index(rest)
            if index_sum < best_sum:
                best_sum = index_sum
                best_restaurant = rest
    return best_restaurant


# --- Next Function Block ---


# --------------------------
# 2. Remove k consecutive digits to yield minimum result
def remove_k_digits_min_result(num: str, k: int) -> str:
    """
    Given a number represented as a string and an integer k, removes k consecutive digits
    from num at every possible starting position, and returns the minimum resulting number
    (as a string). If no removal is possible, returns "0".
    
    Example:
      num = "10", k = 2 → possible removals: removing the only two digits yields "", so return "0"
    """
    results = []
    # For each valid starting index, remove k digits.
    for i in range(len(num) - k + 1):
        candidate = num[:i] + num[i+k:]
        if candidate != "":
            results.append(int(candidate))
    if results:
        return str(min(results))
    else:
        return "0"


# --- Next Function Block ---


# --------------------------
# 3. Remove an element if it is less than a later element
def remove_if_less(nums: list) -> list:
    """
    Iterates over the list and, if an element is found to be less than a later element,
    deletes both elements and continues. (The logic is ambiguous; this function follows
    the provided snippet exactly.)
    
    Example:
      Input: [2,3,4,4,4]
      (Behavior depends on iteration order and deletion.)
    """
    i = 0
    while i < len(nums) - 1:
        j = i + 1
        while j < len(nums):
            if nums[i] < nums[j]:
                del nums[j]
                del nums[i]
                i = max(i - 1, 0)
                break
            else:
                j += 1
        i += 1
    return nums


# --- Next Function Block ---


# --------------------------
# 4. Frequency difference in a list
def frequency_difference(nums: list) -> int:
    """
    Counts the frequency of each element in nums and then computes the difference between
    the frequency of the most common element and the frequencies of the others.
    Specifically, it subtracts, in order (from the most frequent downwards), all frequencies
    from the first frequency.
    
    Example:
      Input: [2,3,4,4,4]
      Frequencies (sorted descending): [3, 1, 1]
      Returns: 3 - 1 - 1 = 1
    """
    freq = dict(sorted(Counter(nums).items(), key=lambda item: item[1], reverse=True))
    diff = None
    for key in freq:
        if diff is None:
            diff = freq[key]
        else:
            diff -= freq[key]
    return diff if diff is not None else 0


# --- Next Function Block ---


# --------------------------
# 5. Remove a triplet (three numbers whose sum equals a target) from an array
def remove_triplet_by_sum(arr: list) -> list:
    """
    Given a list arr, computes total sum divided by 3 (target sum) and then, for each pair
    (arr[i], arr[j]), if target - (arr[i] + arr[j]) exists in arr, removes these three elements.
    Returns the modified array.
    
    Note: This snippet is ambiguous and destructive.
    """
    total = functools.reduce(lambda x, y: x + y, arr) // 3
    i = 0
    while i < len(arr) - 1:
        j = i + 1
        while j < len(arr):
            candidate = total - (arr[i] + arr[j])
            if candidate in arr:
                # Remove one occurrence of arr[j], arr[i] and candidate.
                # Remove arr[j] first (since i < j).
                del arr[j]
                del arr[i]
                arr.remove(candidate)
                i = max(i - 1, 0)
                break
            else:
                j += 1
        i += 1
    return arr


# --- Next Function Block ---


# --------------------------
# 6. Maximum remaining money after buying two boxes from prices
def max_remaining_money(prices: list, money: int) -> int:
    """
    Given a list of prices and a total amount of money, finds a pair of boxes such that
    money minus the sum of the pair is nonnegative and maximizes the remaining money.
    Returns the maximum remaining money if any pair qualifies; otherwise, returns money.
    """
    best = -1
    found = False
    for i in range(len(prices) - 1):
        for j in range(i + 1, len(prices)):
            rem = money - (prices[i] + prices[j])
            if rem >= 0 and rem > best:
                best = rem
                found = True
    return best if found else money


# --- Next Function Block ---


# --------------------------
# 7. Count ordered matches between two texts
def count_ordered_matches(text1: str, text2: str) -> int:
    """
    Counts the number of characters in text1 that appear in text2 in order.
    For each character in text1, if it appears in the remaining part of text2, increments count.
    """
    count = 0
    i = 0
    j = 0
    while i < len(text1) and j < len(text2):
        if text1[i] in text2[j:]:
            count += 1
            j += 1  # Move j to next position for subsequent matches.
        i += 1
    return count


# --- Next Function Block ---


# --------------------------
# 8. Count number of 1's in binary representations for 0 to n
def count_ones_in_binaries(n: int) -> list:
    """
    Returns a list of counts of '1's in the binary representation of every integer from 0 to n.
    """
    result = []
    for i in range(n + 1):
        result.append(bin(i)[2:].count("1"))
    return result


# --- Next Function Block ---


# --------------------------
# 9. XOR each number in a list with k
def xor_with_k(nums: list, k: int) -> list:
    """
    Returns a list where each element in nums is XORed with k.
    """
    return [x ^ k for x in nums]


# --- Next Function Block ---


# --------------------------
# 10. Sum numbers at indices where binary representation of index has exactly k ones
def sum_numbers_with_k_ones(nums: list, k: int) -> int:
    """
    Given a list of numbers, sums those numbers at indices where the binary representation
    of the index (starting at 0) has exactly k ones.
    """
    total = 0
    for i in range(len(nums)):
        if bin(i)[2:].count("1") == k:
            total += nums[i]
    return total


# --- Next Function Block ---


# --------------------------
# 11. Transpose a matrix
def transpose_matrix(matrix: list) -> list:
    """
    Returns the transpose of the given matrix.
    """
    if not matrix or not matrix[0]:
        return []
    result = []
    for j in range(len(matrix[0])):
        col = []
        for i in range(len(matrix)):
            col.append(matrix[i][j])
        result.append(col)
    return result


# --- Next Function Block ---


# --------------------------
# 12. Longest Palindrome Length (from letter frequencies)
def longest_palindrome_length(s: str) -> int:
    """
    Given a string s, returns the length of the longest palindrome that can be built with its letters.
    """
    freq = Counter(s)
    length = 0
    odd_found = False
    for count in freq.values():
        if count % 2 == 0:
            length += count
        else:
            length += count - 1
            odd_found = True
    if odd_found:
        length += 1
    return length


# --- Next Function Block ---


# --------------------------
# 13. Reconstruct a number from its digit frequencies
def reconstruct_number_from_frequencies(num_str: str) -> str:
    """
    Given a string of digits, constructs a new number based on the frequencies of each digit.
    This snippet’s logic is ambiguous, but here we:
      - Count the frequencies of digits,
      - Sort digits in descending order (by digit value),
      - Then form a number by concatenating each digit repeated by its frequency.
    Returns the constructed number as a string.
    """
    freq = dict(Counter(num_str))
    # Sort digits descending (as strings; convert to int for numeric order)
    sorted_digits = sorted(freq.items(), key=lambda item: int(item[0]), reverse=True)
    result = ""
    for digit, count in sorted_digits:
        result += digit * count
    return result


# --- Next Function Block ---


# --------------------------
# 14. Next Greater Element for each element in nums1 based on nums2
def next_greater_element(nums1: list, nums2: list) -> list:
    """
    For each element in nums1, finds the first element in nums2 (starting from the index where the element
    appears) that is greater than that element. If no such element exists, returns -1 for that element.
    
    Example:
      nums1 = [2,4]
      nums2 = [1,2,3,4]
      Returns: [3, -1]
    """
    result = []
    for num in nums1:
        try:
            start_index = nums2.index(num)
        except ValueError:
            result.append(-1)
            continue
        found = -1
        for val in nums2[start_index:]:
            if val > num:
                found = val
                break
        result.append(found)
    return result


# --- Next Function Block ---


# --------------------------
# 15. Transform binary representation of n by flipping 1's and count operations
def transform_binary_and_count(n: int) -> int:
    """
    Converts n to its binary representation (as a string), then for each bit from left to right,
    if the bit is '1', changes it to '0' and sets all following bits to '1'. Increments a counter
    each time a bit is flipped. Returns the total count of flips.
    
    Example:
      n = 6 (binary "110")
      Transformation:
         i=0: flip first '1' → becomes "0" + "11" = "011"
         i=1: flip second '1' → becomes "0" + "0" + "1" = "001"
         i=2: flip last '1' → becomes "000"
      Total flips = 3
    """
    stg = str(bin(n))[2:]
    count = 0
    i = 0
    while i < len(stg):
        if stg[i] == "1":
            stg = stg[:i] + "0" + "1" * (len(stg) - i - 1)
            count += 1
        i += 1
    return count


# --- Next Function Block ---


# --------------------------
# 16. Find duplicates and missing numbers in a list
def find_duplicates_and_missing(nums: list) -> list:
    """
    Given a sorted list nums, returns a list containing:
      - Each element that appears more than once (once only),
      - And any numbers (from 1 to len(nums)) that are missing.
    """
    duplicates = []
    for num in nums:
        if nums.count(num) > 1 and num not in duplicates:
            duplicates.append(num)
    missing = []
    for i in range(1, len(nums) + 1):
        if i not in nums:
            missing.append(i)
    return duplicates + missing


# --- Next Function Block ---


# --------------------------
# 17. Count subarrays with at least three unique elements
def count_subarrays_with_at_least_three_uniques(nums: list) -> int:
    """
    For each starting index in nums, checks if the subarray contains at least 3 unique elements.
    Returns the count of starting indices for which such a subarray exists.
    
    Note: The snippet stops when a subarray with at least 3 uniques is found.
    """
    count = 0
    for i in range(len(nums)):
        seen = set()
        for j in range(i, len(nums)):
            seen.add(nums[j])
            if len(seen) >= 3:
                count += 1
                break
    return count


# --- Next Function Block ---



# ------------------------------------------------------------------
# Snippet A: Find the common restaurant with the minimum index sum.
def min_index_sum_common(list1: list, list2: list) -> str:
    """
    Given two lists of strings (e.g., restaurant names), returns the common name with the minimum index sum.
    If the lists are of different lengths, the function swaps them so that list1 is always the shorter.
    """
    # Ensure list1 is the shorter list.
    if len(list1) > len(list2):
        list1, list2 = list2, list1
    res = ""
    min_sum = len(list1) + len(list2)  # initialize with a large value
    i = 0
    while i < len(list1):
        if list1[i] in list2:
            index_sum = i + list2.index(list1[i])
            if index_sum < min_sum:
                min_sum = index_sum
                res = list1[i]
        i += 1
    return res


# --- Next Function Block ---


# ------------------------------------------------------------------
# Snippet B: Remove a contiguous block of k digits from a number string and return the minimum result.
def remove_block_and_min(num: str, k: int) -> str:
    """
    Given a number as a string and an integer k, removes k consecutive characters (if possible)
    at every possible starting index, converts the result to an integer, and returns the smallest value
    (as a string). If no block removal is possible, returns "0".
    """
    results = []
    i = 0
    # Only consider positions where removal of k digits is possible.
    while i <= len(num) - k:
        try:
            candidate = int(num[:i] + num[i+k:])
            results.append(candidate)
        except Exception:
            pass
        i += 1
    return str(min(results)) if results else "0"


# --- Next Function Block ---


# ------------------------------------------------------------------
# Snippet C: Remove pairs from a list if the earlier element is less than a later one.
def remove_increasing_pairs(nums: list) -> list:
    """
    Iterates over a list of numbers and, for each pair (nums[i], nums[j]) where i < j, 
    if nums[i] < nums[j], removes both elements.
    Returns the resulting list.
    (Note: This destructive removal may change the order; it’s one interpretation of the snippet.)
    """
    i = 0
    # Work on a copy so as not to affect the caller.
    nums = nums.copy()
    while i < len(nums) - 1:
        j = i + 1
        while j < len(nums):
            if nums[i] < nums[j]:
                del nums[j]
                del nums[i]
                i = max(i - 1, 0)
                break
            else:
                j += 1
        i += 1
    return nums


# --- Next Function Block ---


# ------------------------------------------------------------------
# Snippet D: Frequency difference sum.
def frequency_difference_sum(nums: list) -> int:
    """
    Given a list of numbers, builds a frequency dictionary and computes a sum as follows:
    - It takes the frequency of the first (most frequent, as determined by sorting by frequency descending)
      and subtracts the frequencies of the other elements.
    Returns the resulting sum.
    """
    freq = Counter(nums)
    # Sort frequencies in descending order by frequency value.
    sorted_freq = dict(reversed(sorted(freq.items(), key=lambda item: item[1])))
    diff = None
    for key in sorted_freq:
        if diff is None:
            diff = sorted_freq[key]
        else:
            diff -= sorted_freq[key]
    return diff


# --- Next Function Block ---


# ------------------------------------------------------------------
# Snippet E: Remove triplets from a list where three numbers sum to target.
def remove_triplets_with_target_sum(arr: list) -> list:
    """
    Given a list of numbers, computes the target as the integer division of the sum of the list by 3.
    Then, iterates over pairs in the list and, if the third number needed to reach the target exists in the list,
    removes all three numbers.
    Returns the modified list.
    
    Note: This snippet’s logic is ambiguous; this is one interpretation.
    """
    if not arr:
        return arr
    target = functools.reduce(lambda x, y: x + y, arr) // 3
    i = 0
    arr = arr.copy()
    while i < len(arr) - 1:
        j = i + 1
        while j < len(arr):
            needed = target - (arr[i] + arr[j])
            if needed in arr:
                # Print for debugging
                # print(arr[i], arr[j], needed)
                # Remove one occurrence of needed, and remove arr[i] and arr[j]
                arr.remove(needed)
                del arr[j]
                del arr[i]
                i = max(i - 1, 0)
                break
            else:
                j += 1
        i += 1
    return arr


# --- Next Function Block ---


# ------------------------------------------------------------------
# Snippet F: Maximum remaining money after buying two items.
def max_remaining_money(prices: list, money: int) -> int:
    """
    Given a list of prices and an available money amount,
    finds the pair of items that maximizes the remaining money after purchase.
    Returns the maximum remaining money if a pair can be bought; otherwise, returns the original money.
    """
    max_remaining = 0
    flag = False
    n = len(prices)
    for i in range(n - 1):
        for j in range(i + 1, n):
            remaining = money - (prices[i] + prices[j])
            if remaining >= 0 and remaining > max_remaining:
                max_remaining = remaining
                flag = True
    return max_remaining if flag else money


# --- Next Function Block ---


# ------------------------------------------------------------------
# Snippet G: Count sequential matches between two strings.
def count_sequential_matches(text1: str, text2: str) -> int:
    """
    Iterates over text1, and for each character, checks if it appears in text2 starting from an increasing index.
    Returns the count of such sequential matches.
    """
    count = 0
    i = 0
    j = 0
    while i < len(text1) and j < len(text2):
        if text1[i] in text2[j:]:
            count += 1
            # Move j to the next character after the found one.
            j += 1
        i += 1
    return count


# --- Next Function Block ---


# ------------------------------------------------------------------
# Snippet H: Count ones in binary representations for numbers 0 to n.
def count_ones_in_binary_range(n: int) -> list:
    """
    For each integer from 0 to n (inclusive), counts the number of '1's in its binary representation.
    Returns a list of counts.
    """
    result = []
    for i in range(n+1):
        result.append(bin(i)[2:].count('1'))
    return result


# --- Next Function Block ---


# ------------------------------------------------------------------
# Snippet I: Compute bitwise XOR of each element in nums with k.
def xor_with_k(nums: list, k: int) -> list:
    """
    Given a list of integers and an integer k, returns a new list where each element is XOR-ed with k.
    """
    return [x ^ k for x in nums]


# --- Next Function Block ---


# ------------------------------------------------------------------
# Snippet J: Sum values at indices where binary representation of index has exactly k ones.
def sum_by_index_bitcount(nums: list, k: int) -> int:
    """
    For each index i in the list nums, if the binary representation of i (as a string) contains exactly k ones,
    adds nums[i] to a running total.
    Returns the total sum.
    """
    total = 0
    for i in range(len(nums)):
        if bin(i)[2:].count("1") == k:
            total += nums[i]
    return total


# --- Next Function Block ---


# ------------------------------------------------------------------
# Snippet K: Transpose a matrix.
def transpose_matrix(matrix: list) -> list:
    """
    Given a 2D matrix, returns its transpose.
    (Assumes matrix is non-empty and rectangular.)
    """
    if not matrix:
        return []
    rows, cols = len(matrix), len(matrix[0])
    transposed = []
    for j in range(cols):
        new_row = []
        for i in range(rows):
            new_row.append(matrix[i][j])
        transposed.append(new_row)
    return transposed


# --- Next Function Block ---


# ------------------------------------------------------------------
# Snippet L: Compute the length of the longest palindrome that can be built from characters in a string.
def longest_palindrome_length(s: str) -> int:
    """
    Given a string s, returns the length of the longest palindrome that can be built 
    with those letters.
    """
    freq = Counter(s)
    length = 0
    odd_found = False
    for count in freq.values():
        if count % 2 == 0:
            length += count
        else:
            length += count - 1
            odd_found = True
    return length + 1 if odd_found else length


# --- Next Function Block ---


# ------------------------------------------------------------------
# Snippet M: Build the largest palindrome from the digits of a number.
def largest_palindrome_from_digits(num: str) -> str:
    """
    Given a number as a string, returns the largest palindrome that can be formed using its digits.
    If multiple palindromes are possible, returns one of them.
    This implementation uses a greedy approach.
    """
    freq = Counter(num)
    left = []
    middle = ""
    # Process digits in descending order.
    for digit in sorted(freq.keys(), reverse=True):
        count = freq[digit]
        # Use all even counts.
        left.extend([digit] * (count // 2))
        # If odd and we haven't chosen a middle, choose this digit.
        if count % 2 == 1 and middle == "":
            middle = digit
    right = left.copy()
    right.reverse()
    return "".join(left) + middle + "".join(right)


# --- Next Function Block ---


# ------------------------------------------------------------------
# Additional Snippet: Count operations to change a binary string to a target binary string
# by flipping differing bits.
def bit_flip_operations(start: int, goal: int, pad_length: int = 30) -> int:
    """
    Converts start and goal into binary strings (padded to pad_length),
    then counts the number of bit positions where they differ.
    Returns the number of operations needed (one per differing bit).
    """
    bin_start = str(0) * (pad_length - len(bin(start)[2:])) + bin(start)[2:]
    bin_goal  = str(0) * (pad_length - len(bin(goal)[2:])) + bin(goal)[2:]
    count = 0
    for i in range(pad_length):
        if bin_start[i] != bin_goal[i]:
            count += 1
    return count


# --- Next Function Block ---


# ------------------------------------------------------------------
# Additional Snippet: Rearrange list of numbers by interleaving even and odd numbers.
def interleave_even_odd(nums: list) -> list:
    """
    Separates even and odd numbers from nums, sorts even in ascending order and odd in descending order,
    then interleaves them. If one list is longer, appends the remainder.
    """
    evens = sorted([x for x in nums if x % 2 == 0])
    odds  = sorted([x for x in nums if x % 2 != 0], reverse=True)
    result = []
    i = 0
    while i < len(evens) and i < len(odds):
        result.append(evens[i])
        result.append(odds[i])
        i += 1
    # Append remaining elements
    result.extend(evens[i:])
    result.extend(odds[i:])
    return result


# --- Next Function Block ---




# -----------------------------------------------------
# 1. Common Restaurant with Minimum Index Sum
def min_index_sum_common(list1: list, list2: list) -> str:
    """
    Given two lists of strings (e.g., restaurant names), returns the common name
    with the smallest index sum. If list lengths differ, the function uses the shorter list for iteration.
    
    Example:
      list1 = ["Shogun", "Tapioca Express", "Burger King", "KFC"]
      list2 = ["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"]
      returns "Shogun" because its index sum is 0 + 3 = 3.
    """
    # Ensure list1 is the shorter list.
    if len(list1) > len(list2):
        list1, list2 = list2, list1
    res = ""
    min_sum = len(list1) + len(list2)  # Initialize with a large value.
    for i in range(len(list1)):
        if list1[i] in list2:
            index_sum = i + list2.index(list1[i])
            if index_sum < min_sum:
                min_sum = index_sum
                res = list1[i]
    return res


# --- Next Function Block ---


# -----------------------------------------------------
# 2. Remove a Block of k Digits From a Number String and Return the Minimum Result
def remove_block_and_min(num: str, k: int) -> str:
    """
    Given a number represented as a string and an integer k, this function
    removes k consecutive characters from every possible starting index and
    returns the smallest resulting integer (as a string). If no removal is possible,
    returns "0".
    
    Example:
      num = "10", k = 2
      Possible removal: Removing the only 2 digits gives an empty string → interpreted as 0.
    """
    results = []
    for i in range(len(num) - k + 1):
        try:
            candidate = int(num[:i] + num[i+k:])
            results.append(candidate)
        except Exception:
            pass
    return str(min(results)) if results else "0"


# --- Next Function Block ---


# -----------------------------------------------------
# 3. Remove Increasing Pairs from a List
def remove_increasing_pairs(nums: list) -> list:
    """
    Iterates over the list and removes pairs (by deleting both elements)
    whenever an earlier element is less than a later one.
    This function works destructively and returns the resulting list.
    
    Example:
      nums = [2,3,4,4,4]
      (One interpretation: if a pair (a, b) with a < b is found, remove both.)
    """
    nums = nums.copy()  # Work on a copy.
    i = 0
    while i < len(nums) - 1:
        j = i + 1
        while j < len(nums):
            if nums[i] < nums[j]:
                del nums[j]
                del nums[i]
                i = max(i - 1, 0)
                break
            else:
                j += 1
        i += 1
    return nums


# --- Next Function Block ---


# -----------------------------------------------------
# 4. Frequency Difference Sum
def frequency_difference_sum(nums: list) -> int:
    """
    Builds a frequency dictionary for the elements in nums, then subtracts
    the frequencies of all but the first (largest frequency) element.
    
    Example:
      nums = [2,3,4,4,4]
      Suppose frequency sorted descending by frequency gives: {4:3, 2:1, 3:1}
      The function computes 3 - 1 - 1 = 1.
    """
    freq = Counter(nums)
    # Sort dictionary items in descending order by frequency.
    sorted_freq = dict(reversed(sorted(freq.items(), key=lambda item: item[1])))
    diff = None
    for key in sorted_freq:
        if diff is None:
            diff = sorted_freq[key]
        else:
            diff -= sorted_freq[key]
    return diff


# --- Next Function Block ---


# -----------------------------------------------------
# 5. Remove Triplets with Target Sum
def remove_triplets_with_target_sum(arr: list) -> list:
    """
    Calculates target = total sum of arr // 3, then iterates over all pairs in arr.
    If for a pair (arr[i], arr[j]), the value needed to reach target exists in arr,
    removes one occurrence of each of arr[i], arr[j], and that third number.
    Returns the modified list.
    
    Note: The logic here is based on one interpretation of the snippet and may be ambiguous.
    """
    if not arr:
        return arr
    total = functools.reduce(lambda x, y: x + y, arr)
    target = total // 3
    arr = arr.copy()
    i = 0
    while i < len(arr) - 1:
        j = i + 1
        while j < len(arr):
            needed = target - (arr[i] + arr[j])
            if needed in arr:
                # Remove one occurrence of each number.
                try:
                    arr.remove(needed)
                    del arr[j]
                    del arr[i]
                    i = max(i - 1, 0)
                    break
                except ValueError:
                    j += 1
            else:
                j += 1
        i += 1
    return arr


# --- Next Function Block ---


# -----------------------------------------------------
# 6. Maximum Remaining Money after Buying Two Items
def max_remaining_money(prices: list, money: int) -> int:
    """
    Given a list of prices and an amount of money, finds the pair of prices
    such that the remaining money after purchase is maximized (but nonnegative).
    Returns the maximum remaining money; if no pair can be bought, returns the original money.
    
    Example:
      prices = [3,2,3], money = 3.
      The only possible pair might cost more than money; then return money.
    """
    max_rem = 0
    flag = False
    n = len(prices)
    for i in range(n - 1):
        for j in range(i + 1, n):
            cost = prices[i] + prices[j]
            if money - cost >= 0 and money - cost > max_rem:
                max_rem = money - cost
                flag = True
    return max_rem if flag else money


# --- Next Function Block ---


# -----------------------------------------------------
# 7. Count Sequential Matches between Two Strings
def count_sequential_matches(text1: str, text2: str) -> int:
    """
    Iterates over text1; for each character, if that character appears in text2 starting
    from a moving index, increments a counter.
    
    Example:
      text1 = "ezupkr", text2 = "ubmrapg" might count how many characters in text1
      appear sequentially in text2.
    """
    count = 0
    i = 0
    j = 0
    while i < len(text1) and j < len(text2):
        if text1[i] in text2[j:]:
            count += 1
            j += 1  # Move j forward for the next match.
        i += 1
    return count


# --- Next Function Block ---


# -----------------------------------------------------
# 8. Count Ones in Binary Representations for 0 to n
def count_ones_in_binary_range(n: int) -> list:
    """
    Returns a list where each element is the count of '1's in the binary representation
    (without the '0b' prefix) of the numbers from 0 to n (inclusive).
    """
    result = []
    for i in range(n+1):
        ones = bin(i)[2:].count('1')
        result.append(ones)
    return result


# --- Next Function Block ---


# -----------------------------------------------------
# 9. XOR Each Element in a List with k
def xor_with_k(nums: list, k: int) -> list:
    """
    Returns a new list where each element of nums is XOR-ed with k.
    
    Example:
      nums = [7,12,9,8,9,15], k = 4 → returns list of [7^4, 12^4, ...]
    """
    return [x ^ k for x in nums]


# --- Next Function Block ---


# -----------------------------------------------------
# 10. Sum Values at Indices with Exactly k Ones in Binary Representation
def sum_by_index_bitcount(nums: list, k: int) -> int:
    """
    For each index i in nums, if the binary representation of i (without the '0b' prefix)
    contains exactly k '1's, adds nums[i] to a total sum.
    Returns the total sum.
    """
    total = 0
    for i in range(len(nums)):
        if bin(i)[2:].count("1") == k:
            total += nums[i]
    return total


# --- Next Function Block ---


# -----------------------------------------------------
# 11. Transpose a Matrix
def transpose_matrix(matrix: list) -> list:
    """
    Returns the transpose of the given 2D matrix.
    Assumes matrix is non-empty and rectangular.
    """
    if not matrix:
        return []
    rows = len(matrix)
    cols = len(matrix[0])
    transposed = []
    for j in range(cols):
        new_row = []
        for i in range(rows):
            new_row.append(matrix[i][j])
        transposed.append(new_row)
    return transposed


# --- Next Function Block ---


# -----------------------------------------------------
# 12. Longest Palindrome Length from Characters in a String
def longest_palindrome_length(s: str) -> int:
    """
    Given a string s, returns the length of the longest palindrome that can be built
    using its letters. Letters can be rearranged. At most one odd-count letter may be used.
    
    Example:
      s = "abbaca" → can form "aba" or "abba", so returns 5 (since "abcba" is not possible here,
      typical solution: count even frequencies plus one if any odd exists).
    """
    freq = Counter(s)
    length = 0
    odd_found = False
    for count in freq.values():
        if count % 2 == 0:
            length += count
        else:
            length += count - 1
            odd_found = True
    return length + 1 if odd_found else length


# --- Next Function Block ---


# -----------------------------------------------------
# 13. Largest Palindrome from Digits of a Number (Greedy Construction)
def largest_palindrome_from_digits(num_str: str) -> str:
    """
    Given a number as a string, attempts to form the largest palindrome from its digits.
    This implementation uses a greedy approach by counting digit frequencies.
    
    Example:
      num_str = "444947137"
      (One possible output is a palindrome constructed from these digits.)
    """
    freq = Counter(num_str)
    left = []
    middle = ""
    # Process digits in descending order.
    for digit in sorted(freq.keys(), reverse=True):
        count = freq[digit]
        left.extend([digit] * (count // 2))
        if count % 2 == 1 and middle == "":
            middle = digit
    right = left.copy()
    right.reverse()
    return "".join(left) + middle + "".join(right)


# --- Next Function Block ---


# -----------------------------------------------------
# 14. Bit Flip Operations: Count differing bits between padded binary representations.
def bit_flip_operations(start: int, goal: int, pad_length: int = 30) -> int:
    """
    Converts start and goal into binary strings padded to pad_length, then counts the number of positions
    at which they differ.
    """
    bin_start = str(0) * (pad_length - len(bin(start)[2:])) + bin(start)[2:]
    bin_goal  = str(0) * (pad_length - len(bin(goal)[2:])) + bin(goal)[2:]
    count = 0
    for i in range(pad_length):
        if bin_start[i] != bin_goal[i]:
            count += 1
    return count


# --- Next Function Block ---


# -----------------------------------------------------
# 15. Interleave Even and Odd Numbers
def interleave_even_odd(nums: list) -> list:
    """
    Separates even and odd numbers from nums. Sorts evens in ascending order and odds in descending order,
    then interleaves them. If one list is longer, appends the remaining elements.
    
    Example:
      nums = [4,3,2,1] → evens = [2,4], odds = [3,1] → result = [2,3,4,1]
    """
    evens = sorted([x for x in nums if x % 2 == 0])
    odds = sorted([x for x in nums if x % 2 != 0], reverse=True)
    result = []
    i = 0
    while i < len(evens) and i < len(odds):
        result.append(evens[i])
        result.append(odds[i])
        i += 1
    result.extend(evens[i:])
    result.extend(odds[i:])
    return result


# --- Next Function Block ---



# -------------------------------------------------------------
# 1. Group common elements based on binary ones count.
def group_by_binary_ones(arr: list) -> list:
    """
    Given a list of nonnegative integers, groups them by the number of 1's in their binary
    representation. The groups (lists) are sorted by the key (number of ones) in ascending order,
    and within each group the numbers are sorted in ascending order. Returns a single list containing
    all numbers in this order.
    
    Example:
      arr = [0,1,2,3,4,5,6,7,8]
      Binary ones count:
        0 -> 0 ones
        1 -> 1 one
        2 -> 1 one (10)
        3 -> 2 ones (11)
        4 -> 1 one (100)
        5 -> 2 ones (101)
        6 -> 2 ones (110)
        7 -> 3 ones (111)
        8 -> 1 one (1000)
      Grouped by count (key as string for consistency):
        "0": [0]
        "1": [1,2,4,8]
        "2": [3,5,6]
        "3": [7]
      Then concatenated in order: [0,1,2,4,8,3,5,6,7]
    """
    groups = {}
    for num in arr:
        ones = str(bin(num))[2:].count("1")
        if ones in groups:
            groups[ones].append(num)
        else:
            groups[ones] = [num]
    # Sort groups by key (number of ones) and sort each group individually.
    result = []
    for key in sorted(groups, key=lambda x: int(x)):
        groups[key].sort()
        result.extend(groups[key])
    return result


# --- Next Function Block ---


# -------------------------------------------------------------
# 2. Custom sort: For a list of numbers, if two numbers have equal binary ones count,
# swap them if needed (this is a variant of a custom sorting approach).
def custom_sort_by_binary_ones(nums: list) -> list:
    """
    Given a list of numbers, sort them primarily by the count of 1's in their binary representation.
    If two numbers have the same ones count, sort them in ascending order.
    
    Example:
      nums = [75, 34, 30]
    """
    # Use a sort key: (binary ones count, value)
    return sorted(nums, key=lambda x: (bin(x)[2:].count("1"), x))


# --- Next Function Block ---


# -------------------------------------------------------------
# 3. Count extra frequency needed from string s to cover string t.
def extra_frequency_needed(s: str, t: str) -> int:
    """
    Given two strings s and t, computes how many extra occurrences of characters in s are needed
    compared to t. For each character in s, if s has a higher count than t, adds the difference;
    if t doesn't contain the character, adds the full count from s.
    
    Example:
      s = "lloo", t = "balloon"
      Frequency(s): {'l':2, 'o':2}
      Frequency(t): {'b':1, 'a':1, 'l':2, 'o':2, 'n':1}
      Extra needed: 0 for 'l' and 'o' → returns 0.
    """
    sCount = Counter(s)
    tCount = Counter(t)
    extra = 0
    for ch in sCount:
        if ch in tCount:
            if sCount[ch] > tCount[ch]:
                extra += sCount[ch] - tCount[ch]
        else:
            extra += sCount[ch]
    return extra


# --- Next Function Block ---


# -------------------------------------------------------------
# 4. Convert a "MM-DD" date to day-of-year.
def date_to_day(date_str: str, month_days: list = None) -> int:
    """
    Given a date string in "MM-DD" format, returns the day-of-year (assuming a non-leap year).
    Optionally, a list of month lengths may be provided.
    
    Example:
      date_str = "01-20" returns 20.
      date_str = "04-18" returns sum of days in Jan, Feb, Mar plus 18.
    """
    if month_days is None:
        month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    month = int(date_str[:2])
    day = int(date_str[3:])
    if month > 1:
        return sum(month_days[:month-1]) + day
    else:
        return day


# --- Next Function Block ---


# Compute the overlap in days between two date ranges.
def overlapping_days(arrive1: str, leave1: str, arrive2: str, leave2: str) -> int:
    """
    Given two date ranges in "MM-DD" format (arrive and leave for two persons),
    converts each to day-of-year and returns the count of overlapping days.
    """
    d1 = date_to_day(arrive1)
    d2 = date_to_day(leave1)
    d3 = date_to_day(arrive2)
    d4 = date_to_day(leave2)
    
    # Determine the overlapping range.
    start = max(d1, d3)
    end = min(d2, d4)
    return max(0, end - start + 1)


# --- Next Function Block ---


# -------------------------------------------------------------
# 5. Group Anagrams: Group words that are anagrams of each other.
def group_anagrams(strs: list) -> list:
    """
    Given a list of strings, groups them into lists of anagrams.
    Returns a list of lists.
    """
    groups = {}
    for word in strs:
        key = "".join(sorted(word))
        if key in groups:
            groups[key].append(word)
        else:
            groups[key] = [word]
    return list(groups.values())


# --- Next Function Block ---


# -------------------------------------------------------------
# 6. Unique Representative of Anagram Groups.
def unique_anagram_representatives(words: list) -> list:
    """
    Given a list of words, returns a list containing one representative per anagram group.
    The representative is chosen arbitrarily.
    """
    seen = {}
    for word in words:
        key = "".join(sorted(word))
        if key not in seen:
            seen[key] = word
    return list(seen.values())


# --- Next Function Block ---


# -------------------------------------------------------------
# 7. Remove All Occurrences of a Substring Until None Remain.
def remove_substring_repeatedly(s: str, sub: str) -> str:
    """
    Given a string s and a substring sub, repeatedly removes the first occurrence of sub from s,
    until s no longer contains sub (or s equals sub).
    Returns the final string.
    """
    while sub in s and s != sub:
        i = 0
        while i <= len(s) - len(sub):
            if s[i:i+len(sub)] == sub:
                s = s[:i] + s[i+len(sub):]
                break
            i += 1
    return s


# --- Next Function Block ---


# -------------------------------------------------------------
# 8. Count Pairs of Words with Same Unique Letter Set.
def count_same_unique_letter_set(words: list) -> int:
    """
    Given a list of words, counts the number of pairs (i,j) (i < j) for which the sorted set of letters
    in the two words is identical.
    
    Example:
      words = ["aba","aabb","abcd","bac","aabc"]
      For "aba" and "bac": sorted(set("aba")) = "ab", sorted(set("bac")) = "abc" → not equal.
    """
    count = 0
    n = len(words)
    for i in range(n - 1):
        set_i = "".join(sorted(set(words[i])))
        for j in range(i + 1, n):
            set_j = "".join(sorted(set(words[j])))
            if set_i == set_j:
                count += 1
    return count


# --- Next Function Block ---


# -------------------------------------------------------------
# 9. Process Words with "prev" Tokens.
def process_prev_tokens(words: list) -> list:
    """
    Processes a list where each element is either a number (as string) or "prev".
    It builds a list as follows:
      - For a numeric token, it appends the integer value.
      - For each "prev" token encountered consecutively,
        it appends the last number from the numeric list corresponding to the number of consecutive "prev" tokens.
      If there are more "prev" tokens than numbers, it appends -1.
    Returns the resulting list.
    
    Example:
      words = ["1", "2", "prev", "prev", "prev"]
      Might return a list like [-1] (depending on interpretation).
    """
    result = []
    nums = []
    consecutive_prev = 0
    for token in words:
        try:
            value = int(token)
            nums.append(value)
            consecutive_prev = 0  # reset count on number token
        except ValueError:
            consecutive_prev += 1
            if consecutive_prev > len(nums):
                result.append(-1)
            else:
                result.append(nums[-consecutive_prev])
    return result


# --- Next Function Block ---


# -------------------------------------------------------------
# 10. Flowerbed Planting.
def can_place_flowers(flowerbed: list, n: int) -> bool:
    """
    Given a list representing a flowerbed (0 = empty, 1 = planted) and an integer n,
    determines whether n new flowers can be planted without planting adjacent to each other.
    Returns True if possible; otherwise, False.
    """
    bed = flowerbed.copy()
    i = 0
    while i < len(bed):
        if bed[i] == 0:
            empty_left = (i == 0 or bed[i-1] == 0)
            empty_right = (i == len(bed)-1 or bed[i+1] == 0)
            if empty_left and empty_right:
                bed[i] = 1
                n -= 1
                if n == 0:
                    return True
        i += 1
    return n <= 0


# --- Next Function Block ---


# -------------------------------------------------------------
# 11. Time Series Coverage.
def time_series_coverage(timeSeries: list, duration: int) -> set:
    """
    Given a list of start times (timeSeries) and a duration (in integer units),
    returns a set of all times covered by each interval defined by a start time and duration.
    """
    covered = set()
    for t in timeSeries:
        covered.add(t)
        for j in range(1, duration):
            covered.add(t + j)
    return covered


# --- Next Function Block ---




# -----------------------------------------------------
# Snippet 1:
# Group numbers by the count of ones in their binary representation,
# sort groups by key (i.e. number of ones), then concatenate the groups.
def group_by_binary_ones_sort(arr: list) -> list:
    """
    For each number in arr, counts the number of '1's in its binary representation.
    Groups numbers by this count, sorts the groups by the count (ascending),
    sorts each group in ascending order, then concatenates the groups.
    
    Example:
      arr = [0,1,2,3,4,5,6,7,8]
      Returns: [0, 1, 2, 4, 8, 3, 5, 6, 7]
    """
    groups = {}
    for num in arr:
        ones = str(bin(num))[2:].count("1")
        if ones in groups:
            groups[ones].append(num)
        else:
            groups[ones] = [num]
    result = []
    for key in sorted(groups, key=lambda k: k):
        groups[key].sort()
        result.extend(groups[key])
    return result


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 2:
# Custom sort by binary ones: sort numbers by (binary ones count, value).
def custom_sort_by_bin_ones(nums: list) -> list:
    """
    Sorts the list of numbers by the number of '1's in their binary representation.
    For numbers with the same count, sorts in ascending order.
    
    Example:
      nums = [75,34,30]
      Returns: sorted list according to (bin(x).count("1"), x)
    """
    return sorted(nums, key=lambda x: (str(bin(x))[2:].count("1"), x))


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 3:
# For a given string, generate all unique contiguous substrings (prefixes of each suffix)
# and print each along with its reverse.
def unique_prefix_substrings_with_reverse(s: str) -> list:
    """
    For each starting index in s, generates all contiguous substrings starting at that index.
    Collects only those substrings that have not been seen before.
    Returns a list of tuples (substring, reversed substring).
    
    Example:
      s = "aaa"
      Might return: [("a", "a"), ("aa", "aa"), ("aaa", "aaa")]
    """
    seen = set()
    result = []
    for i in range(len(s)):
        for j in range(1, len(s) - i + 1):
            substr = s[i:i+j]
            if substr not in seen:
                seen.add(substr)
                result.append((substr, substr[::-1]))
    return result


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 4:
# Get all prefixes for every suffix of a string.
def all_prefixes(s: str) -> list:
    """
    For each starting index in s, collects all prefixes (contiguous substrings beginning at that index).
    Returns a list of these prefixes.
    
    Example:
      s = "bbbab"
      Returns a list including: "b", "bb", "bbb", "bbba", "bbbab", "b", "bb", "bba", etc.
    """
    prefixes = []
    for i in range(len(s)):
        for j in range(1, len(s) - i + 1):
            prefixes.append(s[i:i+j])
    return prefixes


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 5:
# For each contiguous subarray (prefix of each suffix) of a list that is not the entire list,
# print (or return) the square of its length (i.e. length*length), but only if that subarray is unique.
def unique_subarray_square_lengths(nums: list) -> list:
    """
    For each starting index in nums, generates contiguous subarrays (prefixes of the suffix starting at i)
    that are not equal to the entire list and that have not been seen before.
    Returns a list of the square of the length of each unique subarray.
    
    Example:
      nums = [1,2,1]
      Might return: [1, 4] because subarrays of length 1 yield 1, length 2 yield 4, etc.
    """
    seen = []
    squares = []
    for i in range(len(nums)):
        for j in range(1, len(nums) - i + 1):
            sub = nums[i:i+j]
            if sub not in seen and sub != nums:
                seen.append(sub)
                squares.append(len(sub) * len(sub))
    return squares


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 6:
# Starting with a given count, find the n-th "special" number (one that is prime or divisible by 7).
def find_nth_special(n: int, start: int = 7, initial_count: int = 6) -> int:
    """
    Starting from 'start' with an initial counter value 'initial_count',
    iterates upward and increases the counter if the current number is prime or divisible by 7.
    When the counter reaches n, returns that number.
    
    Example:
      n = 10, initial_count = 6, start = 7.
      Returns the smallest number for which the count reaches 10.
    """
    def is_prime(x: int) -> bool:
        if x < 2:
            return False
        for j in range(2, x):
            if x % j == 0:
                return False
        return True

    count = initial_count
    i = start
    while count < n:
        if is_prime(i) or (i % 7 == 0):
            count += 1
            if count >= n:
                return i
        i += 1
    return i


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 7:
# Compare the unique characters in two strings (ignoring order).
def compare_unique_chars(str1: str, str2: str) -> bool:
    """
    Compares two strings by checking if the set of unique characters in each is the same.
    
    Example:
      str1 = "TAUXXTAUXXTAUXXTAUXXTAUXX"
      str2 = "TAUXXTAUXXTAUXXTAUXXTAUXXTAUXXTAUXXTAUXXTAUXX"
      Returns True if both have the same unique characters.
    """
    set1 = set(str1)
    set2 = set(str2)
    return set1 == set2


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 8:
# Given two date strings "YYYY-MM-DD", swap if necessary so date1 is earlier,
# then compute the day difference based solely on years (each year = 365 days).
def year_difference_in_days(date1: str, date2: str) -> int:
    """
    Given two dates in "YYYY-MM-DD" format, ensures date1 <= date2 and returns the difference
    in years multiplied by 365.
    
    Example:
      date1 = "2018-06-29", date2 = "2019-05-30"
      Returns: (2019-2018)*365 = 365.
    """
    if int(date1.replace("-", "")) > int(date2.replace("-", "")):
        date1, date2 = date2, date1
    y1 = int(date1[:4])
    y2 = int(date2[:4])
    return (y2 - y1) * 365


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 9:
# Remove elements from a list that occur more than a specified maximum frequency.
def remove_excess_duplicates(nums: list, max_allowed: int = 2) -> int:
    """
    Iterates over nums and removes elements (one occurrence at a time) if their total count
    is greater than max_allowed. Returns the new length of the list.
    
    Example:
      nums = [1,1,1,2,2,3] with max_allowed=2 → returns length 5.
    """
    nums = nums.copy()
    i = 0
    while i < len(nums):
        if nums.count(nums[i]) > max_allowed:
            del nums[i]
        else:
            i += 1
    return len(nums)


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 10:
# After sorting, perform pairwise swapping from index 1 toward the end.
def pairwise_swap_after_sort(nums: list) -> list:
    """
    Sorts nums in ascending order, then swaps elements pairwise: starting at index 1 and from the end.
    In each iteration, swaps nums[i] and nums[j], increments i by 2, decrements j by 1.
    
    Example:
      nums = [1,5,1,1,6,4] → after sorting → [1,1,1,4,5,6]
      Then perform pairwise swap on indices 1 and last, etc.
    """
    nums = sorted(nums)
    i = 1
    j = len(nums) - 1
    while i < j:
        nums[i], nums[j] = nums[j], nums[i]
        i += 2
        j -= 1
    return nums


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 11:
# Generate all unique contiguous substrings (prefixes of each suffix) of a string
# and return them along with their reverses.
def unique_prefix_substrings_with_reverse(s: str) -> list:
    """
    For each starting index in s, generates all contiguous substrings starting at that index.
    Returns a list of tuples (substring, reversed substring) for each unique substring.
    
    Example:
      s = "aaa" may produce [("a", "a"), ("aa", "aa"), ("aaa", "aaa")].
    """
    seen = set()
    results = []
    for i in range(len(s)):
        for j in range(1, len(s) - i + 1):
            sub = s[i:i+j]
            if sub not in seen:
                seen.add(sub)
                results.append((sub, sub[::-1]))
    return results


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 12:
# Get all prefixes for every starting index in a string.
def all_prefixes(s: str) -> list:
    """
    For each starting index in s, collects all prefixes (i.e. contiguous substrings starting at that index).
    Returns a list of these prefixes.
    
    Example:
      s = "bbbab" → returns a list of substrings like "b", "bb", "bbb", "bbba", "bbbab", "b", "bb", ...
    """
    prefixes = []
    for i in range(len(s)):
        for j in range(1, len(s) - i + 1):
            prefixes.append(s[i:i+j])
    return prefixes


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 13:
# For each contiguous subarray (prefix of each suffix) of a list (excluding the entire array),
# record the square of its length if not seen before.
def unique_subarray_square_lengths(nums: list) -> list:
    """
    Iterates over nums and for every contiguous subarray (prefix of the suffix starting at index i)
    that is not equal to the entire list and not already seen, computes length^2.
    Returns a list of these square values.
    
    Example:
      nums = [1,2,1]
      Might produce squares like 1^2, 2^2, etc.
    """
    seen = []
    squares = []
    for i in range(len(nums)):
        for j in range(1, len(nums) - i + 1):
            sub = nums[i:i+j]
            if sub not in seen and sub != nums:
                seen.append(sub)
                squares.append(len(sub) ** 2)
    return squares


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 14:
# Find the nth special number, starting with a given initial count and starting number.
def find_nth_special(n: int, start: int = 7, initial_count: int = 6) -> int:
    """
    Starting from 'start' and an initial count, iterates upward and increases the count if
    the current number is prime or divisible by 7. When the count reaches n, returns that number.
    
    Example:
      n = 10, initial_count = 6, start = 7.
    """
    def is_prime(x: int) -> bool:
        if x < 2:
            return False
        for j in range(2, x):
            if x % j == 0:
                return False
        return True

    count = initial_count
    i = start
    while count < n:
        if is_prime(i) or (i % 7 == 0):
            count += 1
            if count >= n:
                return i
        i += 1
    return i


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 15:
# Compare the unique characters in two strings.
def compare_unique_chars(str1: str, str2: str) -> bool:
    """
    Compares two strings by their unique characters.
    Returns True if both strings have the same set of unique characters, else False.
    """
    return set(str1) == set(str2)


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 16:
# Given two dates in "YYYY-MM-DD" format, swap if necessary so that date1 is earlier,
# then compute the day difference based solely on the difference in years (each year = 365 days).
def year_difference_in_days(date1: str, date2: str) -> int:
    """
    Converts two date strings (YYYY-MM-DD) into integers (YYYYMMDD) to compare them.
    If date1 > date2, swaps them. Then computes the difference in years multiplied by 365.
    
    Example:
      date1 = "2018-06-29", date2 = "2019-05-30" → returns 365.
    """
    if int(date1.replace("-", "")) > int(date2.replace("-", "")):
        date1, date2 = date2, date1
    y1 = int(date1[:4])
    y2 = int(date2[:4])
    return (y2 - y1) * 365


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 17:
# Remove elements from a list that occur more than a given maximum frequency.
def remove_excess_duplicates(nums: list, max_allowed: int = 2) -> int:
    """
    Iterates over nums and removes elements if their total count exceeds max_allowed.
    Returns the length of the resulting list.
    
    Example:
      nums = [1,1,1,2,2,3] with max_allowed = 2 returns 5.
    """
    nums = nums.copy()
    i = 0
    while i < len(nums):
        if nums.count(nums[i]) > max_allowed:
            del nums[i]
        else:
            i += 1
    return len(nums)


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 18:
# Sort a list, then perform pairwise swapping starting at index 1 and from the end.
def pairwise_swap_after_sort(nums: list) -> list:
    """
    Sorts nums in ascending order. Then, starting at index 1 and the end of the list,
    swaps elements pairwise (incrementing index by 2 from the start and decrementing from the end).
    Returns the modified list.
    
    Example:
      nums = [1,5,1,1,6,4] → after sorting: [1,1,1,4,5,6] → after pairwise swap, e.g. [1,6,1,4,5,1]
    """
    nums = sorted(nums)
    i = 1
    j = len(nums) - 1
    while i < j:
        nums[i], nums[j] = nums[j], nums[i]
        i += 2
        j -= 1
    return nums


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 19:
# Generate all unique contiguous substrings (prefixes of each suffix) along with their reverses.
def unique_prefix_substrings_with_reverse(s: str) -> list:
    """
    Returns a list of tuples (substring, reversed substring) for all unique contiguous substrings
    of s (each substring is a prefix of some suffix of s).
    
    Example:
      s = "aaa" → might return [("a", "a"), ("aa", "aa"), ("aaa", "aaa")].
    """
    seen = set()
    result = []
    for i in range(len(s)):
        for j in range(1, len(s) - i + 1):
            sub = s[i:i+j]
            if sub not in seen:
                seen.add(sub)
                result.append((sub, sub[::-1]))
    return result


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 20:
# Get all prefixes for every starting index in a string.
def all_prefixes(s: str) -> list:
    """
    Returns a list of all contiguous substrings (prefixes) for every starting index of s.
    
    Example:
      s = "bbbab" → returns all substrings starting at each index.
    """
    prefixes = []
    for i in range(len(s)):
        for j in range(1, len(s) - i + 1):
            prefixes.append(s[i:i+j])
    return prefixes


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 21:
# For each contiguous subarray (prefix of a suffix) that is not the entire list,
# record the square of its length (if not already seen).
def unique_subarray_square_lengths(nums: list) -> list:
    """
    Returns a list of squares of the lengths of each unique contiguous subarray (which is a prefix of a suffix)
    of nums, excluding the subarray that is the entire list.
    
    Example:
      nums = [1,2,1] → possible square lengths: 1, 4, ...
    """
    seen = []
    squares = []
    for i in range(len(nums)):
        for j in range(1, len(nums) - i + 1):
            sub = nums[i:i+j]
            if sub not in seen and sub != nums:
                seen.append(sub)
                squares.append(len(sub) ** 2)
    return squares


# --- Next Function Block ---


# -----------------------------------------------------
# Snippet 22:
# Find the nth special number (one that is prime or divisible by 7) given an initial count.
def find_nth_special(n: int, start: int = 7, initial_count: int = 6) -> int:
    """
    Starting from 'start' with an initial counter value 'initial_count', iterates upward.
    If the current number is prime or divisible by 7, increments the count.
    When the count reaches n, returns that number.
    """
    def is_prime(x: int) -> bool:
        if x < 2:
            return False
        for j in range(2, x):
            if x % j == 0:
                return False
        return True

    count = initial_count
    i = start
    while count < n:
        if is_prime(i) or (i % 7 == 0):
            count += 1
            if count >= n:
                return i
        i += 1
    return i


# --- Next Function Block ---



def join(left, right):
    i=0
    j=0
    nums1=[]
    while i<len(left) and j<len(right):
        if left[i]<right[j]:
            nums1.append(left[i])
            i+=1
        else:
            nums1.append(right[j])
            j+=1
    while i<len(left):
        nums1.append(left[i])
        i+=1
    while j<len(right):
        nums1.append(right[j])
        j+=1
    return nums1


# --- Next Function Block ---


def merge_sort(nums1):
    if len(nums1)<=1:
        return nums1
    mid=len(nums1)//2
    left=nums1[:mid]
    right=nums1[mid:]
    
    return join(merge_sort(left), merge_sort(right))


# --- Next Function Block ---




def join(left, right):
    arr=[]
    i=0
    j=0

    while i<len(left) and j<len(right):
        if left[i]<right[j]:
            arr.append(left[i])
            i+=1
        else:
            arr.append(right[j])
            j+=1
    while i<len(left):
        arr.append(left[i])
        i+=1
    while j<len(right):
        arr.append(right[j])
        j+=1
    return arr


# --- Next Function Block ---

        
def merge_sort(arr):
    if len(arr)<=1:
        return arr
    mid=len(arr)//2
    left=arr[:mid]
    right=arr[mid:]

    return join(merge_sort(left), merge_sort(right))


# --- Next Function Block ---



# -----------------------------------------------------
# Function 1: Get first and last index of target in a sorted list.
def target_first_last_indices(nums: list, target: int) -> tuple:
    """
    Given a list of numbers and a target, returns a tuple:
      (first_index, last_index)
    where first_index is the index of the first occurrence of target,
    and last_index is the index of the last occurrence.
    
    Example:
      nums = [5,7,7,8,8,10], target = 8 
      returns (3, 4)
    """
    if target in nums:
        first = nums.index(target)
        # For last index, reverse the list and subtract from len(nums)-1.
        last = len(nums) - 1 - nums[::-1].index(target)
        return (first, last)
    else:
        return (-1, -1)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 2: Rank the elements in an array.
def rank_array(arr: list) -> (list, dict):
    """
    Given an array, creates a ranking dictionary based on the sorted unique values.
    Each value is assigned a rank starting at 1.
    The function then replaces each element in the original list with its rank.
    
    Example:
      arr = [40,10,20,30]
      Returns: ([4,1,2,3], {10: 1, 20: 2, 30: 3, 40: 4})
    """
    unique_sorted = sorted(set(arr))
    ranking = {val: idx+1 for idx, val in enumerate(unique_sorted)}
    ranked_arr = [ranking[val] for val in arr]
    return ranked_arr, ranking


# --- Next Function Block ---


# -----------------------------------------------------
# Function 3: Compare occurrence counts in two strings.
def compare_occurrence_counts(s: str, t: str) -> bool:
    """
    For each character in s and t, counts the occurrences in the suffix and prefix
    (i.e. count in s[i:] and s[:i]). Returns True if the resulting count arrays are equal.
    
    Example:
      s = "bbbaaaab", t = "aaabbbba"
      (This snippet builds two lists of counts and compares them.)
    """
    s_counts = []
    t_counts = []
    for i in range(len(s)):
        s_counts.append(s[i:].count(s[i]))
        s_counts.append(s[:i].count(s[i]))
    for i in range(len(t)):
        t_counts.append(t[i:].count(t[i]))
        t_counts.append(t[:i].count(t[i]))
    return s_counts == t_counts


# --- Next Function Block ---


# -----------------------------------------------------
# Function 4: Map a pattern to characters from a string.
def pattern_to_mapping(pattern: str, s: str) -> (dict, list):
    """
    Given a pattern and a string, first removes spaces from s, then zips the pattern
    and the string to build a mapping (dictionary). Also returns a list of mapped values
    corresponding to the characters in the pattern.
    
    Example:
      pattern = "abba", s = "dog cat cat fish"
      After removing spaces, s becomes "dogcatcatfish".
      Mapping is built by zipping pattern and s (up to the length of pattern).
    """
    s = s.replace(" ", "")
    mapping = {p: ch for p, ch in zip(pattern, s)}
    mapped_list = [mapping[p] for p in pattern]
    return mapping, mapped_list


# --- Next Function Block ---


# -----------------------------------------------------
# Function 5: Convert an integer to its binary representation.
def to_binary(num: int) -> str:
    """
    Converts a positive integer to its binary representation as a string.
    If num is 0, returns "0".
    
    Example:
      num = 2 → returns "10"
    """
    if num == 0:
        return "0"
    digits = []
    count = abs(num)
    while count > 0:
        digits.append(str(count % 2))
        count //= 2
    return "".join(digits[::-1])


# --- Next Function Block ---


# -----------------------------------------------------
# Function 6: Modular exponentiation using pow.
def mod_exponentiation(a: int, b: int, mod: int) -> int:
    """
    Returns a^b modulo mod.
    
    Example:
      a = 2, b = 3, mod = 1337 → returns pow(2, 3, 1337)
    """
    return pow(a, b, mod)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 7: Custom binary string for negative values.
def custom_bin_negative(num: int) -> str:
    """
    Returns a binary representation for negative numbers by computing bin(num)
    and then slicing off the prefix. This function demonstrates the snippet:
      print(bin(-2**2)[3:])
    """
    return bin(num)[3:]


# --- Next Function Block ---


# -----------------------------------------------------
# Function 8: Convert an integer to base 7.
def to_base7(num: int) -> str:
    """
    Converts a non-negative integer to its base-7 representation as a string.
    
    Example:
      num = 100 → returns "202"
    """
    if num == 0:
        return "0"
    digits = []
    while num > 0:
        digits.append(str(num % 7))
        num //= 7
    return "".join(digits[::-1])


# --- Next Function Block ---


# -----------------------------------------------------
# Function 9: Custom binary search.
def binary_search(nums: list, target: int) -> int:
    """
    Performs a binary search on a sorted list 'nums' to find 'target'.
    Returns the index if found, or -1 if not found.
    Uses a simple iterative method.
    
    Example:
      nums = [-1,0,3,5,9,12], target = 2 → returns -1 (target not found)
    """
    start = 0
    end = len(nums) - 1
    while start <= end:
        mid = (start + end) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            start = mid + 1
        else:
            end = mid - 1
    return -1


# --- Next Function Block ---


# -----------------------------------------------------
# Function 10: Rank an array (alternative implementation).
def rank_array_alternative(arr: list) -> (list, dict):
    """
    Another implementation for ranking elements of 'arr'.
    Assigns a rank (starting at 1) to each unique element based on sorted order,
    and then replaces each element with its rank.
    
    Example:
      arr = [40,10,20,30] → returns ([4,1,2,3], {10:1, 20:2, 30:3, 40:4})
    """
    dictionary = {}
    sorted_arr = sorted(arr)
    for i in range(len(sorted_arr)):
        dictionary[sorted_arr[i]] = i + 1
    ranked_arr = [dictionary[x] for x in arr]
    return ranked_arr, dictionary


# --- Next Function Block ---


# -----------------------------------------------------
# Function 11: Evaluate a string expression.
def evaluate_expression(expr: str):
    """
    Evaluates a string expression using eval.
    
    Example:
      expr = "-9.1234" → returns -9.1234
    """
    return eval(expr)


# --- Next Function Block ---




# -----------------------------------------------------
# Function 1: Get first and last index of target in a sorted list.
def target_first_last_indices(nums: list, target: int) -> tuple:
    """
    Given a list of numbers and a target, returns a tuple:
      (first_index, last_index)
    where first_index is the index of the first occurrence of target,
    and last_index is the index of the last occurrence.
    
    Example:
      nums = [5,7,7,8,8,10], target = 8 
      returns (3, 4)
    """
    if target in nums:
        first = nums.index(target)
        # For last index, reverse the list and subtract from len(nums)-1.
        last = len(nums) - 1 - nums[::-1].index(target)
        return (first, last)
    else:
        return (-1, -1)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 2: Rank the elements in an array.
def rank_array(arr: list):
    """
    Given an array, creates a ranking dictionary based on the sorted unique values.
    Each value is assigned a rank starting at 1.
    The function then replaces each element in the original list with its rank.
    
    Example:
      arr = [40,10,20,30]
      Returns: ([4,1,2,3], {10: 1, 20: 2, 30: 3, 40: 4})
    """
    unique_sorted = sorted(set(arr))
    ranking = {val: idx+1 for idx, val in enumerate(unique_sorted)}
    ranked_arr = [ranking[val] for val in arr]
    return ranked_arr, ranking


# --- Next Function Block ---


# -----------------------------------------------------
# Function 3: Compare occurrence counts in two strings.
def compare_occurrence_counts(s: str, t: str) -> bool:
    """
    For each character in s and t, counts the occurrences in the suffix and prefix
    (i.e. count in s[i:] and s[:i]). Returns True if the resulting count arrays are equal.
    
    Example:
      s = "bbbaaaab", t = "aaabbbba"
      (This snippet builds two lists of counts and compares them.)
    """
    s_counts = []
    t_counts = []
    for i in range(len(s)):
        s_counts.append(s[i:].count(s[i]))
        s_counts.append(s[:i].count(s[i]))
    for i in range(len(t)):
        t_counts.append(t[i:].count(t[i]))
        t_counts.append(t[:i].count(t[i]))
    return s_counts == t_counts


# --- Next Function Block ---


# -----------------------------------------------------
# Function 4: Map a pattern to characters from a string.
def pattern_to_mapping(pattern: str, s: str) -> (dict, list):
    """
    Given a pattern and a string, first removes spaces from s, then zips the pattern
    and the string to build a mapping (dictionary). Also returns a list of mapped values
    corresponding to the characters in the pattern.
    
    Example:
      pattern = "abba", s = "dog cat cat fish"
      After removing spaces, s becomes "dogcatcatfish".
      Mapping is built by zipping pattern and s (up to the length of pattern).
    """
    s = s.replace(" ", "")
    mapping = {p: ch for p, ch in zip(pattern, s)}
    mapped_list = [mapping[p] for p in pattern]
    return mapping, mapped_list


# --- Next Function Block ---


# -----------------------------------------------------
# Function 5: Convert an integer to its binary representation.
def to_binary(num: int) -> str:
    """
    Converts a positive integer to its binary representation as a string.
    If num is 0, returns "0".
    
    Example:
      num = 2 → returns "10"
    """
    if num == 0:
        return "0"
    digits = []
    count = abs(num)
    while count > 0:
        digits.append(str(count % 2))
        count //= 2
    return "".join(digits[::-1])


# --- Next Function Block ---


# -----------------------------------------------------
# Function 6: Modular exponentiation using pow.
def mod_exponentiation(a: int, b: int, mod: int) -> int:
    """
    Returns a^b modulo mod.
    
    Example:
      a = 2, b = 3, mod = 1337 → returns pow(2, 3, 1337)
    """
    return pow(a, b, mod)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 7: Custom binary string for negative values.
def custom_bin_negative(num: int) -> str:
    """
    Returns a binary representation for negative numbers by computing bin(num)
    and then slicing off the prefix. This function demonstrates the snippet:
      print(bin(-2**2)[3:])
    """
    return bin(num)[3:]


# --- Next Function Block ---


# -----------------------------------------------------
# Function 8: Convert an integer to base 7.
def to_base7(num: int) -> str:
    """
    Converts a non-negative integer to its base-7 representation as a string.
    
    Example:
      num = 100 → returns "202"
    """
    if num == 0:
        return "0"
    digits = []
    while num > 0:
        digits.append(str(num % 7))
        num //= 7
    return "".join(digits[::-1])


# --- Next Function Block ---


# -----------------------------------------------------
# Function 9: Custom binary search.
def binary_search(nums: list, target: int) -> int:
    """
    Performs a binary search on a sorted list 'nums' to find 'target'.
    Returns the index if found, or -1 if not found.
    Uses a simple iterative method.
    
    Example:
      nums = [-1,0,3,5,9,12], target = 2 → returns -1 (target not found)
    """
    start = 0
    end = len(nums) - 1
    while start <= end:
        mid = (start + end) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            start = mid + 1
        else:
            end = mid - 1
    return -1


# --- Next Function Block ---


# -----------------------------------------------------
# Function 10: Rank an array (alternative implementation).
def rank_array_alternative(arr: list) -> (list, dict):
    """
    Another implementation for ranking elements of 'arr'.
    Assigns a rank (starting at 1) to each unique element based on sorted order,
    and then replaces each element with its rank.
    
    Example:
      arr = [40,10,20,30] → returns ([4,1,2,3], {10:1, 20:2, 30:3, 40:4})
    """
    dictionary = {}
    sorted_arr = sorted(arr)
    for i in range(len(sorted_arr)):
        dictionary[sorted_arr[i]] = i + 1
    ranked_arr = [dictionary[x] for x in arr]
    return ranked_arr, dictionary


# --- Next Function Block ---


# -----------------------------------------------------
# Function 11: Evaluate a string expression.
def evaluate_expression(expr: str):
    """
    Evaluates a string expression using eval.
    
    Example:
      expr = "-9.1234" → returns -9.1234
    """
    return eval(expr)


# --- Next Function Block ---





def swap(left, right):
    temp=arr[left]
    arr[left]=arr[right]
    arr[right]=temp


# --- Next Function Block ---


def quick_sort(start, end):
    if start >= end:
        return
    pivot = start
    left = start+1
    right = end

    while left <= right:
        if arr[left]>arr[pivot] and arr[right]<arr[pivot]:
            swap(left, right)
            left+=1
            right-=1
        if arr[left]<=arr[pivot]:
            left+=1
        if arr[right]>=arr[pivot]:
            right-=1
    swap(pivot, right)
    quick_sort(start, right-1)
    quick_sort(right+1, end)
    return


# --- Next Function Block ---

    
def swap(left, right):
    temp=arr[left]
    arr[left]=arr[right]
    arr[right]=temp


# --- Next Function Block ---


def quick_sort(start, end):
    if start>=end:
        return
    pivot=start
    left=start+1
    right=end
    while left<=right:
        if arr[left]>arr[pivot] and arr[right]<arr[pivot]:
            swap(left,right)
            left+=1
            right-=1
        if arr[left]<=arr[pivot]:
            left+=1
        if arr[right]>=arr[pivot]:
            right-=1

        swap(pivot, right)
        quick_sort(start, right-1)
        quick_sort(right+1, end)


# --- Next Function Block ---


        

def swap(arr, left, right):
    temp=arr[left]
    arr[left]=arr[right]
    arr[right]=temp


# --- Next Function Block ---


def quick_sort(start, end):
    if start>=end:
        return
    pivot=start
    left=start+1
    right=end
    while left<=right:
        if arr[left]>arr[pivot] and arr[right]<arr[pivot]:
            swap(left, right)
            left+=1
            right-=1
        if arr[left]<=arr[pivot]:
            left+=1
        if arr[right]>=arr[pivot]:
            right-=1
    swap(pivot, right)
    quick_sort(start, right-1)
    quick_sort(right+1, end)


# --- Next Function Block ---



# -----------------------------------------------------
# Function 1: Process two strings by removing matching characters.
def process_order_and_string(order: str, s: str) -> str:
    """
    Iterates over the characters in 'order'. For each character:
      - If the character is found in 's', remove its first occurrence from s.
      - Otherwise, remove that character from order.
    Returns the concatenation of the modified order and s.
    
    Example:
      order = "kqep", s = "pekeq"
      (After processing, the function returns the concatenated result.)
    """
    order = list(order)
    s = list(s)
    i = 0
    while i < len(order):
        ch = order[i]
        if ch in s:
            # Remove the first occurrence from s.
            s.pop(s.index(ch))
        else:
            # Remove the character from order.
            order.pop(i)
            # Do not increment i since the list has shifted.
            continue
        i += 1
    return "".join(order + s)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 2: Process an array by removing zeros and elements whose addition with a prior subarray equals zero.
def process_array(arr: list) -> list:
    """
    Iterates through the list 'arr' and removes elements under two conditions:
      - If an element is zero, remove it.
      - Otherwise, for each element, check every subarray ending at that element. If the sum 
        of that subarray plus the current element equals zero, remove that element.
    Returns the modified list.
    
    Note: Since the snippet is ambiguous, this is one interpretation.
    """
    i = 0
    while i < len(arr):
        if arr[i] == 0:
            del arr[i]
            i = max(i - 1, 0)
            continue
        j = 0
        removed = False
        while j < i:
            sub_sum = functools.reduce(lambda x, y: x + y, arr[j:i], 0)
            if sub_sum + arr[i] == 0:
                arr = arr[:j] + arr[i+1:]
                i = max(j - 1, 0)
                removed = True
                break
            j += 1
        if not removed:
            i += 1
    return arr


# --- Next Function Block ---


# -----------------------------------------------------
# Function 3: Find the divisor that divides the most numbers.
def find_max_divisor(nums: list, divisors: list) -> int:
    """
    Given a list of numbers and a list of divisors, counts for each divisor how many numbers
    in 'nums' are divisible by it. Returns the divisor with the highest count.
    
    Example:
      nums = [20, 14, 21, 10], divisors = [5,7,5]
    """
    max_count = 0
    result = None
    i = 0
    seen = {}
    while i < len(divisors):
        d = divisors[i]
        if d not in seen:
            count = 0
            j = 0
            while j < len(nums):
                if nums[j] % d == 0:
                    count += 1
                j += 1
            seen[d] = count
            if count > max_count:
                max_count = count
                result = d
        i += 1
    return result


# --- Next Function Block ---


# -----------------------------------------------------
# Function 4: Concatenate binary representations and mark indices if divisible by 5.
def process_binaries(nums: list) -> (str, list):
    """
    Given a list of numbers, concatenates their binary representations (without the '0b' prefix)
    into a string. After adding each number's binary representation, converts the string to an
    integer and checks if it is divisible by 5. Replaces the corresponding element in a result
    list with True if divisible, False otherwise.
    
    Returns a tuple:
      (final concatenated binary string, list of booleans indicating divisibility by 5 at each step)
    """
    out = ""
    flags = []
    for num in nums:
        out += bin(num)[2:]
        # Debug print: current integer value of the binary string.
        print("Current value:", int(out))
        if int(out) % 5 == 0:
            flags.append(True)
        else:
            flags.append(False)
    return out, flags


# --- Next Function Block ---


# -----------------------------------------------------
# Function 5: Get sorted sliding windows from a list.
def get_sorted_windows(nums: list, k: int) -> list:
    """
    For every contiguous subarray (window) of length k in nums, returns its sorted version.
    
    Example:
      nums = [1,3,-1,-3,5,3,6,7], k = 3
      Returns a list of sorted windows.
    """
    windows = []
    n = len(nums)
    for i in range(n - k + 1):
        windows.append(sorted(nums[i:i+k]))
    return windows


# --- Next Function Block ---


# -----------------------------------------------------
# Function 6: Copy list into a fixed-length array.
def copy_to_fixed_length(nums: list, fixed_length: int) -> list:
    """
    Copies the contents of 'nums' into a new list of length 'fixed_length',
    filling any extra positions with zeros.
    
    Example:
      nums = [1,3,-1,-3,5,3,6,7], fixed_length = 20.
    """
    arr = [0] * fixed_length
    for i in range(len(nums)):
        arr[i] = nums[i]
    return arr[:len(nums)]


# --- Next Function Block ---


# -----------------------------------------------------
# Function 7: Print prefix and suffix sums of an array.
def print_prefix_suffix_sums(n: int) -> None:
    """
    Constructs a list of numbers from 1 to n. For each index, prints:
      - The prefix (elements up to and including that index)
      - The suffix (elements after that index)
      - The sum of the prefix and the sum of the suffix.
    """
    arr = [i + 1 for i in range(n)]
    for i in range(1, len(arr) + 1):
        prefix = arr[:i]
        suffix = arr[i:]
        prefix_sum = functools.reduce(lambda x, y: x + y, prefix)
        suffix_sum = functools.reduce(lambda x, y: x + y, suffix) if suffix else 0
        print("Prefix:", prefix, "Suffix:", suffix, "Prefix sum:", prefix_sum, "Suffix sum:", suffix_sum)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 8: DP toggle variant (Version 1)
def dp_toggle_variant1(n: int) -> list:
    """
    Creates a dp list of length n with all elements initialized to 1.
    Then toggles the values based on nested loop conditions:
      - For i == 1: set dp[j] = 0 for odd indices.
      - For i == 2: toggles based on a count pattern.
      - Otherwise: toggles each element (1 becomes 0, and 0 becomes 1).
    If n > 3, toggles the last element.
    Returns the final dp list.
    """
    dp = [1] * n
    for i in range(1, n):
        count = 0
        for j in range(n):
            if i == 1:
                if j % 2 == 1:
                    dp[j] = 0
            elif i == 2:
                count += 1
                if count == 3:
                    count = 1
                    dp[j] = 0 if dp[j] == 1 else 1
            else:
                dp[j] = 0 if dp[j] == 1 else 1
    if n > 3:
        dp[-1] = 0 if dp[-1] == 1 else 1
    return dp


# --- Next Function Block ---


# -----------------------------------------------------
# Function 9: DP toggle variant (Version 2)
def dp_toggle_variant2(n: int) -> list:
    """
    Creates a dp list of length n with all elements initialized to 1.
    For each integer i from 2 to n, toggles dp[j] for all j in range(i-1, n, i).
    Prints the dp list after each outer iteration.
    Returns the final dp list.
    """
    dp = [1] * n
    for i in range(2, n + 1):
        for j in range(i - 1, n, i):
            dp[j] = 0 if dp[j] == 1 else 1
        print("After toggling for i =", i, ":", dp)
    return dp


# --- Next Function Block ---





class Node:
    def __init__(self, data=None, left=None, right=None):
        self.data=data
        self.left=left
        self.right=right

class Binary:
    def __init__(self):
        self.root=None

    def append(self, data):
        node=Node(data)
        if self.root==None:
            self.root=node
            return
        current=self.root
        while True:
            if data<current.data:
                if current.left==None:
                    current.left=node
                    break
                else:
                    current=current.left
            else:
                if current.right==None:
                    current.right=node
                    break
                else:
                    current=current.right

    def exists(self, data):
        current=self.root
        while current:
            if data < current.data:
                current=current.left
            elif data > current.data:
                current=current.right
            else:
                return current.data
        return False
    
    def remove(self, data):

        def get_min(current):
            if current.left:
                get_min(current.left)
            else:
                return(current.data)
            
        def remove_helper(data, current, parent):
            current=self.root
            while current:
                parent=current
                if data<current.data:
                    current=current.left
                elif data>current.data:
                    current=current.right
                else:
                    if current.left != None and current.right != None: 
                        current.data = get_min(current.right)
                        remove_helper(current.data, )
                    

                    return
        
    def in_order(self):
        def in_order_helper(current):
            if current:
                in_order_helper(current.left)
                print(current.data)
                in_order_helper(current.right)
        
        in_order_helper(self.root)
            


class Node:
    def __init__(self, data=None, left=None, right=None):
        self.data=data
        self.left=left
        self.right=right

class BinarySearchTree:
    def __init__(self):
        self.root=None
    
    def append(self, data):
        node=Node(data)
        if self.root == None:
            self.root=node
            return
        current=self.root
        while True:
            if data < current.data:
                if current.left == None:
                    current.left = node
                    break
                else:
                    current = current.left
            else:
                if current.right == None:
                    current.right = node
                    break
                else:
                    current = current.right

    def in_order(self):
        def helper(current):
            if current:
                helper(current.left)
                print(current.data)
                helper(current.right)
        helper(self.root)


    def remove(self, data):

        def get_min(current):
            if current.left==None:
                return current.data
            else:
                return get_min(current.left)

        def helper(data, current, parrent):
            while current != None:
                if data<current.data:
                    parrent=current
                    current=current.left
                elif data>current.data:
                    parrent=current
                    current=current.right
                else:
                    if current.left != None and current.right != None:
                        current.data=get_min(current.right)
                        return helper(current.data, current.right, current)
                    else:
                        if parrent == None:
                            if current.left == None:
                                self.root = current.right
                            else:
                                self.root = current.left
                        else:
                            if parrent.left == current:
                                if current.left == None:
                                    parrent.left = current.right
                                    current=current.right
                                else:
                                    parrent.left = current.left
                                    current=current.left
                            else:
                                if current.left == None:
                                    parrent.right = current.right
                                    current=current.right
                                else:
                                    parrent.right = current.left
                                    current=current.left



        parrent=None
        current=self.root       
        helper(data, current, parrent)




        
def join(left, right):
    array=[]
    i,j = 0,0
    while i<len(left) and j<len(right):
        if left[i] < right[j]:
            array.append(left[i])
            i+=1
        else:
            array.append(right[j])
            j+=1
    while i<len(left):
        array.append(left[i])
        i+=1
    while j<len(right):
        array.append(right[j])
        j+=1
    return array


# --- Next Function Block ---

def merge(array):
    if len(array)<=1:
        return array
    mid = len(array)//2
    left = array[:mid]
    right = array[mid:]
    
    return join(merge(left), merge(right))


# --- Next Function Block ---





def validate_bst_traversal(arr) -> bool:
  """
  This function checks if a list represents a valid Binary Search Tree (BST) based on its in-order traversal.

  Args:
      arr: A list containing the in-order traversal of the BST.

  Returns:
      bool: True if the list represents a valid BST, False otherwise.
  """
  prev = float('-inf')  # Initialize previous value to negative infinity
  for val in arr:
    if val <= prev:
      return False  # Current value must be greater than the previous encountered value in in-order traversal
    prev = val
  return True


# --- Next Function Block ---



# -----------------------------------------------------
# Function 1: Minimum Cost Climbing Stairs
def min_cost_climbing_stairs(cost: list) -> int:
    """
    Given a list 'cost' where cost[i] is the cost of stepping on index i,
    calculates the minimum cost to reach the top (beyond the last index).
    Uses a bottom-up DP approach.
    
    Example:
      cost = [1,10,15,7]
      Returns 15.
    """
    n = len(cost)
    dp = [0] * (n + 1)
    # dp[i] is the cost to reach step i.
    for i in range(2, n + 1):
        dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
    return dp[n]


# --- Next Function Block ---


# -----------------------------------------------------
# Function 2: Maximum Sum of Non-Adjacent Numbers (House Robber variant)
def max_non_adjacent_sum(nums: list) -> int:
    """
    Given a list 'nums', returns the maximum sum of a subsequence such that no two numbers are adjacent.
    Uses dynamic programming.
    
    Example:
      nums = [0,0,0,3,2,0]
      Returns the maximum sum possible by selecting non-adjacent numbers.
    """
    n = len(nums)
    if n == 0:
        return 0
    if n == 1:
        return nums[0]
    dp = [0] * (n)
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    for i in range(2, n):
        dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])
    return dp[-1]


# --- Next Function Block ---


# -----------------------------------------------------
# Function 3: Compare Counters of Two String Groups
def compare_string_counters(s1: str, s2: str, s3: str) -> bool:
    """
    Concatenates s1 and s2 and compares the Counter (frequency distribution) with s3.
    
    Example:
      s1 = "aabcc", s2 = "dbbca", s3 = "daabbcbcac"
      Returns True if Counter(s1+s2)==Counter(s3), otherwise False.
    """
    combined = s1 + s2
    return Counter(combined) == Counter(s3)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 4: A DP variant returning a computed value from a list of numbers.
def dp_special(nums: list) -> int:
    """
    Given a list 'nums', builds a dp array where each element is a pair [value, flag].
    The dp recurrence is defined as:
      dp[0] = [nums[0], True]
      For i >= 1:
          If dp[i-2][0] + nums[i] > dp[i-1][0]:
              dp[i] = [dp[i-2][0] + nums[i], <some boolean>]
          Else:
              dp[i] = [dp[i-1][0], <some boolean>]
    Finally, if dp[n-1][1] is True, subtracts min(nums[n-1], nums[0]) from dp[n-1][0].
    Returns the maximum value found in dp.
    
    Note: This snippet is ambiguous; here we follow one interpretation.
    """
    n = len(nums)
    if n == 0:
        return 0
    # Initialize dp array; avoid multiplication pitfalls with lists.
    dp = [[0, False] for _ in range(n)]
    dp[0] = [nums[0], True]
    for i in range(1, n):
        # Use safe index for dp[i-2]
        prev2 = dp[i-2][0] if i - 2 >= 0 else 0
        if prev2 + nums[i] > dp[i-1][0]:
            flag = True if (i - 2 >= 0 and dp[i-2][1]) else False
            dp[i] = [prev2 + nums[i], flag]
        else:
            dp[i] = [dp[i-1][0], dp[i-1][1]]
    if dp[n-1][1]:
        dp[n-1][0] -= min(nums[n-1], nums[0])
    # Find maximum value in dp.
    max_val = max(x[0] for x in dp)
    return max_val


# --- Next Function Block ---


# -----------------------------------------------------
# Function 5: Group Anagrams from a list of words.
def group_anagrams(words: list) -> list:
    """
    Groups anagrams together from the list 'words'.
    
    Example:
      words = ["eat","tea","tan","ate","nat","bat"]
      Returns: [["eat","tea","ate"], ["tan","nat"], ["bat"]]
    """
    groups = {}
    for word in words:
        key = "".join(sorted(word))
        if key in groups:
            groups[key].append(word)
        else:
            groups[key] = [word]
    return list(groups.values())


# --- Next Function Block ---


# -----------------------------------------------------
# Function 6: Two-Sum: Find a pair of numbers that add up to a target.
def two_sum(a: list, t: int):
    """
    Given a list 'a' and a target 't', finds and returns a tuple (x, y)
    such that x + y == t.
    
    Uses a simple nested loop approach.
    If no such pair is found, returns None.
    """
    n = len(a)
    for i in range(n):
        for j in range(i+1, n):
            if a[i] + a[j] == t:
                return (a[i], a[j])
    return None


# --- Next Function Block ---






def minCostClimbingStairs(cost):
    n = len(cost)
    dp = [0] * (n + 1)

    for i in range(2, n + 1):
        dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])

    return dp[n]


# --- Next Function Block ---




# -----------------------------------------------------
# Function 1: Process a string by repeatedly removing its first and last characters.
def process_string(s: str) -> str:
    """
    Given a string s, prints its first character and then repeatedly checks:
      if s[i] equals the last character of s, removes the first and last characters;
      otherwise, stops processing.
    Returns the final processed string.
    
    Example:
      s = "a" → prints "a" and returns "" (if removal occurs).
    """
    if not s:
        return s
    print("First character:", s[0])
    i = 0
    # Continue processing while s is not empty.
    while i < len(s) and len(s) >= 2:
        if s[i] == s[-1]:
            s = s[i+1:-1]
        else:
            break
        i += 1
    return s


# --- Next Function Block ---


# -----------------------------------------------------
# Function 2: Count and remove consecutive pairs summing to a fixed target.
def count_and_remove_pairs(nums: list) -> int:
    """
    Given a list 'nums', defines the target as the sum of the first two elements.
    Then, iterates through the list; whenever a consecutive pair sums to the target,
    increments a counter and removes that pair from the list.
    Returns the count of removed pairs.
    
    Note: This function modifies the list in a loop.
    """
    if len(nums) < 2:
        return 0
    target = nums[0] + nums[1]
    count = 0
    i = 0
    # Use a while loop since we are modifying the list.
    while i < len(nums) - 1:
        if nums[i] + nums[i+1] == target:
            count += 1
            # Remove the pair at indices i and i+1.
            del nums[i:i+2]
            # Reset i to 0 to re-check from start.
            i = 0
        else:
            i += 1
    return count


# --- Next Function Block ---


# -----------------------------------------------------
# Function 3: Count duplicate words that are “wrapped” by themselves.
def count_wrapped_words(words: list) -> int:
    """
    Given a list of words, for each word checks subsequent words:
      if a word's first l characters and last l characters (l = len(word))
      equal the word itself, it is considered a "wrapped" duplicate.
    The function deletes such duplicates and counts the total occurrences (including the original).
    Returns the total count for words that appear more than once in this sense.
    
    Example:
      words = ["abab", "ab"] 
      (If "ab" appears as a prefix and suffix of a duplicate word, it is counted.)
    """
    count = 0
    i = 0
    words = words.copy()  # Work on a copy.
    n = len(words)
    while i < n - 1:
        t = 1
        l = len(words[i])
        j = i + 1
        while j < n:
            # Check if word at j starts and ends with words[i]
            if words[j][:l] == words[i] and words[j][-l:] == words[i]:
                t += 1
                del words[j]
                n -= 1
            else:
                j += 1
        if t > 1:
            count += t
        i += 1
    return count


# --- Next Function Block ---


# -----------------------------------------------------
# Function 4: Convert a fraction to decimal.
def fraction_to_decimal(numerator: int, denominator: int) -> str:
    """
    Converts a fraction to its decimal representation.
    If the fraction is an integer (no remainder), returns the integer as a string.
    Otherwise, returns the floating-point representation as a string.
    
    Example:
      numerator = 4, denominator = 333
    """
    if numerator % denominator == 0:
        return str(numerator // denominator)
    else:
        return str(numerator / denominator)


# --- Next Function Block ---


# -----------------------------------------------------
# Function 5: Find all starting indices of anagrams of p in s.
def find_anagram_indices(s: str, p: str) -> list:
    """
    Finds all start indices in s where an anagram of p appears.
    
    Example:
      s = "cbaebabacd", p = "abc" → returns [0, 6]
    """
    result = []
    l = len(p)
    n = len(s)
    sorted_p = sorted(p)
    for i in range(n - l + 1):
        if sorted(s[i:i+l]) == sorted_p:
            result.append(i)
    return result


# --- Next Function Block ---


# -----------------------------------------------------
# Function 6: Find the minimum window substring of s that contains all characters of t.
def min_window_substring(s: str, t: str) -> str:
    """
    Finds the minimum window in s that contains all characters of t.
    If no such window exists, returns an empty string.
    
    Uses a sliding window approach with two pointers.
    """
    if not s or not t:
        return ""
    dict_t = Counter(t)
    required = len(dict_t)
    l, r = 0, 0
    formed = 0
    window_counts = {}
    ans = float("inf"), None, None
    while r < len(s):
        character = s[r]
        window_counts[character] = window_counts.get(character, 0) + 1
        if character in dict_t and window_counts[character] == dict_t[character]:
            formed += 1
        while l <= r and formed == required:
            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)
            character = s[l]
            window_counts[character] -= 1
            if character in dict_t and window_counts[character] < dict_t[character]:
                formed -= 1
            l += 1
        r += 1
    return "" if ans[0] == float("inf") else s[ans[1]:ans[2]+1]


# --- Next Function Block ---





def join(left, right):
    arr=[]
    i=0
    j=0
    while i<len(left) and j<len(right):
        if left[i]<right[j]:
            arr.append(left[i])
            i+=1
        else:
            arr.append(right[j])
            j+=1
    while i<len(left):
        arr.append(left[i])
        i+=1
    while j<len(right):
        arr.append(right[j])
        j+=1
    
    return arr


# --- Next Function Block ---


def merge(arr):
    if len(arr)<=1:
        return arr
    mid=len(arr)//2
    left=arr[:mid]
    right=arr[mid:]

    return join(merge(left), merge(right))


# --- Next Function Block ---





def swap(arr, left, right):
    temp=arr[left]
    arr[left]=arr[right]
    arr[right]=temp


# --- Next Function Block ---


def helper(arr, start, end):
    if start>=end:
        return arr
    pivot=start
    left=start+1
    right=end

    while left<=right:
        if arr[left]>arr[pivot] and arr[right]<arr[pivot]:
            swap(arr, left, right)
            left+=1
            right-=1
        if arr[left]<=arr[pivot]:
            left+=1
        if arr[right]>=arr[pivot]:
            right-=1
    swap(arr, pivot, right)
    helper(arr, start,right-1)
    helper(arr, right+1, end)
    return arr


# --- Next Function Block ---


def quick(arr):
    start=0
    end=len(arr)-1
    return helper(arr, start, end)


# --- Next Function Block ---



class Node:
    def __init__(self, data=None, next=None):
        self.data=data
        self.next=next

class Stack:
    def __init__(self):
        self.head=None
        self.tail=None

    def push(self, data):
        node=Node(data)
        if self.head==None:
            self.head=node
            self.tail=node
        else:
            node.next=self.head
            self.head=node

    def print(self):
        current=self.head
        while current:
            print(current.data)
            current=current.next

    def pop(self, data):
        if self.head.data==data:
            self.head=self.head.next
            return
        current=self.head
        previous=None
        while current.next:
            previous=current
            current=current.next

            if current.data==data:
                previous.next = current.next
                return

    def enque(self, data):
        node=Node(data)
        if self.head==None:
            self.head=node
            self.tail=node
        else:
            self.tail.next=node
            self.tail=node

    def deque(self):
        if self.head!=None:
            self.head=self.head.next



class Node:
    def __init__(self, data=None, next=None):
        self.data=data
        self.next=next

class HashTable:
    def __init__(self, size):
        self.size=size
        self.table=self.create_baskucts()

    def create_baskucts(self):
        return [[] for _ in range(self.size)]
    
    def set_val(self, key, val):
        hashed_key = hash(key)%self.size

        baskuct = self.table[hashed_key]

        found_key=False
        for index, record in enumerate(baskuct):
            record_key, record_val = record

            if record_key == key:
                found_key=True
                break
        
        if found_key:
            baskuct[index]=(key, val)
        else:
            baskuct.append((key,val))

    def get_val(self, key):

        hashed_key = hash(key)%self.size

        baskuct = self.table[hashed_key]

        found_key=False
        for index, record in enumerate(baskuct):
            record_key, record_val = record

            if record_key==key:
                found_key=True
                break
        
        if found_key:
            print(record_val)
        else:
            print("No record found")
        
    def delete_val(self, key):

        hashed_key = hash(key)%self.size

        baskuct = self.table[hashed_key]

        found_key=False
        for index, record in enumerate(baskuct):
            record_key, record_val = record

            if record_key==key:
                found_key=True
                break
        if found_key:
            baskuct.pop(index)
        return
    



class HashTable:
    def __init__(self, size=None):
        self.size=size
        self.table=self.create()

    def create(self):
        return [[] for _ in range(self.size)]
    
    def set_val(self, key, val):

        hashed_key = hash(key)%self.size

        arr = self.table[hashed_key]

        found_key = False
        for index, record in enumerate(arr):
            record_key, record_val = record

            if record_key==key:
                found_key=True
                break
        if found_key:
            arr[index] = (key, val)
        else:
            arr.append((key, val))

    def get_val(self, key):

        hashed_key = hash(key)%self.size

        arr=self.table[hashed_key]

        found_key=False
        for index, record in enumerate(arr):
            record_key, record_val = record

            if record_key == key:
                found_key=True
                break
        if found_key:
            print(record_val)
        else:
            print("No record found")

    def delete_val(self, key):

        hashed_key=hash(key)%self.size

        arr=self.table[hashed_key]

        found_key=False
        for index, record in enumerate(arr):
            record_key, record_val = record

            if record_key == key:
                arr.pop(index)
                return
            
    def print_val(self):
        for record in self.table:
            try:
                key, val = record[0]    
                print(key, val)
            except:
                continue


    
def join(left, right):
    
    arr=[]
    i=0
    j=0
    while i<len(left) and j<len(right):
        if left[i]<right[j]:
            arr.append(left[i])
            i+=1
        else:
            arr.append(right[j])
            j+=1
    while i<len(left):
        arr.append(left[i])
        i+=1
    while j<len(right):
        arr.append(right[j])
        j+=1
    return arr


# --- Next Function Block ---




def merge(arr):
    if len(arr)<=1:
        return arr
    mid = len(arr)//2
    left = arr[:mid]
    right = arr[mid:]

    return join(merge(left), merge(right))


# --- Next Function Block ---




def min_window_substring(s, t):
    if not s or not t:
        return ""
    
    target_counts = Counter(t)
    required_chars = len(target_counts)
    
    min_length = float('inf')
    min_window = ""
    
    left = 0
    char_count = 0
    window_counts = Counter()
    
    for right, char in enumerate(s):
        window_counts[char] += 1
        if window_counts[char] == target_counts[char]:
            char_count += 1
        
        while char_count == required_chars:
            if right - left + 1 < min_length:
                min_length = right - left + 1
                min_window = s[left:right+1]
            
            if window_counts[s[left]] == target_counts[s[left]]:
                char_count -= 1
            window_counts[s[left]] -= 1
            left += 1
    
    return min_window


# --- Next Function Block ---



class Node:
    def __init__(self, data=None, left=None, right=None):
        self.data=data
        self.left=left
        self.right=right

class Heap:
    def __init__(self):
        self.root = None

    def append(self, data):
        node = Node(data)
        if self.root is None:
            self.root = node
            return
        queue = [self.root]
        while queue:
            current = queue.pop(0)
            if current.left is None:
                current.left = node
                break
            else:
                queue.append(current.left)
            if current.right is None:
                current.right = node
                break
            else:
                queue.append(current.right)
    
    def print(self):
        def helper(current):
            if current:
                print(current.data)
                helper(current.left)
                helper(current.right)
            
        helper(self.root)
    


class Node:
    def __init__(self, data=None, left=None, right=None):
        self.data=data
        self.left=left
        self.right=right

class BinaryTree:
    def __init__(self):
        self.root=None

    def append(self, data):
        node = Node(data)
        if self.root is None:
            self.root=node
            return
        queue=[self.root]
        while queue:
            current=queue.pop(0)
            if current.left is None:
                current.left=node
                break
            else:
                queue.append(current.left)
            if current.right is None:
                current.right=node
                break
            else:
                queue.append(current.right)

    def print(self):
        level=0
        def helper(current, count):
            nonlocal level
            if current:
                count+=1
                level=max(level, count)
                print(current.data)
                helper(current.left, count)
                helper(current.right, count)
        helper(self.root, 0)



class Node:
    def __init__(self, data=None, left=None, right=None):
        self.data=data
        self.left=left
        self.right=right

class BinarySearchTree:
    def __init__(self):
        self.root=None

    def append(self, data):
        node=Node(data)
        if self.root is None:
            self.root=node
            return
        current=self.root
        while True:
            if data < current.data:
                if current.left is None:
                    current.left=node
                    break
                else:
                    current=current.left
            else:
                if current.right is None:
                    current.right=node
                    break
                else:
                    current=current.right
        
    def print(self):
        level=0
        def helper(current, count):
            nonlocal level
            if current:
                count+=1
                level=max(level, count)
                print(current.data)
                helper(current.left, count)
                helper(current.right, count)
        helper(self.root, 0)


class HashMap:
    def __init__(self, size=None):
        self.size=size
        self.table = self.create()

    def create(self):
        return [[] for _ in range(self.size)]
    
    def set_value(self, key, value):
        hashed = hash(key)%self.size

        bucket = self.table[hashed]

        found_key = False
        for index, record in enumerate(bucket):
            record_key, record_value = record
            if key == record_key:
                found_key = True
                break

        if found_key:
            bucket[index] = (key, value)
        else:
            bucket.append((key,value))

    def print(self):
        for x in self.table:
            try:
                key, value = x[0]
                print(key, value)
            except:
                continue
    



class HashMap:
    def __init__(self, size=None):
        self.size=size
        self.table=self.create()

    def create(self):
        return [[] for _ in range(self.size)]
    
    def append(self, key, value):
        hashed = hash(key)%self.size
        bucket = self.table[hashed]

        found_key=False
        for index, random in enumerate(bucket):
            random_key, random_value = random

            if key == random_key:
                found_key = True
                break
        
        if found_key:
            bucket[index]=(key,value)
        else:
            bucket.append((key, value))

    def print(self):
        for x in self.table:
            key, value = x[0]
            print(key, value)




class Heap:
    def __init__(self):
        self.heap=[]

    def parent(self, i):
        return (i-1)//2
    
    def left_child(self, i):
        return 2*i+1
    
    def right_child(self, i):
        return 2*i+2
    
    def append(self, data):
        self.heap.append(data)
        self.shift_up(len(self.heap)-1)

    def shift_up(self, i):
        while i>0 and self.heap[self.parent(i)] > self.heap[i]:
            self.heap[self.parent(i)], self.heap[i] = self.heap[i], self.heap[self.parent(i)]
            i = self.parent(i)

    def shift_down(self, i):
        min_index=i
        left=self.left_child(i)
        right=self.right_child(i)

        if left < len(self.heap) and self.heap[left] < self.heap[min_index]:
            min_index = left
        if right < len(self.heap) and self.heap[right] < self.heap[min_index]:
            min_index = right

        if min_index != i:
            self.heap[i], self.heap[min_index] = self.heap[min_index], self.heap[i]
            self.shift_down(min_index)

    def remove(self, data):
        for i, j in enumerate(self.heap):
            if i == len(self.heap)-1 and j == data:
                self.heap.pop(i)
                break
            elif j == data:
                self.heap[i] = self.heap[len(self.heap)-1]
                self.heap.pop(len(self.heap)-1)
                self.shift_down(i)
                self.shift_up(i)
                break
        
    
    def print(self):
        print(self.heap)




class Heap:

    def __init__(self):
        self.heap=[]

    def parent(self, i):
        return (i-1)//2
    
    def left_child(self, i):
        return 2*i+1
    
    def right_child(self, i):
        return 2*i+2
    
    def append(self, data):
        self.heap.append(data)
        self.shift_up(len(self.heap)-1)

    def remove(self, data):
        for i, x in enumerate(self.heap):
            if x == data:
                self.heap[i] = self.heap[len(self.heap)-1]
                self.heap.pop(len(self.heap)-1)
                self.shift_down(0)
    
                
    def shift_down(self, i):
        min_index = i
        left = self.left_child(i)
        right = self.right_child(i)

        while left < len(self.heap) and self.heap[left] < self.heap[min_index]:
            min_index = left
        while right < len(self.heap) and self.heap[right] < self.heap[min_index]:
            min_index = right
        if min_index != i:
            self.heap[i], self.heap[min_index] = self.heap[min_index], self.heap[i]
            self.shift_down(min_index)

    def shift_up(self, i):
        while i>0 and self.heap[self.parent(i)] > self.heap[i]:
            self.heap[self.parent(i)], self.heap[i] = self.heap[i], self.heap[self.parent(i)]
            i = self.parent(i)

    def print(self):
        print(self.heap)





class Node:
    def __init__(self, data=None, left=None, right=None):
        self.data=data
        self.left=left
        self.right=right

class BinarySearchTree:
    def __init__(self):
        self.root=None

    def append(self, data):
        node=Node(data)
        if self.root is None:
            self.root=node
            return
        current=self.root
        while True:
            if data < current.data:
                if current.left is None:
                    current.left=node
                    break
                else:
                    current=current.left
            else:
                if current.right is None:
                    current.right=node
                    break
                else:
                    current=current.right

    def print(self):
        level=0
        def helper(current, count):
            nonlocal level
            if current:
                count+=1
                level=max(level, count)
                print(current.data)
                helper(current.left, count)
                helper(current.right, count)
        helper(self.root,0)
        print("Depth : ",level)

    def remove(self, data):
        def get_min(current):
            if current.left is None:
                return current.data
            else:
                return get_min(current.left)
        
        def helper(data, current, parent):
            while current:
                if data < current.data:
                    parent=current
                    current=current.left
                elif data > current.data:
                    parent=current
                    current=current.right
                else:
                    if current.left and current.right:
                        current.data = get_min(current.right)
                        return helper(current.data, current.right, current)
                    else:
                        if parent is None:
                            if current.left is None:
                                self.root = current.right
                            else:
                                self.root = current.left
                        else:
                            if parent.left == current:
                                if current.left == None:
                                    parent.left = current.right
                                    current=current.right
                                else:
                                    parent.left = current.left
                                    current=current.left
                            else:
                                if current.left == None:
                                    parent.right = current.right
                                    current=current.right
                                else:
                                    parent.right = current.left
                                    current=current.left
        helper(data, self.root, None)



class Node:
    def __init__(self, data=None, left=None, right=None):
        self.data=data
        self.left=left
        self.right=right

class BinarySearchTree:
    def __init__(self):
        self.root=None

    def append(self, data):
        node=Node(data)
        if self.root is None:
            self.root=node
            return
        current=self.root
        while True:
            if data < current.data:
                if current.left:
                    current=current.left
                else:
                    current.left=node
                    break
            else:
                if current.right:
                    current=current.right
                else:
                    current.right=node
                    break

    def print(self):
        def helper(current):
            if current:
                print(current.data)
                helper(current.left)
                helper(current.right)
        helper(self.root)

    
    def remove(self, data):
        def get_min(current):
            if current.left:
                return get_min(current.left)
            else:
                return current.data
        
        def helper(data, current, parrent):
            while current:
                if data < current.data:
                    parrent=current
                    current=current.left
                elif data > current.data:
                    parrent=current
                    current=current.right
                else:
                    if current.left and current.right:
                        current.data=get_min(current.right)
                        return helper(current.data, current.right, current)
                    else:
                        if parrent is None:
                            if current.left:
                                self.root=current.left
                            else:
                                self.root=current.right
                        else:
                            if current == parrent.left:
                                if current.left:
                                    parrent.left=current.left
                                    current=current.left
                                else:
                                    parrent.left=current.right
                                    current=current.right
                            else:
                                if current.left:
                                    parrent.right=current.left
                                    current=current.left
                                else:
                                    parrent.right=current.right
                                    current=current.right
        helper(data, self.root, None)

    def delete(self, data):
        pass


class Node:
    def __init__(self, data=None, left=None, right=None):
        self.data=data
        self.left=left
        self.right=right

class BinarySearchTree:
    def __init__(self):
        self.root=None

    def append(self, data):
        node=Node(data)
        if self.root is None:
            self.root=node
            return
        current=self.root
        while True:
            if data < current.data:
                if current.left:
                    current=current.left
                else:
                    current.left=node
                    break
            else:
                if current.right:
                    current=current.right
                else:
                    current.right=node
                    break
    
    def remove(self, data):
        def get_min(current):
            if current.left:
                return get_min(current.left)
            else:
                return current.data
        
        def helper(data, current, parent):
            while current:
                if data < current.data:
                    parent=current
                    current=current.left
                elif data > current.data:
                    parent=current
                    current=current.right
                else:
                    if current.left and current.right:
                        current.data=get_min(current.right)
                        return helper(current.data, current.right, current)
                    else:
                        if parent is None:
                            if current.left:
                                self.root=current.left
                            else:
                                self.root=current.right
                        else:
                            if parent.left == current:
                                if current.left:
                                    parent.left=current.left
                                    current=current.left
                                else:
                                    parent.left=current.right
                                    current=current.right
                            else:
                                if current.left:
                                    parent.right=current.left
                                    current=current.left
                                else:
                                    parent.right=current.right
                                    current=current.right
        helper(data, self.root, None)

    
    def print(self):
        def helper(current):
            if current:
                print(current.data)
                helper(current.left)
                helper(current.right)
        helper(self.root)

    def find(self, data):
        value=float('inf')
        check=float('inf')
        def helper(current):
            nonlocal value
            nonlocal check
            if current:
                if abs(current.data - data)<check:
                    check=abs(current.data - data)
                    value=current.data
                helper(current.left)
                helper(current.right)
        helper(self.root)
        print(value)




class Heap:
    def __init__(self):
        self.heap=[]
        self.length=0

    def parent(self, i):
        return (i-1)//2
    
    def left_child(self, i):
        return 2*i+1
    
    def right_child(self, i):
        return 2*i+2

    def append(self, data):
        self.heap.append(data)
        self.length+=1
        self.shift_up(self.length-1)

    def shift_up(self, i):
        while i>0 and self.heap[self.parent(i)] > self.heap[i]:
            self.heap[self.parent(i)], self.heap[i] = self.heap[i], self.heap[self.parent(i)]
            i=self.parent(i)

    def shift_down(self, i):
        min_index=i
        left=self.left_child(i)
        right=self.right_child(i)
        while left < self.length and self.heap[left] < self.heap[min_index]:
            min_index=left
        while right < self.length and self.heap[right] < self.heap[min_index]:
            min_index=right
        if min_index != i:
            self.heap[i], self.heap[min_index] = self.heap[min_index], self.heap[i]
            self.shift_down(min_index)

    def remove(self, data):
        for i, x in enumerate(self.heap):
            if x == data:
                self.heap[i]=self.heap[self.length-1]
                self.heap.pop(self.length-1)
                self.length-=1
                self.shift_down(i)
                self.shift_up(i)
                break

    def print(self):
        for x in self.heap:
            print(x)

    def build(self, arr):
        self.length+=len(arr)
        self.heap.extend(arr)
        self.shift_down(0)
        self.shift_up(self.length-1)




class Node:
    def __init__(self, data=None, left=None, right=None):
        self.data=data
        self.left=left
        self.right=right

class BinaryTree:
    def __init__(self):
        self.root=None

    def append(self, data):
        node=Node(data)
        if self.root is None:
            self.root=node
            return
        queue=[self.root]
        while queue:
            current=queue.pop(0)
            if current.left:
                queue.append(current.left)
            else:
                current.left=node
                break
            if current.right:
                queue.append(current.right)
            else:
                current.right=node
                break

    def print(self):
        def helper(current):
            if current:
                print(current.data)
                helper(current.left)
                helper(current.right)
        helper(self.root)
    

class Heap:
    def __init__(self):
        self.heap=[]
        self.length=0

    def parrent(self, i):
        return (i-1)//2

    def left_child(self, i):
        return 2*i+1
    
    def right_child(self, i):
        return 2*i+2

    def append(self, data):
        self.heap.append(data)
        self.length+=1
        self.shift_up(self.length-1)

    def shift_up(self, i):
        while i>0 and self.heap[self.parrent(i)] < self.heap[i]:
            self.heap[self.parrent(i)], self.heap[i] =  self.heap[i], self.heap[self.parrent(i)]
            i = self.parrent(i)
    
    def shift_down(self, i):
        min_index=i
        left=self.left_child(i)
        right=self.right_child(i)
        if left<self.length and self.heap[left] > self.heap[min_index]:
            min_index=left
        if right<self.length and self.heap[right] > self.heap[min_index]:
            min_index=right
        if min_index != i:
            self.heap[i], self.heap[min_index] = self.heap[min_index], self.heap[i]
            self.shift_down(min_index)
    
    def helper(self,i,j):
        min_index=i
        left=self.left_child(i)
        right=self.right_child(i)
        if left<self.length-j and self.heap[left] > self.heap[min_index]:
            min_index=left
        if right<self.length-j and self.heap[right] > self.heap[min_index]:
            min_index=right
        if min_index != i:
            self.heap[i], self.heap[min_index] = self.heap[min_index], self.heap[i]
            self.helper(min_index, j)

    def sort(self):
        i=0
        while i<self.length:
            self.helper(0,i)
            self.heap[0], self.heap[-i-1] = self.heap[-i-1], self.heap[0]
            i+=1
        

    def print(self):
        for x in self.heap:
            print(x)


# patterns.py
import functools

# ------------------------------
# Custom Heap class (simple implementation)
class Heap:
    def __init__(self):
        self.data = []
        
    def append(self, value):
        self.data.append(value)
        
    def sort(self):
        self.data.sort()
        
    def print(self):
        print(self.data)

# ------------------------------
# Function 1: Demo using a custom Heap to sort an array.
def demo_heap_sort(arr: list) -> None:
    """
    Given a list 'arr', appends its elements to a Heap instance,
    sorts the heap, and prints the sorted array.
    
    Example:
      arr = [9,4,9,6,1,3,0,8,6,2]
    """
    heap = Heap()
    for num in arr:
        heap.append(num)
    heap.sort()
    heap.print()


# --- Next Function Block ---


# ------------------------------
# Function 2: Custom Binary Search Demo
def binary_search_demo(arr: list, target: int) -> int:
    """
    Given a sorted list 'arr' and a target value, performs a binary search
    using a custom non-standard approach:
      - Initialize index i as the middle index.
      - If target < arr[i], update i to the midpoint of left and i.
      - If target > arr[i], update i to the midpoint of i and right.
      - Counts iterations and stops after a number of iterations equal to the length of arr.
      
    If the target is found, prints the index and returns it; otherwise prints the iteration count and returns -1.
    
    Example:
      arr = [1,2,4,5,6,7,8,9,10], target = 11
    """
    n = len(arr)
    left = 0
    right = n
    i = n // 2
    count = 0
    while True:
        count += 1
        if count >= n:
            print("Iterations:", count)
            return -1
        if target == arr[i]:
            print("Found at index:", i, "after", count, "iterations")
            return i
        elif target < arr[i]:
            right = i
            # Move i to the midpoint between left and current i.
            i = left + (i - left) // 2
        else:  # target > arr[i]
            left = i
            # Move i to the midpoint between current i and right.
            i = i + (right - i) // 2
        
        if left >= right - 1:
            print("Not found after", count, "iterations")
            return -1


# --- Next Function Block ---


# ------------------------------


class Node:
    def __init__(self, data=None):
        self.child={}
        self.end=False

class Trie:
    def __init__(self):
        self.root=Node()

    def append(self, data):
        current=self.root
        parrent=None
        for key in data:
            parrent=current
            if key in current.child:
                current=current.child[key]
            else:
                current.child[key]=Node()
                current=current.child[key]
        parrent.end=True

    def print(self):
        def helper(current):
            if current:
                for key in current.child:
                    print(key)
                    if current.end:
                        print()
                    helper(current.child[key])
        helper(self.root)

    def exist(self, data):
        current=self.root
        parrent=None
        for key in data:
            parrent=current
            if current and key not in current.child:
                return(False)
            current=current.child[key]
        if parrent and parrent.end:
            return(True)
        else:
            return(False)
        
        


class Node:
    def __init__(self):
        self.child={}
        self.end=False

class Trie:
    def __init__(self):
        self.root=Node()

    def append(self, data):
        current=self.root
        parent=None
        for key in data:
            parent=current
            if key in current.child:
                current=current.child[key]
            else:
                current.child[key]=Node()
                current=current.child[key]
        parent.end=True
            
    
    def search(self, data):
        current=self.root
        parent=None
        for key in data:
            parent=current
            if current and key in current.child:
                current=current.child[key]
            else:
                return False
        if parent and parent.end:
            return True
        return False
    
    def print(self):
        def helper(current):
            if current:
                for key in current.child:
                    print(key,end="")
                    if current.end:
                        print()
                    helper(current.child[key])
        helper(self.root)

    def remove(self, data):
        current=self.root
        parent=None
        for key in data:
            parent=current
            if current and key in current.child:
                current=current.child[key]
            else:
                return
        parent.end=False

    
        

class Vertex:
    def __init__(self, data=None):
        self.data=data
        self.edge={}

class Graph:
    def __init__(self):
        self.root=None
        self.index={}

    def append(self, data, edge):
        if self.root is None:
            self.root=Vertex(data)
            self.index[data]=self.root
            self.root.edge[edge]=Vertex(edge)
            self.index[edge]=self.root.edge[edge]
            return
        if data not in self.index:
            vertex=Vertex(data)
            self.index[data]=vertex
            if edge not in self.index:
                vertex.edge[edge]=Vertex(edge)
                self.index[edge]=vertex.edge[edge]
            else:
                vertex.edge[edge]=self.index[edge]
        else:
            vertex=self.index[data]
            
            if edge not in self.index:
                vertex.edge[edge]=Vertex(edge)
                self.index[edge]=vertex.edge[edge]
            else:
                vertex.edge[edge]=self.index[edge]

    def print(self):
        dict={}
        def helper(current):
            nonlocal dict
            if current:
                for edge in current.edge:
                    print(current.data)
                    if current not in dict:
                        dict[current]=current.data
                        helper(current.edge[edge])
        for current in self.index:
            helper(self.index[current])



class Vertex:
    def __init__(self, data=None):
        self.data=data
        self.edges={}

class Graph:
    def __init__(self):
        self.index={}

    def append(self, data, edge):
        if data in self.index:
            vertex=self.index[data]
        else:
            vertex=Vertex(data)
            self.index[data]=vertex
        if edge in self.index:
            node=self.index[edge]
            vertex.edges[edge]=node
        else:
            node=Vertex(edge)
            self.index[edge]=node
            vertex.edges[edge]=node

    def print(self):
        dict={}
        def helper(current):
            nonlocal dict
            if current:
                for edge in current.edges:
                    print(current.data, end=" ")
                    if current not in dict:
                        dict[current]=current.data
                        helper(current.edges[edge])
                    else:
                        break
        for current in self.index:
            print(self.index[current])
            helper(self.index[current])





# -----------------------------------------------------
# Function 1: Process two strings by removing matching characters.
def process_order_and_string(order: str, s: str) -> str:
    """
    Iterates over the characters in 'order'. For each character:
      - If the character exists in 's', remove its first occurrence from 's'.
      - Otherwise, remove its first occurrence from 'order'.
    Finally, returns the concatenation of the modified order and s.
    
    Example:
      order = "kqep", s = "pekeq"
      (The function processes both strings and returns the concatenated result.)
    """
    order = list(order)
    s = list(s)
    i = 0
    while i < len(order):
        ch = order[i]
        if ch in s:
            s.pop(s.index(ch))
        else:
            order.pop(i)
            # Do not increment i if we removed the current character
            continue
        i += 1
    return "".join(order + s)
